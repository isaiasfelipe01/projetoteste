[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sistemas Inteligentes para Gestão de Riscos e Previsões - SIGERIP",
    "section": "",
    "text": "O projeto tem como objetivo principal impactar a comunidade interna e externa por meio do desenvolvimento de sistemas inteligentes de apoio à decisão com enfoque na gestão de riscos e previsão de dados demográficos e atuariais. Objetivos específicos: Dessa maneira, os objetivos específicos são: - Oportunizar à equipe do projeto uma formação cidadã e profissional ao resolver um problema real da sociedade, por meio de um sistema inteligente para web. - Promover a capacitação dos discentes da UFPB, integrando ensino, extensão e pesquisa a partir de uma aplicação de projeção de mortalidade humana. - Desenvolver uma aplicação web interativa a qual disponibilizará dados demográficos de expectativa de vida, quantitativo populacional, taxas de mortalidade, projeções dessas informações e de cálculos atuariais. - Disponibilizar o sistema desenvolvido na web de forma gratuita para toda a sociedade. - Realizar oficinas para capacitar a comunidade externa a tomar melhor decisões dos dados e projeções de taxa de mortalidade e expectativa de vida.\n\nviewof contatos = {\n  // Elementos do modal\n  const overlay = document.createElement('div');\n  const modal = document.createElement('div');\n  const closeBtn = document.createElement('span');\n  const content = document.createElement('div');\n\n  // Conteúdo do modal\n  content.innerHTML = `\n  &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css\"&gt;\n  \n    \n    &lt;h3 style=\"margin:0;color:#2c3e50;padding-bottom:15px;border-bottom:2px solid #3498db\"&gt;Equipe SIGERIP&lt;/h3&gt;\n    &lt;div style=\"margin-top:20px;max-width: 450px;height: 450px;padding-right: 10px;overflow-y: scroll;overflow-x: hidden;line-height:1.6\"&gt;\n      &lt;ul class=\"lista-equipe\"&gt;\n\n      &lt;!-- Prof Filipe --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Filipe C. L. Duarte&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Coordenador - Tábuas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/filipeclduarte/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; filipe_pb_duarte@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Prof Gustavo --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Gustavo C. Xavier&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Coordenador Adjunto - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/gcxavier/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; gustavocorreiaxavier@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Prof Herick --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Herick C. G. Oliveira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Colaborador - Mortalidade intantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/herickcidarta/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; hcidarta@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n      \n      &lt;!-- TODO: FALTA EMAIL E LINKEDIN Tassia --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Tassia T. S. Oliveira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Colaboradora&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; email.aqui\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: falta linkedin Beatriz--&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Beatriz G. Olinpio&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Voluntária - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; bgo@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Cleo --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Cleo D. Anacleto&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Bolsista - Tábuas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/cleo-decker-anacleto-66a69b133/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; cleodecker@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Cristiane --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Cristiane S. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Voluntária - Tábuas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; css3@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: FALTA LINKEDIN Gabrielle --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Gabrielle S. M. Vieira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Voluntária - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; gabrielle.samara230@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Igor --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Igor B. Kutelak&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Voluntário - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/igor-kutelak-20b10a194/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; Kutelak.igor@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Isaias --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Isaias F. S. Sousa&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Voluntário - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/isa%C3%ADas-felipe-silva-de-sousa-453902327/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; isaias.felipe@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: FALTA LINKEDIN Jefferson --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Jefferson G. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Voluntário - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; jeffeersonguilhermeh@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Stênio --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;João P. S. F. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Voluntário - Tábuas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/jo%C3%A3o-pedro-st%C3%AAnio-2861071b3/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; jpsfs2@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!--TODO: FALTA LINKEDIN Nathiely --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Nathiely B. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Voluntária - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; nathiely.silva@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n      \n    &lt;/ul&gt;\n    &lt;/div&gt;\n  `;\n\n  // Estilização do modal\n  Object.assign(overlay.style, {\n    display: 'none',\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0,0,0,0.5)',\n    zIndex: 1000\n  });\n\n  Object.assign(modal.style, {\n    position: 'fixed',\n    top: '50%',\n    left: '50%',\n    transform: 'translate(-50%, -50%)',\n    backgroundColor: 'white',\n    padding: '25px',\n    borderRadius: '10px',\n    width: 'min(90%, 500px)',\n    boxShadow: '0 5px 15px rgba(0,0,0,0.2)'\n  });\n\n  Object.assign(closeBtn.style, {\n    position: 'absolute',\n    right: '15px',\n    top: '10px',\n    cursor: 'pointer',\n    fontSize: '28px',\n    color: '#666',\n    transition: 'color 0.2s'\n  });\n\n  // Montagem do modal\n  closeBtn.innerHTML = '&times;';\n  modal.append(closeBtn, content);\n  overlay.append(modal);\n  document.body.append(overlay);\n\n  // Container para centralização\n  const container = document.createElement('div');\n  Object.assign(container.style, {\n    display: 'flex',\n    justifyContent: 'center',\n    width: '100%',\n    margin: '30px 0'\n  });\n\n  // Criação do botão centralizado\n  const btn = Inputs.button(\"👥 Conheça Nossa Equipe\");\n  btn.className = \"botao-equipe\"; // ← Adicione esta linha\n\n  // Efeitos de hover\n  btn.addEventListener('mouseenter', () =&gt; {\n    btn.style.transform = 'scale(1.05)';\n    btn.style.boxShadow = '0 6px 8px rgba(0,0,0,0.2)';\n  });\n\n  btn.addEventListener('mouseleave', () =&gt; {\n    btn.style.transform = 'scale(1)';\n    btn.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)';\n  });\n\n  // Event listeners\n  btn.addEventListener('click', () =&gt; overlay.style.display = 'block');\n  closeBtn.addEventListener('click', () =&gt; overlay.style.display = 'none');\n  overlay.addEventListener('click', e =&gt; e.target === overlay && (overlay.style.display = 'none'));\n  document.addEventListener('keydown', e =&gt; e.key === 'Escape' && (overlay.style.display = 'none'));\n\n  // Adiciona botão ao container\n  container.append(btn);\n  \n  return container;\n}\n\n\n\n\n\n\nhtml`\n&lt;style&gt;\n  /* Estilos Gerais */\n  .equipe-container {\n    display: flex;\n    justify-content: center;\n    margin: 40px 0;\n  }\n\n  .botao-equipe {\n    padding: 15px 35px;\n    background: linear-gradient(135deg, #2c3e50, #3498db);\n    color: white;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 18px;\n    font-weight: 600;\n    transition: all 0.3s ease;\n    box-shadow: 0 4px 15px rgba(44, 62, 80, 0.2);\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n\n  .botao-equipe:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px rgba(44, 62, 80, 0.3);\n  }\n\n  .modal-overlay {\n    display: none;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0,0,0,0.5);\n    z-index: 1000;\n    backdrop-filter: blur(3px);\n  }\n\n  .modal-equipe {\n    position: relative;\n    background: white;\n    padding: 30px;\n    border-radius: 12px;\n    width: 90%;\n    max-width: 600px;\n    margin: 5% auto;\n    box-shadow: 0 10px 30px rgba(0,0,0,0.2);\n  }\n\n  .lista-equipe {\n    list-style: none;\n    padding: 0;\n    margin: 20px 0;\n  }\n\n  .membro-equipe {\n    padding: 15px;\n    margin: 10px 0;\n    background: #f8f9fa;\n    border-radius: 8px;\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    transition: transform 0.2s;\n  }\n\n  .membro-equipe:hover {\n    transform: translateX(10px);\n    background: #f1f3f5;\n  }\n\n  .fechar-modal {\n    position: absolute;\n    top: 15px;\n    right: 20px;\n    font-size: 28px;\n    cursor: pointer;\n    color: #666;\n    transition: color 0.2s;\n  }\n\n  .fechar-modal:hover {\n    color: #333;\n  }\n  .botao-equipe {\n  background: #343a40 !important; /* Azul mais claro */\n  color: #ffffff !important;\n  /* mantém o restante das propriedades */\n}\n&lt;/style&gt;\n\n&lt;script&gt;\n  // JavaScript Corrigido\n  document.addEventListener('DOMContentLoaded', () =&gt; {\n    const btnAbrir = document.getElementById('btnEquipe');\n    const btnFechar = document.getElementById('fecharModal');\n    const modal = document.getElementById('modalEquipe');\n\n    if(btnAbrir && btnFechar && modal) {\n      // Abrir modal\n      btnAbrir.addEventListener('click', () =&gt; {\n        modal.style.display = 'block';\n      });\n\n      // Fechar modal\n      btnFechar.addEventListener('click', () =&gt; {\n        modal.style.display = 'none';\n      });\n\n      // Fechar ao clicar fora\n      window.addEventListener('click', (e) =&gt; {\n        if(e.target === modal) {\n          modal.style.display = 'none';\n        }\n      });\n\n      // Fechar com ESC\n      document.addEventListener('keydown', (e) =&gt; {\n        if(e.key === 'Escape') {\n          modal.style.display = 'none';\n        }\n      });\n    } else {\n      console.error('Verifique os IDs dos elementos:', {btnAbrir, btnFechar, modal});\n    }\n  });\n  function copiarEmail() {\n        // Obtém o conteúdo do elemento que contém o email\n        const email = document.getElementById(\"email\").textContent;\n        \n        // Copia o email para a área de transferência usando a Clipboard API\n        navigator.clipboard.writeText(email)\n          .then(() =&gt; {\n            // Exibe uma mensagem de confirmação\n            alert(\"Email copiado com sucesso!\");\n          })\n          .catch(err =&gt; {\n            console.error(\"Erro ao copiar o email:\", err);\n          });\n      }\n&lt;/script&gt;\n`"
  },
  {
    "objectID": "index.html#objetivo",
    "href": "index.html#objetivo",
    "title": "Sistemas Inteligentes para Gestão de Riscos e Previsões - SIGERIP",
    "section": "",
    "text": "O projeto tem como objetivo principal impactar a comunidade interna e externa por meio do desenvolvimento de sistemas inteligentes de apoio à decisão com enfoque na gestão de riscos e previsão de dados demográficos e atuariais. Objetivos específicos: Dessa maneira, os objetivos específicos são: - Oportunizar à equipe do projeto uma formação cidadã e profissional ao resolver um problema real da sociedade, por meio de um sistema inteligente para web. - Promover a capacitação dos discentes da UFPB, integrando ensino, extensão e pesquisa a partir de uma aplicação de projeção de mortalidade humana. - Desenvolver uma aplicação web interativa a qual disponibilizará dados demográficos de expectativa de vida, quantitativo populacional, taxas de mortalidade, projeções dessas informações e de cálculos atuariais. - Disponibilizar o sistema desenvolvido na web de forma gratuita para toda a sociedade. - Realizar oficinas para capacitar a comunidade externa a tomar melhor decisões dos dados e projeções de taxa de mortalidade e expectativa de vida.\n\nviewof contatos = {\n  // Elementos do modal\n  const overlay = document.createElement('div');\n  const modal = document.createElement('div');\n  const closeBtn = document.createElement('span');\n  const content = document.createElement('div');\n\n  // Conteúdo do modal\n  content.innerHTML = `\n  &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css\"&gt;\n  \n    \n    &lt;h3 style=\"margin:0;color:#2c3e50;padding-bottom:15px;border-bottom:2px solid #3498db\"&gt;Equipe SIGERIP&lt;/h3&gt;\n    &lt;div style=\"margin-top:20px;max-width: 450px;height: 450px;padding-right: 10px;overflow-y: scroll;overflow-x: hidden;line-height:1.6\"&gt;\n      &lt;ul class=\"lista-equipe\"&gt;\n\n      &lt;!-- Prof Filipe --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Filipe C. L. Duarte&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Coordenador - Tábuas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/filipeclduarte/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; filipe_pb_duarte@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Prof Gustavo --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Gustavo C. Xavier&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Coordenador Adjunto - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/gcxavier/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; gustavocorreiaxavier@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Prof Herick --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Herick C. G. Oliveira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Colaborador - Mortalidade intantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/herickcidarta/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; hcidarta@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n      \n      &lt;!-- TODO: FALTA EMAIL E LINKEDIN Tassia --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Tassia T. S. Oliveira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Colaboradora&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; email.aqui\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: falta linkedin Beatriz--&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Beatriz G. Olinpio&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Voluntária - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; bgo@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Cleo --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Cleo D. Anacleto&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Bolsista - Tábuas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/cleo-decker-anacleto-66a69b133/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; cleodecker@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Cristiane --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Cristiane S. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Voluntária - Tábuas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; css3@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: FALTA LINKEDIN Gabrielle --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Gabrielle S. M. Vieira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Voluntária - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; gabrielle.samara230@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Igor --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Igor B. Kutelak&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Voluntário - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/igor-kutelak-20b10a194/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; Kutelak.igor@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Isaias --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Isaias F. S. Sousa&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Voluntário - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/isa%C3%ADas-felipe-silva-de-sousa-453902327/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; isaias.felipe@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: FALTA LINKEDIN Jefferson --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Jefferson G. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Voluntário - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; jeffeersonguilhermeh@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Stênio --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;João P. S. F. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Voluntário - Tábuas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/jo%C3%A3o-pedro-st%C3%AAnio-2861071b3/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; jpsfs2@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!--TODO: FALTA LINKEDIN Nathiely --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Nathiely B. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Voluntária - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; nathiely.silva@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n      \n    &lt;/ul&gt;\n    &lt;/div&gt;\n  `;\n\n  // Estilização do modal\n  Object.assign(overlay.style, {\n    display: 'none',\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0,0,0,0.5)',\n    zIndex: 1000\n  });\n\n  Object.assign(modal.style, {\n    position: 'fixed',\n    top: '50%',\n    left: '50%',\n    transform: 'translate(-50%, -50%)',\n    backgroundColor: 'white',\n    padding: '25px',\n    borderRadius: '10px',\n    width: 'min(90%, 500px)',\n    boxShadow: '0 5px 15px rgba(0,0,0,0.2)'\n  });\n\n  Object.assign(closeBtn.style, {\n    position: 'absolute',\n    right: '15px',\n    top: '10px',\n    cursor: 'pointer',\n    fontSize: '28px',\n    color: '#666',\n    transition: 'color 0.2s'\n  });\n\n  // Montagem do modal\n  closeBtn.innerHTML = '&times;';\n  modal.append(closeBtn, content);\n  overlay.append(modal);\n  document.body.append(overlay);\n\n  // Container para centralização\n  const container = document.createElement('div');\n  Object.assign(container.style, {\n    display: 'flex',\n    justifyContent: 'center',\n    width: '100%',\n    margin: '30px 0'\n  });\n\n  // Criação do botão centralizado\n  const btn = Inputs.button(\"👥 Conheça Nossa Equipe\");\n  btn.className = \"botao-equipe\"; // ← Adicione esta linha\n\n  // Efeitos de hover\n  btn.addEventListener('mouseenter', () =&gt; {\n    btn.style.transform = 'scale(1.05)';\n    btn.style.boxShadow = '0 6px 8px rgba(0,0,0,0.2)';\n  });\n\n  btn.addEventListener('mouseleave', () =&gt; {\n    btn.style.transform = 'scale(1)';\n    btn.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)';\n  });\n\n  // Event listeners\n  btn.addEventListener('click', () =&gt; overlay.style.display = 'block');\n  closeBtn.addEventListener('click', () =&gt; overlay.style.display = 'none');\n  overlay.addEventListener('click', e =&gt; e.target === overlay && (overlay.style.display = 'none'));\n  document.addEventListener('keydown', e =&gt; e.key === 'Escape' && (overlay.style.display = 'none'));\n\n  // Adiciona botão ao container\n  container.append(btn);\n  \n  return container;\n}\n\n\n\n\n\n\nhtml`\n&lt;style&gt;\n  /* Estilos Gerais */\n  .equipe-container {\n    display: flex;\n    justify-content: center;\n    margin: 40px 0;\n  }\n\n  .botao-equipe {\n    padding: 15px 35px;\n    background: linear-gradient(135deg, #2c3e50, #3498db);\n    color: white;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 18px;\n    font-weight: 600;\n    transition: all 0.3s ease;\n    box-shadow: 0 4px 15px rgba(44, 62, 80, 0.2);\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n\n  .botao-equipe:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px rgba(44, 62, 80, 0.3);\n  }\n\n  .modal-overlay {\n    display: none;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0,0,0,0.5);\n    z-index: 1000;\n    backdrop-filter: blur(3px);\n  }\n\n  .modal-equipe {\n    position: relative;\n    background: white;\n    padding: 30px;\n    border-radius: 12px;\n    width: 90%;\n    max-width: 600px;\n    margin: 5% auto;\n    box-shadow: 0 10px 30px rgba(0,0,0,0.2);\n  }\n\n  .lista-equipe {\n    list-style: none;\n    padding: 0;\n    margin: 20px 0;\n  }\n\n  .membro-equipe {\n    padding: 15px;\n    margin: 10px 0;\n    background: #f8f9fa;\n    border-radius: 8px;\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    transition: transform 0.2s;\n  }\n\n  .membro-equipe:hover {\n    transform: translateX(10px);\n    background: #f1f3f5;\n  }\n\n  .fechar-modal {\n    position: absolute;\n    top: 15px;\n    right: 20px;\n    font-size: 28px;\n    cursor: pointer;\n    color: #666;\n    transition: color 0.2s;\n  }\n\n  .fechar-modal:hover {\n    color: #333;\n  }\n  .botao-equipe {\n  background: #343a40 !important; /* Azul mais claro */\n  color: #ffffff !important;\n  /* mantém o restante das propriedades */\n}\n&lt;/style&gt;\n\n&lt;script&gt;\n  // JavaScript Corrigido\n  document.addEventListener('DOMContentLoaded', () =&gt; {\n    const btnAbrir = document.getElementById('btnEquipe');\n    const btnFechar = document.getElementById('fecharModal');\n    const modal = document.getElementById('modalEquipe');\n\n    if(btnAbrir && btnFechar && modal) {\n      // Abrir modal\n      btnAbrir.addEventListener('click', () =&gt; {\n        modal.style.display = 'block';\n      });\n\n      // Fechar modal\n      btnFechar.addEventListener('click', () =&gt; {\n        modal.style.display = 'none';\n      });\n\n      // Fechar ao clicar fora\n      window.addEventListener('click', (e) =&gt; {\n        if(e.target === modal) {\n          modal.style.display = 'none';\n        }\n      });\n\n      // Fechar com ESC\n      document.addEventListener('keydown', (e) =&gt; {\n        if(e.key === 'Escape') {\n          modal.style.display = 'none';\n        }\n      });\n    } else {\n      console.error('Verifique os IDs dos elementos:', {btnAbrir, btnFechar, modal});\n    }\n  });\n  function copiarEmail() {\n        // Obtém o conteúdo do elemento que contém o email\n        const email = document.getElementById(\"email\").textContent;\n        \n        // Copia o email para a área de transferência usando a Clipboard API\n        navigator.clipboard.writeText(email)\n          .then(() =&gt; {\n            // Exibe uma mensagem de confirmação\n            alert(\"Email copiado com sucesso!\");\n          })\n          .catch(err =&gt; {\n            console.error(\"Erro ao copiar o email:\", err);\n          });\n      }\n&lt;/script&gt;\n`"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "graficos.html",
    "href": "graficos.html",
    "title": "Gráficos",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n// Carregando os dados\nstateData1 = await FileAttachment(\"expec.csv\").csv()\nstateData = tabelaFiltrada2.map(d =&gt; ({\n  estado: d.estado,\n  valor: +d.valor // Converte para número\n}))\ntabelaFiltrada2 = stateData1\n    .filter(d =&gt; +d.Ano === ano5)\n    .map(d =&gt; ({\n        estado: d.Local,\n        valor: d.ex\n    }));\n\n\ndados = FileAttachment(\"comp_pop.csv\").csv()\ntabelaFiltrada = dados.filter(d =&gt; d.new_local === estados &&\n                                   +d.Ano === ano6)"
  },
  {
    "objectID": "graficos.html#mapa-da-expectativa-de-vida-ao-nascer-por-unidade-federativa",
    "href": "graficos.html#mapa-da-expectativa-de-vida-ao-nascer-por-unidade-federativa",
    "title": "Gráficos",
    "section": "Mapa da expectativa de vida ao nascer por Unidade Federativa",
    "text": "Mapa da expectativa de vida ao nascer por Unidade Federativa\nO mapa representa a expectativa de vida ao nascer distribuido entre estados e Distrito Federal ao longo dos anos de 2000 a 2023.\n\nPLotData\n\n\n\nviewof ano5 = Inputs.range([2000, 2023],\n       {\n        value: [2000],\n        step: 1,\n        label: \"Ano: \"\n    }\n)\n\n// Carregar o GeoJSON dos estados brasileiros\ngeoData = await fetch(\"https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/brazil-states.geojson\")\n  .then(response =&gt; response.json())\n\n// Criar o mapa\nwidth = 800;\nheight = 600;\n\nchart3 = {\n  const svg = d3.create(\"svg\")\n    .attr(\"viewBox\", [0, 0, width, height])\n    .style(\"width\", \"100%\")\n    .style(\"height\", \"auto\");\n\n  // Configurar a projeção\n  const projection = d3.geoMercator()\n    .center([-52, -15]) // Centralizar no Brasil\n    .scale(700)\n    .translate([width / 2, height / 2]);\n\n  const path = d3.geoPath().projection(projection);\n\n  // Criar escala de cores\n  const valores = stateData.map(d =&gt; d.valor);\n  const colorScale = d3.scaleSequential()\n    .domain([d3.min(valores), d3.max(valores)])\n    .interpolator(d3.interpolateBlues);\n\n  // Função para normalizar nomes (remover acentos)\n  const normalizeName = name =&gt; name\n    ? name.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").toLowerCase()\n    : \"\";\n\n  // Criar mapa\n  svg.selectAll(\"path\")\n    .data(geoData.features)\n    .join(\"path\")\n    .attr(\"d\", path)\n    .attr(\"fill\", d =&gt; {\n      const state = stateData.find(s =&gt;\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n      return state ? colorScale(state.valor) : \"#ccc\";\n    })\n    .attr(\"stroke\", \"white\")\n    .attr(\"stroke-width\", 0.5);\n\n  // Adicionar tooltip\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .attr(\"class\", \"tooltip\")\n    .style(\"opacity\", 0)\n    .style(\"position\", \"absolute\")\n    .style(\"background-color\", \"white\")\n    .style(\"border\", \"solid\")\n    .style(\"border-width\", \"1px\")\n    .style(\"border-radius\", \"5px\")\n    .style(\"padding\", \"5px\");\n\n  svg.selectAll(\"path\")\n    .on(\"mouseover\", (event, d) =&gt; {\n      const state = stateData.find(s =&gt;\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", .9);\n\n      tooltip.html(`\n        Estado: ${d.properties.name}&lt;br/&gt;\n        Valor: ${state ? state.valor : 'Sem dados'}\n      `)\n        .style(\"left\", (event.pageX + 10) + \"px\")\n        .style(\"top\", (event.pageY - 28) + \"px\");\n    })\n    .on(\"mouseout\", () =&gt; {\n      tooltip.transition()\n        .duration(500)\n        .style(\"opacity\", 0);\n    });\n\n  // Adicionar barra de cores (legenda)\n  const legendWidth = 400;\n  const legendHeight = 20;\n\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${(width - legendWidth) / 2}, ${height - 25})`);\n\n  const gradient = legend.append(\"defs\")\n    .append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"y2\", \"0%\");\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"0%\")\n    .attr(\"stop-color\", colorScale(d3.min(valores)));\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"100%\")\n    .attr(\"stop-color\", colorScale(d3.max(valores)));\n\n  legend.append(\"rect\")\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Adicionar rótulos na barra de cores\n  legend.append(\"text\")\n    .attr(\"x\", 0)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"start\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.min(valores)));\n\n  legend.append(\"text\")\n    .attr(\"x\", legendWidth)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"end\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.max(valores)));\n\n  return svg.node();\n}\n\n// Mostrar valores mínimos e máximos\n    minMaxValues = {\n    const valores = stateData.map(d =&gt; d.valor);\n    return {\n        min: d3.min(valores),\n        max: d3.max(valores)\n    };\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.table(tabelaFiltrada2)\n\n\n\n\n\n\n\nhtml`\n&lt;body&gt;\n    &lt;a href=\"expec.csv\" download&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ⬇️ Baixar CSV completo\n        &lt;/button&gt;\n    &lt;/a&gt;\n    &lt;a download=\"tabelaFiltrada2.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\"&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ⬇️ Baixar CSV filtrado\n        &lt;/button&gt;\n&lt;/a&gt;\n&lt;/body&gt;\n`"
  },
  {
    "objectID": "graficos.html#evolução-da-população-por-faixa-etária",
    "href": "graficos.html#evolução-da-população-por-faixa-etária",
    "title": "Gráficos",
    "section": "Evolução da População por faixa-etária",
    "text": "Evolução da População por faixa-etária\nO gráfico representa uma comparação entre dados interpolados pelo IBGE e por nós (SIGERIP), que nos demonstra a população por faixa-etária sellecionado por nação, regiões, estados e distrito federal.\n\nPLotData\n\n\n\nviewof ano6 = Inputs.range([2000, 2023],\n       {\n        value: [2000],\n        step: 1,\n        label: \"Ano: \"\n    }\n)\n\nviewof estados = Inputs.select(['Brasil', 'Norte', 'Nordeste', 'Sudeste', 'Sul', 'Centro-Oeste',\n       'Rondônia', 'Acre', 'Amazonas', 'Roraima', 'Pará', 'Amapá',\n       'Tocantins', 'Maranhão', 'Piauí', 'Ceará', 'Rio Grande do Norte',\n       'Paraíba', 'Pernambuco', 'Alagoas', 'Sergipe', 'Bahia',\n       'Minas Gerais', 'Espírito Santo', 'Rio de Janeiro', 'São Paulo',\n       'Paraná', 'Santa Catarina', 'Rio Grande do Sul',\n       'Mato Grosso do Sul', 'Mato Grosso', 'Goiás', 'Distrito Federal'],\n       {\n        value: 'Brasil',\n        label: \"Local: \"\n        }\n       )\n\n// Gráfico\nchart = {{\n  // Definição das dimensões do gráfico\n  const width = 828;  // Largura do gráfico\n  const height = 600; // Altura do gráfico\n  const marginTop = 20;    // Margem superior\n  const marginRight = 20;  // Margem direita\n  const marginBottom = 30; // Margem inferior\n  const marginLeft = 50;   // Margem esquerda\n\n  // Escala para o eixo X (Ano)\n  const x = d3.scaleLinear()\n    .domain(d3.extent(tabelaFiltrada, d =&gt; +d.new_faixa))  // Determina o intervalo de valores para o eixo X com base no ano\n    .range([marginLeft, width - marginRight]);  // Define o intervalo de pixels no eixo X\n\n  // Escala para o eixo Y (Total)\n  const y = d3.scaleLinear()\n    .domain([d3.min(tabelaFiltrada, d =&gt; +d.Total), d3.max(tabelaFiltrada, d =&gt; +d.Total)]).nice()  // Define o intervalo de valores para o eixo Y com base no total\n    .range([height - marginBottom, marginTop]);  // Define o intervalo de pixels no eixo Y\n\n  // Definição de cores para as linhas\n  const color = d3.scaleOrdinal(d3.schemeCategory10);  // Usa uma paleta de cores pré-definida do D3\n\n  // Criação do elemento SVG para o gráfico\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)  // Define a largura do SVG\n    .attr(\"height\", height)  // Define a altura do SVG\n    .attr(\"viewBox\", [0, 0, width, height])  // Define a visualização do SVG com base nas dimensões\n    .style(\"max-width\", \"100%\")  // Estilo para garantir que o gráfico seja responsivo\n    .style(\"height\", \"auto\")  // Estilo para ajustar a altura automaticamente\n    .style(\"overflow\", \"visible\")  // Permite que os elementos do gráfico saiam do limite do SVG\n    .style(\"font\", \"10px sans-serif\");  // Define o estilo da fonte no gráfico\n\n  // Adiciona o eixo X (ano)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - marginBottom})`)  // Posiciona o eixo X na parte inferior\n    .call(d3.axisBottom(x).tickFormat(d3.format(\"d\")));  // Aplica a escala X e formata os ticks como números inteiros\n\n  // Adiciona o eixo Y (total)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${marginLeft},0)`)  // Posiciona o eixo Y à esquerda\n    .call(d3.axisLeft(y))  // Aplica a escala Y\n    .call(g =&gt; g.select(\".domain\").remove())  // Remove a linha do eixo Y\n    .call(g =&gt; g.append(\"text\")  // Adiciona texto ao lado do eixo Y\n      .attr(\"x\", -marginLeft)  // Posiciona o texto à esquerda do gráfico\n      .attr(\"y\", 10)  // Posiciona o texto no eixo Y\n      .attr(\"fill\", \"currentColor\")  // Define a cor do texto\n      .attr(\"text-anchor\", \"start\")  // Define o alinhamento do texto\n      .text(\"↑ Total (%)\"));  // Texto do eixo Y\n\n  // Agrupa os dados pela coluna UF (Unidade Federativa)\n  const groupedData = d3.group(tabelaFiltrada, d =&gt; d.Fonte);\n\n  // Define a função para desenhar as linhas no gráfico\n  const line = d3.line()\n    .x(d =&gt; x(+d.new_faixa))  // Define a posição X da linha com base no ano\n    .y(d =&gt; y(+d.Total));  // Define a posição Y da linha com base no total\n\n  // Adiciona as linhas para cada grupo de dados\n  const paths = svg.append(\"g\")\n    .selectAll(\"path\")  // Seleciona todos os elementos \"path\" (caminhos das linhas)\n    .data(groupedData)  // Vincula os dados agrupados (por UF)\n    .join(\"path\")  // Cria um novo \"path\" para cada grupo de dados\n    .attr(\"fill\", \"none\")  // Define que as linhas não terão preenchimento\n    .attr(\"stroke\", ([key]) =&gt; color(key))  // Define a cor da linha de acordo com a UF\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da linha\n    .attr(\"d\", ([, values]) =&gt; line(values));  // Desenha a linha para cada conjunto de dados\n\n  // Adiciona o texto com o nome da UF na extremidade de cada linha\n  svg.append(\"g\")\n    .selectAll(\"text\")\n    .data(groupedData)\n    .join(\"text\")\n    .attr(\"font-size\", 20)  // Define o tamanho da fonte do texto\n    .attr(\"x\", width - marginRight)  // Posiciona o texto à direita\n    .attr(\"y\", ([, values]) =&gt; y(+values[values.length - 1].Total))  // Posiciona o texto na última coordenada da linha\n    .attr(\"dy\", \"0.35em\")  // Ajusta a posição vertical do texto\n    .attr(\"text-anchor\", \"start\")  // Alinha o texto à esquerda\n    .attr(\"fill\", ([key]) =&gt; color(key))  // Define a cor do texto de acordo com a UF\n    .text(([key]) =&gt; key);  // Define o texto como o nome da UF\n  \n  // Adiciona os pontos no gráfico\n  svg.append(\"g\")\n    .selectAll(\"circle\")\n    .data(tabelaFiltrada)\n    .join(\"circle\")\n    .attr(\"cx\", d =&gt; x(+d.new_faixa))  // Posição horizontal baseada no ano\n    .attr(\"cy\", d =&gt; y(+d.Total))  // Posição vertical baseada no total\n    .attr(\"r\", 4)  // Define o raio do círculo\n    .attr(\"fill\", d =&gt; color(d.Fonte))  // Define a cor do ponto com base na UF\n    .attr(\"stroke\", \"white\")  // Adiciona uma borda branca ao ponto\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da borda\n    ;\n\n  // Criação do tooltip (caixa de informação ao passar o mouse)\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .style(\"position\", \"absolute\")  // Define a posição absoluta do tooltip\n    .style(\"background\", \"white\")  // Define o fundo branco do tooltip\n    .style(\"border\", \"1px solid #ccc\")  // Define a borda do tooltip\n    .style(\"padding\", \"5px\")  // Adiciona o espaçamento interno\n    .style(\"border-radius\", \"5px\")  // Define bordas arredondadas\n    .style(\"font-size\", \"12px\")  // Define o tamanho da fonte\n    .style(\"pointer-events\", \"none\")  // Impede a interação do tooltip com o gráfico\n    .style(\"opacity\", 0);  // Inicialmente o tooltip é invisível\n\n  // Adiciona interação para mostrar o tooltip quando o mouse passa sobre a linha\n  paths.on(\"pointermove\", (event, [uf, values]) =&gt; {\n    // Encontra o ponto mais próximo do mouse na linha\n    const [xm, ym] = d3.pointer(event);\n    const closest = d3.least(values, d =&gt; Math.hypot(x(+d.Ano) - xm, y(+d.Total) - ym));\n    \n    if (closest) {\n      const { Ano, Total } = closest;  // Obtém os dados do ponto mais próximo\n\n      // Destaque da linha: reduz opacidade das outras e aumenta a espessura da linha ativa\n      paths.attr(\"stroke-opacity\", 0.2);  \n      d3.select(event.target).attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 2.5);\n\n      // Atualiza o tooltip com os dados do ponto mais próximo\n      tooltip.style(\"opacity\", 1)\n        .html(`Fonte: ${uf}&lt;br&gt;Ano: ${Ano}&lt;br&gt;Total: ${Total}`)\n        .style(\"left\", `${event.pageX + 10}px`)  // Posiciona o tooltip ao lado do mouse\n        .style(\"top\", `${event.pageY + 10}px`);  // Posiciona o tooltip acima do mouse\n    }\n  });\n\n  // Esconde o tooltip e restaura a opacidade das linhas quando o mouse sai\n  paths.on(\"pointerleave\", () =&gt; {\n    paths.attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 1.5);  // Restaura a opacidade e espessura das linhas\n    tooltip.style(\"opacity\", 0);  // Oculta o tooltip\n  });\n\n  return svg.node();  // Retorna o elemento SVG para ser exibido\n}};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.table(tabelaFiltrada)\n\n\n\n\n\n\n\nhtml`\n&lt;body&gt;\n    &lt;a href=\"comp_pop.csv\" download&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ⬇️ Baixar CSV completo\n        &lt;/button&gt;\n    &lt;/a&gt;\n    &lt;a download=\"tabelaFiltrada.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\"&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ⬇️ Baixar CSV filtrado\n        &lt;/button&gt;\n&lt;/a&gt;\n&lt;/body&gt;\n`"
  },
  {
    "objectID": "graficos.html#mortalidade-por-faixa-etária",
    "href": "graficos.html#mortalidade-por-faixa-etária",
    "title": "Gráficos",
    "section": "Mortalidade por faixa-etária",
    "text": "Mortalidade por faixa-etária\nO gráfico representa a mortalidade ao longo do tempo por nação, regiões, estado e distrito federal, podendo selecionar faixa etária no qual deseja ver a sua evolução ao longo do tempo (2000 - 2023).\n\nPLotData\n\n\n\nmortalidade = FileAttachment(\"mortalidade1.csv\").csv()\nmortalidade_filtrada = mortalidade\n    .filter(d =&gt; d.idade === faixa_etaria_mortalidade &&\n                 (estados_mortalidade.includes(\"Todos estados\") || estados_mortalidade.includes(d.UF))\n    )\n    .map(d =&gt; ({\n        Ano: d.Ano,\n        UF: d.UF,\n        Total: d.Total\n    }));\n\nviewof faixa_etaria_mortalidade = Inputs.select(\n    ['Menos de 1 ano', '1 a 4 anos', '5 a 9 anos', '10 a 14 anos', '15 a 19 anos', '20 a 24 anos', '25 a 29 anos', '30 a 34 anos', '35 a 39 anos', '40 a 44 anos', '45 a 49 anos', '50 a 54 anos', '55 a 59 anos', '60 a 64 anos', '65 a 69 anos', '70 a 74 anos', '75 a 79 anos', '80 anos ou mais'],\n    {\n        value: ['Menos de 1 ano'],\n        label: \"Faixa etária: \"\n    }\n)\nviewof estados_mortalidade = Inputs.checkbox(\n  [\n    \"AC\", \"AL\", \"AM\", \"AP\", \"BA\", \"CE\", \"DF\", \"ES\", \"GO\", \"MA\", \n    \"MT\", \"MS\", \"MG\", \"PA\", \"PB\", \"PE\", \"PI\", \"PR\", \"RJ\", \"RN\", \n    \"RO\", \"RR\", \"RS\", \"SC\", \"SE\", \"SP\", \"TO\", \"Todos estados\"\n  ],\n  {\n    value: [\"Todos estados\"], // Define \"Todos estados\" como valor inicial selecionado\n    label: \"Local: \",\n    sort: true, // Ordena alfabeticamente\n    unique: true // Evita duplicatas\n  }\n)\n\n\n// Gráfico\nchart1 = {{\n  // Definição das dimensões do gráfico\n  const width = 928;  // Largura do gráfico\n  const height = 600; // Altura do gráfico\n  const marginTop = 20;    // Margem superior\n  const marginRight = 20;  // Margem direita\n  const marginBottom = 30; // Margem inferior\n  const marginLeft = 50;   // Margem esquerda\n\n  // Escala para o eixo X (Ano)\n  const x = d3.scaleLinear()\n    .domain(d3.extent(mortalidade_filtrada, d =&gt; +d.Ano))  // Determina o intervalo de valores para o eixo X com base no ano\n    .range([marginLeft, width - marginRight]);  // Define o intervalo de pixels no eixo X\n\n  // Escala para o eixo Y (Total)\n  const y = d3.scaleLinear()\n    .domain([d3.min(mortalidade_filtrada, d =&gt; +d.Total), d3.max(mortalidade_filtrada, d =&gt; +d.Total)]).nice()  // Define o intervalo de valores para o eixo Y com base no total\n    .range([height - marginBottom, marginTop]);  // Define o intervalo de pixels no eixo Y\n\n  // Definição de cores para as linhas\n  const color = d3.scaleOrdinal(d3.schemeCategory10);  // Usa uma paleta de cores pré-definida do D3\n\n  // Criação do elemento SVG para o gráfico\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)  // Define a largura do SVG\n    .attr(\"height\", height)  // Define a altura do SVG\n    .attr(\"viewBox\", [0, 0, width, height])  // Define a visualização do SVG com base nas dimensões\n    .style(\"max-width\", \"100%\")  // Estilo para garantir que o gráfico seja responsivo\n    .style(\"height\", \"auto\")  // Estilo para ajustar a altura automaticamente\n    .style(\"overflow\", \"visible\")  // Permite que os elementos do gráfico saiam do limite do SVG\n    .style(\"font\", \"10px sans-serif\");  // Define o estilo da fonte no gráfico\n\n  // Adiciona o eixo X (ano)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - marginBottom})`)  // Posiciona o eixo X na parte inferior\n    .call(d3.axisBottom(x).tickFormat(d3.format(\"d\")));  // Aplica a escala X e formata os ticks como números inteiros\n\n  // Adiciona o eixo Y (total)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${marginLeft},0)`)  // Posiciona o eixo Y à esquerda\n    .call(d3.axisLeft(y))  // Aplica a escala Y\n    .call(g =&gt; g.select(\".domain\").remove())  // Remove a linha do eixo Y\n    .call(g =&gt; g.append(\"text\")  // Adiciona texto ao lado do eixo Y\n      .attr(\"x\", -marginLeft)  // Posiciona o texto à esquerda do gráfico\n      .attr(\"y\", 10)  // Posiciona o texto no eixo Y\n      .attr(\"fill\", \"currentColor\")  // Define a cor do texto\n      .attr(\"text-anchor\", \"start\")  // Define o alinhamento do texto\n      .text(\"↑ Total (%)\"));  // Texto do eixo Y\n\n  // Agrupa os dados pela coluna UF (Unidade Federativa)\n  const groupedData = d3.group(mortalidade_filtrada, d =&gt; d.UF);\n\n  // Define a função para desenhar as linhas no gráfico\n  const line = d3.line()\n    .x(d =&gt; x(+d.Ano))  // Define a posição X da linha com base no ano\n    .y(d =&gt; y(+d.Total));  // Define a posição Y da linha com base no total\n\n  // Adiciona as linhas para cada grupo de dados\n  const paths = svg.append(\"g\")\n    .selectAll(\"path\")  // Seleciona todos os elementos \"path\" (caminhos das linhas)\n    .data(groupedData)  // Vincula os dados agrupados (por UF)\n    .join(\"path\")  // Cria um novo \"path\" para cada grupo de dados\n    .attr(\"fill\", \"none\")  // Define que as linhas não terão preenchimento\n    .attr(\"stroke\", ([key]) =&gt; color(key))  // Define a cor da linha de acordo com a UF\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da linha\n    .attr(\"d\", ([, values]) =&gt; line(values));  // Desenha a linha para cada conjunto de dados\n\n  // Adiciona o texto com o nome da UF na extremidade de cada linha\n  svg.append(\"g\")\n    .selectAll(\"text\")\n    .data(groupedData)\n    .join(\"text\")\n    .attr(\"font-size\", 10)  // Define o tamanho da fonte do texto\n    .attr(\"x\", width - marginRight)  // Posiciona o texto à direita\n    .attr(\"y\", ([, values]) =&gt; y(+values[values.length - 1].Total))  // Posiciona o texto na última coordenada da linha\n    .attr(\"dy\", \"0.35em\")  // Ajusta a posição vertical do texto\n    .attr(\"text-anchor\", \"start\")  // Alinha o texto à esquerda\n    .attr(\"fill\", ([key]) =&gt; color(key))  // Define a cor do texto de acordo com a UF\n    .text(([key]) =&gt; key);  // Define o texto como o nome da UF\n\n\n\n  // Criação do tooltip (caixa de informação ao passar o mouse)\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .style(\"position\", \"absolute\")  // Define a posição absoluta do tooltip\n    .style(\"background\", \"white\")  // Define o fundo branco do tooltip\n    .style(\"border\", \"1px solid #ccc\")  // Define a borda do tooltip\n    .style(\"padding\", \"5px\")  // Adiciona o espaçamento interno\n    .style(\"border-radius\", \"5px\")  // Define bordas arredondadas\n    .style(\"font-size\", \"12px\")  // Define o tamanho da fonte\n    .style(\"pointer-events\", \"none\")  // Impede a interação do tooltip com o gráfico\n    .style(\"opacity\", 0);  // Inicialmente o tooltip é invisível\n\n  // Adiciona interação para mostrar o tooltip quando o mouse passa sobre a linha\n  paths.on(\"pointermove\", (event, [uf, values]) =&gt; {\n    // Encontra o ponto mais próximo do mouse na linha\n    const [xm, ym] = d3.pointer(event);\n    const closest = d3.least(values, d =&gt; Math.hypot(x(+d.Ano) - xm, y(+d.Total) - ym));\n    \n    if (closest) {\n      const { Ano, Total } = closest;  // Obtém os dados do ponto mais próximo\n\n      // Destaque da linha: reduz opacidade das outras e aumenta a espessura da linha ativa\n      paths.attr(\"stroke-opacity\", 0.2);  \n      d3.select(event.target).attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 2.5);\n\n      // Atualiza o tooltip com os dados do ponto mais próximo\n      tooltip.style(\"opacity\", 1)\n        .html(`UF: ${uf}&lt;br&gt;Ano: ${Ano}&lt;br&gt;Total: ${Total}`)\n        .style(\"left\", `${event.pageX + 10}px`)  // Posiciona o tooltip ao lado do mouse\n        .style(\"top\", `${event.pageY + 10}px`);  // Posiciona o tooltip acima do mouse\n    }\n  });\n\n  // Esconde o tooltip e restaura a opacidade das linhas quando o mouse sai\n  paths.on(\"pointerleave\", () =&gt; {\n    paths.attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 1.5);  // Restaura a opacidade e espessura das linhas\n    tooltip.style(\"opacity\", 0);  // Oculta o tooltip\n  });\n\n  return svg.node();  // Retorna o elemento SVG para ser exibido\n}};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.table(tabelaFiltrada)\n\n\n\n\n\n\n\nfunction converterParaCSV(dados) {\n  const cabecalho = Object.keys(dados[0]).join(\",\")\n  const linhas = dados.map(obj =&gt; \n    Object.values(obj).map(v =&gt; \n      `\"${String(v).replace(/\"/g, '\"\"')}\"`\n    ).join(\",\")\n  )\n  return [cabecalho, ...linhas].join(\"\\n\")\n}\ncsv = converterParaCSV(mortalidade_filtrada)\nhtml`\n&lt;body&gt;\n    &lt;a href=\"mortalidade1.csv\" download&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ⬇️ Baixar CSV completo\n        &lt;/button&gt;\n    &lt;/a&gt;\n    &lt;a download=\"mortalidade_filtrada.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\"&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ⬇️ Baixar CSV filtrado\n        &lt;/button&gt;\n&lt;/a&gt;\n&lt;/body&gt;\n`"
  },
  {
    "objectID": "graficos.html#plot",
    "href": "graficos.html#plot",
    "title": "Gráficos",
    "section": "PLot",
    "text": "PLot\n\nviewof ano5 = Inputs.range([2000, 2023],\n       {\n        value: [2000],\n        step: 1,\n        label: \"Ano: \"\n    }\n)\n\n// Carregar o GeoJSON dos estados brasileiros\ngeoData = await fetch(\"https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/brazil-states.geojson\")\n  .then(response =&gt; response.json())\n\n// Criar o mapa\nwidth = 800;\nheight = 600;\n\nchart3 = {\n  const svg = d3.create(\"svg\")\n    .attr(\"viewBox\", [0, 0, width, height])\n    .style(\"width\", \"100%\")\n    .style(\"height\", \"auto\");\n\n  // Configurar a projeção\n  const projection = d3.geoMercator()\n    .center([-52, -15]) // Centralizar no Brasil\n    .scale(700)\n    .translate([width / 2, height / 2]);\n\n  const path = d3.geoPath().projection(projection);\n\n  // Criar escala de cores\n  const valores = stateData.map(d =&gt; d.valor);\n  const colorScale = d3.scaleSequential()\n    .domain([d3.min(valores), d3.max(valores)])\n    .interpolator(d3.interpolateBlues);\n\n  // Função para normalizar nomes (remover acentos)\n  const normalizeName = name =&gt; name\n    ? name.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").toLowerCase()\n    : \"\";\n\n  // Criar mapa\n  svg.selectAll(\"path\")\n    .data(geoData.features)\n    .join(\"path\")\n    .attr(\"d\", path)\n    .attr(\"fill\", d =&gt; {\n      const state = stateData.find(s =&gt;\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n      return state ? colorScale(state.valor) : \"#ccc\";\n    })\n    .attr(\"stroke\", \"white\")\n    .attr(\"stroke-width\", 0.5);\n\n  // Adicionar tooltip\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .attr(\"class\", \"tooltip\")\n    .style(\"opacity\", 0)\n    .style(\"position\", \"absolute\")\n    .style(\"background-color\", \"white\")\n    .style(\"border\", \"solid\")\n    .style(\"border-width\", \"1px\")\n    .style(\"border-radius\", \"5px\")\n    .style(\"padding\", \"5px\");\n\n  svg.selectAll(\"path\")\n    .on(\"mouseover\", (event, d) =&gt; {\n      const state = stateData.find(s =&gt;\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", .9);\n\n      tooltip.html(`\n        Estado: ${d.properties.name}&lt;br/&gt;\n        Valor: ${state ? state.valor : 'Sem dados'}\n      `)\n        .style(\"left\", (event.pageX + 10) + \"px\")\n        .style(\"top\", (event.pageY - 28) + \"px\");\n    })\n    .on(\"mouseout\", () =&gt; {\n      tooltip.transition()\n        .duration(500)\n        .style(\"opacity\", 0);\n    });\n\n  // Adicionar barra de cores (legenda)\n  const legendWidth = 400;\n  const legendHeight = 20;\n\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${(width - legendWidth) / 2}, ${height - 25})`);\n\n  const gradient = legend.append(\"defs\")\n    .append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"y2\", \"0%\");\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"0%\")\n    .attr(\"stop-color\", colorScale(d3.min(valores)));\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"100%\")\n    .attr(\"stop-color\", colorScale(d3.max(valores)));\n\n  legend.append(\"rect\")\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Adicionar rótulos na barra de cores\n  legend.append(\"text\")\n    .attr(\"x\", 0)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"start\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.min(valores)));\n\n  legend.append(\"text\")\n    .attr(\"x\", legendWidth)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"end\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.max(valores)));\n\n  return svg.node();\n}\n\n// Mostrar valores mínimos e máximos\n    minMaxValues = {\n    const valores = stateData.map(d =&gt; d.valor);\n    return {\n        min: d3.min(valores),\n        max: d3.max(valores)\n    };\n}"
  },
  {
    "objectID": "graficos.html#data",
    "href": "graficos.html#data",
    "title": "Gráficos",
    "section": "Data",
    "text": "Data\n\nInputs.table(tabelaFiltrada2)\n\n\n\n\n\n\n:::"
  },
  {
    "objectID": "mortalidade.html",
    "href": "mortalidade.html",
    "title": "Dados de Mortalidade",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\ndata = await FileAttachment(\"dados/dados2/erros.csv\").csv()\ntabua_comb = await FileAttachment(\"dados/dados1/previsoes_combinado.csv\").csv()\n\ndata_filter = data.filter(\n    d =&gt; d.faixa_etaria === '0' && d.regiao === 'Brasil' && d.taxa === 'Total'\n)\n\n\nhtml`\n&lt;p style=\"text-align: justify;\"&gt;Aqui, você encontrará um conjunto de dados detalhados sobre mortalidade dividido entre: Brasil, Regiões e Estados, combinando informações reais extraídas do Instituto Brasileiro de Geografia e Estatística (IBGE) com projeções e análises desenvolvidas por nossa equipe.&lt;/p&gt;\n&lt;p style=\"text-align: justify;\"&gt;Nosso objetivo é oferecer uma visão clara e acessível sobre a evolução dos padrões de mortalidade, permitindo comparações entre os dados históricos e nossas estimativas futuras. Utilizamos modelos estatísticos e atuariais para gerar previsões que podem ser aplicadas em diversas áreas, como seguros, previdência, saúde pública e planejamento estratégico.&lt;/p&gt;\n&lt;p style=\"text-align: justify;\"&gt;Explore nossos gráficos interativos e relatórios para entender melhor as tendências e impactos da longevidade no Brasil.&lt;/p&gt;\n`"
  },
  {
    "objectID": "mortalidade.html#gráficos",
    "href": "mortalidade.html#gráficos",
    "title": "Mortalidade",
    "section": "Gráficos",
    "text": "Gráficos\n\n{\n  const width = 1000;\n  const height = 800;\n  const margin = { top: 20, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Criação do SVG principal\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  // Calcula dimensões dos subplots\n  const subplotWidth = (width - margin.left - margin.right) / numCols;\n  const subplotHeight = (height - margin.top - margin.bottom) / numRows;\n\n  // Criação dos subplots\n  for (let row = 0; row &lt; numRows; row++) {\n    for (let col = 0; col &lt; numCols; col++) {\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left + col * subplotWidth}, \n                                      ${margin.top + row * subplotHeight})`);\n      \n      // Adicione elementos gráficos aqui\n      // Exemplo de retângulo de fundo\n      subplot.append(\"rect\")\n        .attr(\"width\", subplotWidth - 10)\n        .attr(\"height\", subplotHeight - 10)\n        .attr(\"fill\", \"#f0f0f0\");\n\n      // Exemplo de gráfico de barras (adaptar para seus dados)\n      subplot.selectAll(\"rect.bar\")\n        .data([1, 2, 3, 4, 5]) // Dados de exemplo\n        .join(\"rect\")\n          .attr(\"class\", \"bar\")\n          .attr(\"x\", 5)\n          .attr(\"y\", 20)\n          .attr(\"width\", 10)\n          .attr(\"height\", 30)\n          .attr(\"fill\", \"steelblue\");\n\n      // Adicione eixos\n      const xScale = d3.scaleLinear()\n        .domain([0, 5])\n        .range([0, subplotWidth - margin.left - margin.right]);\n\n      const yScale = d3.scaleLinear()\n        .domain([0, 5])\n        .range([subplotHeight - margin.bottom, margin.top]);\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale));\n\n      subplot.append(\"g\")\n        .call(d3.axisLeft(yScale));\n    }\n  }\n\n  return svg.node();\n}\n\n\n\n\n\n\n\n{\n  const width = 1200;\n  const height = 1000;\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 4;\n  const numCols = 5;\n  \n  // Criação do SVG principal\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  // Extrai faixas etárias únicas e ordena\n  const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n  \n  // Calcula dimensões dos subplots\n  const subplotWidth = width / numCols;\n  const subplotHeight = height / numRows;\n\n  // Criação dos subplots\n  for (let row = 0; row &lt; numRows; row++) {\n    for (let col = 0; col &lt; numCols; col++) {\n      const index = row * numCols + col;\n      if (index &gt;= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n      \n      // Filtra dados para a faixa etária atual\n      const filteredData = data.filter(d =&gt; \n        d.faixa_etaria === currentAge && \n        d.regiao === 'Brasil' && \n        d.taxa === 'Total'\n      ).map(d =&gt; ({\n        ...d,\n        ano: +d.ano,\n        mx_real: +d.mx_real\n      }));\n      \n      // Configura escalas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d =&gt; d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n      \n      const yScale = d3.scaleLinear()\n        .domain([0, d3.max(filteredData, d =&gt; d.mx_real)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Adiciona eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5));\n      \n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5));\n      \n      // Adiciona linha\n      const line = d3.line()\n        .x(d =&gt; xScale(d.ano))\n        .y(d =&gt; yScale(d.mx_real));\n      \n      subplot.append(\"path\")\n        .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n        .attr(\"d\", line)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"steelblue\")\n        .attr(\"stroke-width\", 2);\n      \n      // Adiciona título\n      subplot.append(\"text\")\n        .attr(\"x\", margin.left)\n        .attr(\"y\", margin.top)\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n\n  return svg.node();\n}"
  },
  {
    "objectID": "mortalidade.html#taxa-central-de-mortalidade",
    "href": "mortalidade.html#taxa-central-de-mortalidade",
    "title": "Dados de Mortalidade",
    "section": "Taxa Central de Mortalidade",
    "text": "Taxa Central de Mortalidade\n\n{\n  const width = 800;\n  const height = 650;\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Criação do SVG principal\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  // Extrai faixas etárias únicas e ordena\n  const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n  \n  // Calcula dimensões dos subplots\n  const subplotWidth = width / numCols;\n  const subplotHeight = height / numRows;\n\n  // Criação dos subplots\n  for (let row = 0; row &lt; numRows; row++) {\n    for (let col = 0; col &lt; numCols; col++) {\n      const index = row * numCols + col;\n      if (index &gt;= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n      \n      // Filtra dados para a faixa etária atual\n      const filteredData = data.filter(d =&gt; \n        d.faixa_etaria === currentAge && \n        d.regiao === 'Brasil' && \n        d.taxa === 'Total'\n      ).map(d =&gt; ({\n        ...d,\n        ano: +d.ano,\n        mx_real: Math.log(+d.mx_real)\n      }));\n      \n      // Configura escalas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d =&gt; d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n      \n      const yScale = d3.scaleLinear()\n        .domain([d3.min(filteredData, d =&gt; d.mx_real), d3.max(filteredData, d =&gt; d.mx_real)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Adiciona eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5));\n      \n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5));\n      \n      // Adiciona linha\n      const line = d3.line()\n        .x(d =&gt; xScale(d.ano))\n        .y(d =&gt; yScale(d.mx_real));\n      \n      subplot.append(\"path\")\n        .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n        .attr(\"d\", line)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"steelblue\")\n        .attr(\"stroke-width\", 2);\n      \n      // Adiciona título\n      subplot.append(\"text\")\n        .attr(\"x\", margin.left)\n        .attr(\"y\", margin.top)\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\", \"center\");\n    }\n  }\n\n  return svg.node();\n}"
  },
  {
    "objectID": "mortalidade.html#taxa-central-de-mortalidade-2000-à-2023",
    "href": "mortalidade.html#taxa-central-de-mortalidade-2000-à-2023",
    "title": "Dados de Mortalidade",
    "section": "Taxa Central de Mortalidade 2000 à 2023",
    "text": "Taxa Central de Mortalidade 2000 à 2023\n\nviewof qual = Inputs.checkbox(['Lee-Carter', 'Lee-Miler', 'Dados real'], {value: ['Lee-Miler', 'Lee-Carter', 'Dados real'], label: 'Modelos:'}) \n\nviewof regiao = Inputs.select([\n  \"Brasil\",\n  \"Norte\",\n  \"Nordeste\",\n  \"Centro-Oeste\",\n  \"Sudeste\",\n  \"Sul\",\n  \"Acre\",\n  \"Alagoas\",\n  \"Amapá\",\n  \"Amazonas\",\n  \"Bahia\",\n  \"Ceará\",\n  \"Distrito Federal\",\n  \"Espírito Santo\",\n  \"Goiás\",\n  \"Maranhão\",\n  \"Mato Grosso\",\n  \"Mato Grosso do Sul\",\n  \"Minas Gerais\",\n  \"Pará\",\n  \"Paraíba\",\n  \"Paraná\",\n  \"Pernambuco\",\n  \"Piauí\",\n  \"Rio de Janeiro\",\n  \"Rio Grande do Norte\",\n  \"Rio Grande do Sul\",\n  \"Rondônia\",\n  \"Roraima\",\n  \"Santa Catarina\",\n  \"São Paulo\",\n  \"Sergipe\",\n  \"Tocantins\"],\n  {\n        value: ['Brasil'],\n        label: \"Local: \"\n    })\n\nhtml`\n&lt;div class=\"grafico-container\"&gt;\n  &lt;!-- Legenda HTML --&gt;\n  &lt;div class=\"legenda\"&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: steelblue\"&gt;&lt;/div&gt;\n      &lt;span&gt;Real&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: darkorange\"&gt;&lt;/div&gt;\n      &lt;span&gt;Modelo LC&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: green\"&gt;&lt;/div&gt;\n      &lt;span&gt;Modelo LM&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n\n  &lt;!-- Container do gráfico SVG será injetado aqui --&gt;\n  &lt;div id=\"grafico\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n.grafico-container {\n  max-width: 800px;\n  margin: 0 auto;\n  font-family: sans-serif;\n}\n\n.legenda {\n  display: flex;\n  gap: 1.5rem;\n  justify-content: center;\n  margin-bottom: 1.5rem;\n}\n\n.legenda-item {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.25rem 0.75rem;\n  background: #f5f5f5;\n  border-radius: 1rem;\n}\n\n.cor-marcador {\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n}\n\n&lt;/style&gt;\n`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction lm_lc(){\n  //lm e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [ d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lm(){\n  //real e lm\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lc(){\n  //real e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lc]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n\n\nfunction todos(){\n  //todos\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n//real\nfunction real(){\n  {\n    const width = 800;\n    const height = 750;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_real), d3.max(filteredData, d =&gt; d.mx_real)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_real));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"steelblue\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lm\nfunction mx_lm(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_lm), d3.max(filteredData, d =&gt; d.mx_lm)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_lm));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"green\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lc\nfunction mx_lc(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_lc), d3.max(filteredData, d =&gt; d.mx_lc)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_lc));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"darkorange\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Dados real\")\nlm = qual.includes(\"Lee-Miler\")\nlc = qual.includes(\"Lee-Carter\")\n\n{\n  if(totalSelecionado === 1 ){\n    if (rea) return real();\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  }else if (totalSelecionado === 3){\n    return todos()\n  }else if (totalSelecionado === 2){\n    if (rea && lm) return real_lm();\n    if (rea && lc) return real_lc();\n    if (lm && lc) return lm_lc();\n  }else if (totalSelecionado == 0){\n    return html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncleo = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\n//faixaeta = Array.from(d3.group(cleo, d =&gt; d.faixa_etaria).keys());\nviewof faixa_etaria = Inputs.select(Array.from(d3.group(cleo, d =&gt; d.faixa_etaria).keys()))\ndata_filter2 = cleo.filter(\n    d =&gt; d.faixa_etaria === faixa_etaria && d.Local === 'Brasil' && d.Sexo === 'Ambos'\n).map(\n  d =&gt; ({\n    ano: d.Ano,\n    prev: Math.log(d.nMx_previsão)\n  }))\n\nviewof ano = Inputs.select(Array.from(d3.group(cleo, d =&gt; d.Ano).keys()))\ndata_filter1 = cleo.filter(\n    d =&gt; d.Ano === ano && d.Local === 'Brasil' && d.Sexo === 'Ambos'\n).map(\n  d =&gt; ({\n    faixa: d.faixa_etaria,\n    prev: Math.log(d.nMx_previsão)\n  }))\nInputs.table(data_filter1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n  // Declare the chart dimensions and margins.\n  const width = 800;\n  const height = 650;\n  const marginTop = 30;\n  const marginRight = 20;\n  const marginBottom = 40;\n  const marginLeft = 50;\n\n  // Extraia os valores únicos de faixa e ordene-os se necessário\n  const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n  \n  // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n  const x = d3.scalePoint()\n      .domain(faixaValues)\n      .range([marginLeft, width - marginRight])\n      .padding(0.5); // Adiciona espaço nas extremidades\n\n  // Declare the y (vertical position) scale.\n  const y = d3.scaleLinear()\n      .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n      .range([height - marginBottom, marginTop]);\n\n  // Declare the line generator.\n  const line = d3.line()\n      .x(d =&gt; x(d.faixa))\n      .y(d =&gt; y(d.prev));\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  // Add the x-axis.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x))\n      .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n      .style(\"text-anchor\", \"end\")\n      .attr(\"dx\", \"-.8em\")\n      .attr(\"dy\", \".15em\")\n      .attr(\"transform\", \"rotate(-45)\");\n\n  // Add the y-axis, remove the domain line, add grid lines and a label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).ticks(height / 40))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.selectAll(\".tick line\").clone()\n          .attr(\"x2\", width - marginLeft - marginRight)\n          .attr(\"stroke-opacity\", 0.1))\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"↑ Prevalência\"));\n\n  // Append a path for the line.\n  svg.append(\"path\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"steelblue\")\n      .attr(\"stroke-width\", 1.5)\n      .attr(\"d\", line(data_filter1));\n\n  return svg.node();\n}"
  },
  {
    "objectID": "mortalidade.html#testando",
    "href": "mortalidade.html#testando",
    "title": "Dados de Mortalidade",
    "section": "testando",
    "text": "testando\n\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Dados real\")\nlm = qual.includes(\"Lee-Miler\")\nlc = qual.includes(\"Lee-Carter\")\n\n{\n  if(totalSelecionado === 1 ){\n    if (rea) return real();\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  }else if (totalSelecionado === 3){\n    return todos()\n  }else if (totalSelecionado === 2){\n    if (rea && lm) return real_lm();\n    if (rea && lc) return real_lc();\n    if (lm && lc) return \"lm lc\";\n  }\n\n}"
  },
  {
    "objectID": "mortalidade.html#taxa-central-de-mortalidade-de-2000-à-2023-para-os-modelos-de-lee-miler-e-lee-carter",
    "href": "mortalidade.html#taxa-central-de-mortalidade-de-2000-à-2023-para-os-modelos-de-lee-miler-e-lee-carter",
    "title": "Dados de Mortalidade",
    "section": "Taxa central de mortalidade de 2000 à 2023 para os modelos de Lee-Miler e Lee-Carter",
    "text": "Taxa central de mortalidade de 2000 à 2023 para os modelos de Lee-Miler e Lee-Carter\n\nviewof qual = Inputs.checkbox(['Lee-Carter', 'Lee-Miler', 'Observado'], {value: ['Lee-Miler', 'Lee-Carter', 'Observado'], label: 'Modelos:'}) \n\nviewof regiao = Inputs.select([\n  \"Brasil\",\n  \"Norte\",\n  \"Nordeste\",\n  \"Centro-Oeste\",\n  \"Sudeste\",\n  \"Sul\",\n  \"Acre\",\n  \"Alagoas\",\n  \"Amapá\",\n  \"Amazonas\",\n  \"Bahia\",\n  \"Ceará\",\n  \"Distrito Federal\",\n  \"Espírito Santo\",\n  \"Goiás\",\n  \"Maranhão\",\n  \"Mato Grosso\",\n  \"Mato Grosso do Sul\",\n  \"Minas Gerais\",\n  \"Pará\",\n  \"Paraíba\",\n  \"Paraná\",\n  \"Pernambuco\",\n  \"Piauí\",\n  \"Rio de Janeiro\",\n  \"Rio Grande do Norte\",\n  \"Rio Grande do Sul\",\n  \"Rondônia\",\n  \"Roraima\",\n  \"Santa Catarina\",\n  \"São Paulo\",\n  \"Sergipe\",\n  \"Tocantins\"],\n  {\n        value: ['Brasil'],\n        label: \"Local: \"\n    })\n\nhtml`\n&lt;div class=\"grafico-container\"&gt;\n  &lt;!-- Legenda HTML --&gt;\n  &lt;div class=\"legenda\"&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: steelblue\"&gt;&lt;/div&gt;\n      &lt;span&gt;Observado&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: darkorange\"&gt;&lt;/div&gt;\n      &lt;span&gt;Modelo LC&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: green\"&gt;&lt;/div&gt;\n      &lt;span&gt;Modelo LM&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n\n  &lt;!-- Container do gráfico SVG será injetado aqui --&gt;\n  &lt;div id=\"grafico\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n.grafico-container {\n  max-width: 800px;\n  margin: 0 auto;\n  font-family: sans-serif;\n}\n\n.legenda {\n  display: flex;\n  gap: 1.5rem;\n  justify-content: center;\n  margin-bottom: 1.5rem;\n}\n\n.legenda-item {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.25rem 0.75rem;\n  background: #f5f5f5;\n  border-radius: 1rem;\n}\n\n.cor-marcador {\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n}\n\n&lt;/style&gt;\n`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction lm_lc(){\n  //lm e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [ d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lm(){\n  //real e lm\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lc(){\n  //real e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lc]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n\n\nfunction todos(){\n  //todos\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n//real\nfunction real(){\n  {\n    const width = 800;\n    const height = 750;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_real), d3.max(filteredData, d =&gt; d.mx_real)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_real));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"steelblue\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lm\nfunction mx_lm(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_lm), d3.max(filteredData, d =&gt; d.mx_lm)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_lm));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"green\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lc\nfunction mx_lc(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_lc), d3.max(filteredData, d =&gt; d.mx_lc)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_lc));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"darkorange\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Observado\")\nlm = qual.includes(\"Lee-Miler\")\nlc = qual.includes(\"Lee-Carter\")\n\n{\n  if(totalSelecionado === 1 ){\n    if (rea) return real();\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  }else if (totalSelecionado === 3){\n    return todos()\n  }else if (totalSelecionado === 2){\n    if (rea && lm) return real_lm();\n    if (rea && lc) return real_lc();\n    if (lm && lc) return lm_lc();\n  }else if (totalSelecionado == 0){\n    return html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n  }\n\n}"
  },
  {
    "objectID": "mortalidade.html#projeção-da-taxa-central-de-mortalidade-de-2024-à-2070-para-o-modelo-combinado-arima-ets-ponderado",
    "href": "mortalidade.html#projeção-da-taxa-central-de-mortalidade-de-2024-à-2070-para-o-modelo-combinado-arima-ets-ponderado",
    "title": "Dados de Mortalidade",
    "section": "Projeção da taxa central de mortalidade de 2024 à 2070 para o modelo combinado (ARIMA + ETS Ponderado)",
    "text": "Projeção da taxa central de mortalidade de 2024 à 2070 para o modelo combinado (ARIMA + ETS Ponderado)\n\ncleo = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\nviewof sexo = Inputs.radio([\"Ambos\", \"Homens\", \"Mulheres\"], {label: \"Sexo\", value: \"Ambos\"})\n\ndata_filter1 = cleo.filter(\n    d =&gt; d.Local === 'Paraíba' && d.Sexo === sexo\n).map(\n  d =&gt; ({\n    ano: +d.Ano,\n    faixa: d.faixa_etaria,\n    prev: Math.log(d.nMx_previsão)\n  }))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n  // Declare the chart dimensions and margins.\n  const width = 800;\n  const height = 650;\n  const marginTop = 30;\n  const marginRight = 20;\n  const marginBottom = 40;\n  const marginLeft = 50;\n\n  // Extraia os valores únicos de faixa e ordene-os se necessário\n  const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n  \n  // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n  const x = d3.scalePoint()\n      .domain(faixaValues)\n      .range([marginLeft, width - marginRight])\n      .padding(0.5); // Adiciona espaço nas extremidades\n\n  // Declare the y (vertical position) scale.\n  const y = d3.scaleLinear()\n      .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n      .range([height - marginBottom, marginTop]);\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  // Adicionar definições para gradientes\n  const defs = svg.append(\"defs\");\n\n  // Separar os dados por ano (ou outro agrupamento conforme necessário)\n  const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n  \n  // Mapeando os anos entre 2024 e 2070 para cores\n  const colorScale = d3.scaleSequential()\n      .domain([2024, 2070])\n      .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n  // Adicionar um gradiente para cada linha\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const gradientId = `line-gradient-${year}`;\n\n    // Criar gradiente linear\n    const gradient = defs.append(\"linearGradient\")\n        .attr(\"id\", gradientId)\n        .attr(\"gradientUnits\", \"userSpaceOnUse\")\n        .attr(\"x1\", marginLeft)\n        .attr(\"y1\", 0)\n        .attr(\"x2\", width - marginRight)\n        .attr(\"y2\", 0);\n\n    // Adicionar paradas de cor para o gradiente\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"0%\")\n        .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"100%\")\n        .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n  });\n\n  // Add the x-axis.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x))\n      .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n      .style(\"text-anchor\", \"end\")\n      .attr(\"dx\", \"-.8em\")\n      .attr(\"dy\", \".15em\")\n      .attr(\"transform\", \"rotate(-45)\");\n\n  // Add the y-axis, remove the domain line, add grid lines and a label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).ticks(height / 40))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.selectAll(\".tick line\").clone()\n          .attr(\"x2\", width - marginLeft - marginRight)\n          .attr(\"stroke-opacity\", 0.1))\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Log Previsão\"));\n\n  // Declare the line generator.\n  const line = d3.line()\n      .x(d =&gt; x(d.faixa))\n      .y(d =&gt; y(d.prev));\n\n  // Desenhar uma linha para cada ano com seu próprio gradiente\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const values = yearGroup[1];\n\n    // Desenhar a linha com gradiente\n    svg.append(\"path\")\n        .datum(values)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n        .attr(\"stroke-width\", 2.5)\n        .attr(\"d\", line);\n  });\n\n  // Adicionar legenda para os anos\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - marginRight - legendWidth;\n  const legendY = marginTop;\n\n  // Legenda de gradiente horizontal\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  // Adicionar paradas de cor para a legenda\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  // Retângulo da legenda com gradiente\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Texto para a legenda\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  // Rótulos dos anos na legenda\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  return svg.node();\n}"
  },
  {
    "objectID": "modelos.html",
    "href": "modelos.html",
    "title": "Modelos",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\n// Dados e filtros\nprev_comb = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\nprev_lm = await FileAttachment('dados/dados2/tabuas_lc.csv').csv() \nprev_lc = await FileAttachment('dados/dados2/tabuas_lm.csv').csv()\n\nviewof sexo = Inputs.radio([\"Ambos\", \"Homens\", \"Mulheres\"], {label: \"Sexo\", value: \"Homens\"})\n\ndata_filter1 = prev_comb.filter(d =&gt; d.Local === 'Brasil' && d.Sexo === sexo).map(d =&gt; ({\n  ano: +d.Ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.nMx_previsão)\n}))\n\ndata_filter2 = prev_lm.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\ndata_filter3 = prev_lc.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\nviewof qual = Inputs.checkbox(\n  ['Combinado', 'Lee-Carter', 'Lee-Miler'], \n  {value: ['Combinado'], label: 'Modelos:'}\n)\n\n// Função principal para criar gráficos\nfunction createChart(data, title) {\n  const width = 800;\n  const height = 550;\n  const margin = {top: 30, right: 20, bottom: 40, left: 50};\n  \n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [0, 0, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto;\");\n\n  // Escalas\n  const x = d3.scalePoint()\n    .domain([...new Set(data.map(d =&gt; d.faixa))])\n    .range([margin.left, width - margin.right])\n    .padding(0.5);\n\n  const y = d3.scaleLinear()\n    .domain(d3.extent(data, d =&gt; d.prev)).nice()\n    .range([height - margin.bottom, margin.top]);\n\n  // Eixos\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - margin.bottom})`)\n    .call(d3.axisBottom(x))\n    .selectAll(\"text\")\n    .style(\"text-anchor\", \"end\")\n    .attr(\"dx\", \"-.8em\")\n    .attr(\"dy\", \".15em\")\n    .attr(\"transform\", \"rotate(-45)\");\n\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},0)`)\n    .call(d3.axisLeft(y).ticks(height / 40))\n    .call(g =&gt; g.select(\".domain\").remove())\n    .call(g =&gt; g.selectAll(\".tick line\").clone()\n      .attr(\"x2\", width - margin.left - margin.right)\n      .attr(\"stroke-opacity\", 0.1));\n\n  // Gradiente e cores\n  const colorScale = d3.scaleSequential(d3.interpolateViridis)\n    .domain([2024, 2070]);\n\n  const defs = svg.append(\"defs\");\n  const nestedData = d3.groups(data, d =&gt; d.ano);\n\n  nestedData.forEach(([year, values]) =&gt; {\n    const gradientId = `gradient-${title}-${year}`;\n    \n    const gradient = defs.append(\"linearGradient\")\n      .attr(\"id\", gradientId)\n      .attr(\"gradientUnits\", \"userSpaceOnUse\")\n      .attr(\"x1\", margin.left)\n      .attr(\"y1\", 0)\n      .attr(\"x2\", width - margin.right)\n      .attr(\"y2\", 0);\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"0%\")\n      .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"100%\")\n      .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070)));\n  });\n\n  // Linhas\n  const line = d3.line()\n    .x(d =&gt; x(d.faixa))\n    .y(d =&gt; y(d.prev));\n\n  nestedData.forEach(([year, values]) =&gt; {\n    svg.append(\"path\")\n      .datum(values)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", `url(#gradient-${title}-${year})`)\n      .attr(\"stroke-width\", 2.5)\n      .attr(\"d\", line);\n  });\n\n  // Legenda\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - margin.right - legendWidth;\n  const legendY = margin.top;\n\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", `legend-${title}`)\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", `url(#legend-${title})`);\n\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  // Título\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .style(\"font-size\", \"1.2em\")\n    .text(title);\n\n  return svg.node();\n}\n\n// Renderização dos gráficos\n{\n  const container = document.createElement('div');\n  container.style.display = \"grid\";\n  container.style.gap = \"2rem\";\n  container.style.justifyContent = \"center\";\n\n  if (qual.includes(\"Combinado\")) {\n    container.appendChild(createChart(data_filter1, \"Combinado\"));\n  }\n  if (qual.includes(\"Lee-Miler\")) {\n    container.appendChild(createChart(data_filter2, \"Lee-Miller\"));\n  }\n  if (qual.includes(\"Lee-Carter\")) {\n    container.appendChild(createChart(data_filter3, \"Lee-Carter\"));\n  }\n\n  return qual.length === 0 \n    ? html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n    : container;\n}"
  },
  {
    "objectID": "modelos.html#projeção-da-taxa-central-de-mortalidade-de-2024-à-2070-para-o-modelo-combinado-arima-ets-ponderado",
    "href": "modelos.html#projeção-da-taxa-central-de-mortalidade-de-2024-à-2070-para-o-modelo-combinado-arima-ets-ponderado",
    "title": "Modelos",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\nprev_comb = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\nviewof sexo = Inputs.radio([\"Ambos\", \"Homens\", \"Mulheres\"], {label: \"Sexo\", value: \"Homens\"})\n\n\n\nprev_lm = await FileAttachment('dados/dados2/tabuas_lc.csv').csv() \nprev_lc = await FileAttachment('dados/dados2/tabuas_lm.csv').csv()\n\ndata_filter1 = prev_comb.filter(\n    d =&gt; d.Local === 'Brasil' && d.Sexo === sexo\n).map(\n  d =&gt; ({\n    ano: +d.Ano,\n    faixa: d.faixa_etaria,\n    prev: Math.log(d.nMx_previsão)\n  }))\n\ndata_filter2 = prev_lm.filter(\n    d =&gt; d.local === 'Brasil' && d.sexo === sexo\n).map(\n  d =&gt; ({\n    ano: +d.ano,\n    faixa: d.faixa_etaria,\n    prev: Math.log(d.mx_previsto)\n  }))\n\ndata_filter3 = prev_lc.filter(\n    d =&gt; d.local === 'Brasil' && d.sexo === sexo\n).map(\n  d =&gt; ({\n    ano: +d.ano,\n    faixa: d.faixa_etaria,\n    prev: Math.log(d.mx_previsto)\n  }))\n\n\nviewof qual = Inputs.checkbox(['Lee-Carter', 'Lee-Miler', 'Combinado'], {value: ['Combinado'], label: 'Modelos:'})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//combinado\nfunction combinado(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n\n\n\n\n\n\n//lm\nfunction mx_lm(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter2.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter2, d =&gt; d.prev), d3.max(data_filter2, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter2, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n\n\n\n\n\n\nfunction mx_lc(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter3.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter3, d =&gt; d.prev), d3.max(data_filter3, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter3, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n//comb_lm\nfunction comb_lm(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n  //divsoria\n  html`&lt;h2&gt;div&lt;/h2&gt;`\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter2.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter2, d =&gt; d.prev), d3.max(data_filter2, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter2, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n//comb_lc\nfunction comb_lc(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n  html`&lt;h2&gt;div&lt;/h2&gt;`\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter3.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter3, d =&gt; d.prev), d3.max(data_filter3, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter3, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n\n//lm lc\nfunction lm_lc(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter2.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter2, d =&gt; d.prev), d3.max(data_filter2, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter2, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n  html`&lt;h2&gt;div&lt;/h2&gt;`\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter3.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter3, d =&gt; d.prev), d3.max(data_filter3, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter3, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n//comb_lm lc\nfunction todos(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n  \n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter2.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter2, d =&gt; d.prev), d3.max(data_filter2, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter2, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n  html`&lt;h2&gt;div&lt;/h2&gt;`\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores únicos de faixa e ordene-os se necessário\n    const faixaValues = [...new Set(data_filter3.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espaço nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter3, d =&gt; d.prev), d3.max(data_filter3, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar definições para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necessário)\n    const nestedData = d3.groups(data_filter3, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previsão\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu próprio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Retângulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // Rótulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Combinado\");\nlm = qual.includes(\"Lee-Miler\");\nlc = qual.includes(\"Lee-Carter\");\n\n{\n  if (totalSelecionado === 1) {\n    if (rea) return combinado();\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  } \n  else if (totalSelecionado === 3) {\n    return [combinado(), mx_lm(), mx_lc()]; // Retorna array com todos\n  } \n  else if (totalSelecionado === 2) {\n    if (rea && lm) return [combinado(), mx_lm()];\n    if (rea && lc) return [combinado(), mx_lc()];\n    if (lm && lc) return [mx_lm(), mx_lc()];\n  } \n  else if (totalSelecionado === 0) {\n    return html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`;\n  }\n  \n  // Caso inesperado (opcional)\n  return html`&lt;p&gt;Seleção inválida&lt;/p&gt;`;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhtml`&lt;h2&gt;Combinado&lt;/h2&gt;`\n\n\n\n\n\n\n\n{\n  // Declare the chart dimensions and margins.\n  const width = 800;\n  const height = 650;\n  const marginTop = 30;\n  const marginRight = 20;\n  const marginBottom = 40;\n  const marginLeft = 50;\n\n  // Extraia os valores únicos de faixa e ordene-os se necessário\n  const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n  \n  // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n  const x = d3.scalePoint()\n      .domain(faixaValues)\n      .range([marginLeft, width - marginRight])\n      .padding(0.5); // Adiciona espaço nas extremidades\n\n  // Declare the y (vertical position) scale.\n  const y = d3.scaleLinear()\n      .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev+1)]).nice()\n      .range([height - marginBottom, marginTop]);\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  // Adicionar definições para gradientes\n  const defs = svg.append(\"defs\");\n\n  // Separar os dados por ano (ou outro agrupamento conforme necessário)\n  const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n  \n  // Mapeando os anos entre 2024 e 2070 para cores\n  const colorScale = d3.scaleSequential()\n      .domain([2024, 2070])\n      .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n  // Adicionar um gradiente para cada linha\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const gradientId = `line-gradient-${year}`;\n\n    // Criar gradiente linear\n    const gradient = defs.append(\"linearGradient\")\n        .attr(\"id\", gradientId)\n        .attr(\"gradientUnits\", \"userSpaceOnUse\")\n        .attr(\"x1\", marginLeft)\n        .attr(\"y1\", 0)\n        .attr(\"x2\", width - marginRight)\n        .attr(\"y2\", 0);\n\n    // Adicionar paradas de cor para o gradiente\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"0%\")\n        .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"100%\")\n        .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n  });\n\n  // Add the x-axis.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x))\n      .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n      .style(\"text-anchor\", \"end\")\n      .attr(\"dx\", \"-.8em\")\n      .attr(\"dy\", \".15em\")\n      .attr(\"transform\", \"rotate(-45)\");\n\n  // Add the y-axis, remove the domain line, add grid lines and a label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).ticks(height / 40))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.selectAll(\".tick line\").clone()\n          .attr(\"x2\", width - marginLeft - marginRight)\n          .attr(\"stroke-opacity\", 0.1))\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Log Previsão\"));\n\n  // Declare the line generator.\n  const line = d3.line()\n      .x(d =&gt; x(d.faixa))\n      .y(d =&gt; y(d.prev));\n\n  // Desenhar uma linha para cada ano com seu próprio gradiente\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const values = yearGroup[1];\n\n    // Desenhar a linha com gradiente\n    svg.append(\"path\")\n        .datum(values)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n        .attr(\"stroke-width\", 2.5)\n        .attr(\"d\", line);\n  });\n\n  // Adicionar legenda para os anos\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - marginRight - legendWidth;\n  const legendY = marginTop;\n\n  // Legenda de gradiente horizontal\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  // Adicionar paradas de cor para a legenda\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  // Retângulo da legenda com gradiente\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Texto para a legenda\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  // Rótulos dos anos na legenda\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  return svg.node();\n}\n\n\n\n\n\n\n\nhtml`&lt;h2&gt;Lee-Miler&lt;/h2&gt;`\n\n\n\n\n\n\n\n{\n  // Declare the chart dimensions and margins.\n  const width = 800;\n  const height = 650;\n  const marginTop = 30;\n  const marginRight = 20;\n  const marginBottom = 40;\n  const marginLeft = 50;\n\n  // Extraia os valores únicos de faixa e ordene-os se necessário\n  const faixaValues = [...new Set(data_filter2.map(d =&gt; d.faixa))];\n  \n  // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n  const x = d3.scalePoint()\n      .domain(faixaValues)\n      .range([marginLeft, width - marginRight])\n      .padding(0.5); // Adiciona espaço nas extremidades\n\n  // Declare the y (vertical position) scale.\n  const y = d3.scaleLinear()\n      .domain([d3.min(data_filter2, d =&gt; d.prev), d3.max(data_filter2, d =&gt; d.prev+1)]).nice()\n      .range([height - marginBottom, marginTop]);\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  // Adicionar definições para gradientes\n  const defs = svg.append(\"defs\");\n\n  // Separar os dados por ano (ou outro agrupamento conforme necessário)\n  const nestedData = d3.groups(data_filter2, d =&gt; d.ano);\n  \n  // Mapeando os anos entre 2024 e 2070 para cores\n  const colorScale = d3.scaleSequential()\n      .domain([2024, 2070])\n      .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n  // Adicionar um gradiente para cada linha\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const gradientId = `line-gradient-${year}`;\n\n    // Criar gradiente linear\n    const gradient = defs.append(\"linearGradient\")\n        .attr(\"id\", gradientId)\n        .attr(\"gradientUnits\", \"userSpaceOnUse\")\n        .attr(\"x1\", marginLeft)\n        .attr(\"y1\", 0)\n        .attr(\"x2\", width - marginRight)\n        .attr(\"y2\", 0);\n\n    // Adicionar paradas de cor para o gradiente\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"0%\")\n        .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"100%\")\n        .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n  });\n\n  // Add the x-axis.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x))\n      .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n      .style(\"text-anchor\", \"end\")\n      .attr(\"dx\", \"-.8em\")\n      .attr(\"dy\", \".15em\")\n      .attr(\"transform\", \"rotate(-45)\");\n\n  // Add the y-axis, remove the domain line, add grid lines and a label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).ticks(height / 40))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.selectAll(\".tick line\").clone()\n          .attr(\"x2\", width - marginLeft - marginRight)\n          .attr(\"stroke-opacity\", 0.1))\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Log Previsão\"));\n\n  // Declare the line generator.\n  const line = d3.line()\n      .x(d =&gt; x(d.faixa))\n      .y(d =&gt; y(d.prev));\n\n  // Desenhar uma linha para cada ano com seu próprio gradiente\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const values = yearGroup[1];\n\n    // Desenhar a linha com gradiente\n    svg.append(\"path\")\n        .datum(values)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n        .attr(\"stroke-width\", 2.5)\n        .attr(\"d\", line);\n  });\n\n  // Adicionar legenda para os anos\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - marginRight - legendWidth;\n  const legendY = marginTop;\n\n  // Legenda de gradiente horizontal\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  // Adicionar paradas de cor para a legenda\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  // Retângulo da legenda com gradiente\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Texto para a legenda\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  // Rótulos dos anos na legenda\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  return svg.node();\n}\n\n\n\n\n\n\n\nhtml`&lt;h2&gt;Lee-Carter&lt;/h2&gt;`\n\n\n\n\n\n\n\n{\n  // Declare the chart dimensions and margins.\n  const width = 800;\n  const height = 650;\n  const marginTop = 30;\n  const marginRight = 20;\n  const marginBottom = 40;\n  const marginLeft = 50;\n\n  // Extraia os valores únicos de faixa e ordene-os se necessário\n  const faixaValues = [...new Set(data_filter3.map(d =&gt; d.faixa))];\n  \n  // Use scalePoint para valores de string - isso coloca cada valor em um ponto específico\n  const x = d3.scalePoint()\n      .domain(faixaValues)\n      .range([marginLeft, width - marginRight])\n      .padding(0.5); // Adiciona espaço nas extremidades\n\n  // Declare the y (vertical position) scale.\n  const y = d3.scaleLinear()\n      .domain([d3.min(data_filter3, d =&gt; d.prev), d3.max(data_filter3, d =&gt; d.prev+1)]).nice()\n      .range([height - marginBottom, marginTop]);\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  // Adicionar definições para gradientes\n  const defs = svg.append(\"defs\");\n\n  // Separar os dados por ano (ou outro agrupamento conforme necessário)\n  const nestedData = d3.groups(data_filter3, d =&gt; d.ano);\n  \n  // Mapeando os anos entre 2024 e 2070 para cores\n  const colorScale = d3.scaleSequential()\n      .domain([2024, 2070])\n      .interpolator(d3.interpolateViridis); // Pode usar outras opções: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n  // Adicionar um gradiente para cada linha\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const gradientId = `line-gradient-${year}`;\n\n    // Criar gradiente linear\n    const gradient = defs.append(\"linearGradient\")\n        .attr(\"id\", gradientId)\n        .attr(\"gradientUnits\", \"userSpaceOnUse\")\n        .attr(\"x1\", marginLeft)\n        .attr(\"y1\", 0)\n        .attr(\"x2\", width - marginRight)\n        .attr(\"y2\", 0);\n\n    // Adicionar paradas de cor para o gradiente\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"0%\")\n        .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"100%\")\n        .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos à frente ou até 2070\n  });\n\n  // Add the x-axis.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x))\n      .selectAll(\"text\")  // Ajuste para textos inclinados se necessário\n      .style(\"text-anchor\", \"end\")\n      .attr(\"dx\", \"-.8em\")\n      .attr(\"dy\", \".15em\")\n      .attr(\"transform\", \"rotate(-45)\");\n\n  // Add the y-axis, remove the domain line, add grid lines and a label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).ticks(height / 40))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.selectAll(\".tick line\").clone()\n          .attr(\"x2\", width - marginLeft - marginRight)\n          .attr(\"stroke-opacity\", 0.1))\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Log Previsão\"));\n\n  // Declare the line generator.\n  const line = d3.line()\n      .x(d =&gt; x(d.faixa))\n      .y(d =&gt; y(d.prev));\n\n  // Desenhar uma linha para cada ano com seu próprio gradiente\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const values = yearGroup[1];\n\n    // Desenhar a linha com gradiente\n    svg.append(\"path\")\n        .datum(values)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n        .attr(\"stroke-width\", 2.5)\n        .attr(\"d\", line);\n  });\n\n  // Adicionar legenda para os anos\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - marginRight - legendWidth;\n  const legendY = marginTop;\n\n  // Legenda de gradiente horizontal\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  // Adicionar paradas de cor para a legenda\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  // Retângulo da legenda com gradiente\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Texto para a legenda\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  // Rótulos dos anos na legenda\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  return svg.node();\n}"
  },
  {
    "objectID": "teste.html",
    "href": "teste.html",
    "title": "Modelos",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\n// Dados e filtros\nprev_comb = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\nprev_lm = await FileAttachment('dados/dados2/tabuas_lc.csv').csv() \nprev_lc = await FileAttachment('dados/dados2/tabuas_lm.csv').csv()\n\nviewof sexo = Inputs.radio([\"Ambos\", \"Homens\", \"Mulheres\"], {label: \"Sexo\", value: \"Homens\"})\n\ndata_filter1 = prev_comb.filter(d =&gt; d.Local === 'Brasil' && d.Sexo === sexo).map(d =&gt; ({\n  ano: +d.Ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.nMx_previsão)\n}))\n\ndata_filter2 = prev_lm.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\ndata_filter3 = prev_lc.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\nviewof qual = Inputs.checkbox(\n  ['Lee-Carter', 'Lee-Miler', 'Combinado'], \n  {value: ['Combinado'], label: 'Modelos:'}\n)\n\n// Função principal para criar gráficos\nfunction createChart(data, title) {\n  const width = 800;\n  const height = 650;\n  const margin = {top: 30, right: 20, bottom: 40, left: 50};\n  \n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [0, 0, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto;\");\n\n  // Escalas\n  const x = d3.scalePoint()\n    .domain([...new Set(data.map(d =&gt; d.faixa))])\n    .range([margin.left, width - margin.right])\n    .padding(0.5);\n\n  const y = d3.scaleLinear()\n    .domain(d3.extent(data, d =&gt; d.prev)).nice()\n    .range([height - margin.bottom, margin.top]);\n\n  // Eixos\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - margin.bottom})`)\n    .call(d3.axisBottom(x))\n    .selectAll(\"text\")\n    .style(\"text-anchor\", \"end\")\n    .attr(\"dx\", \"-.8em\")\n    .attr(\"dy\", \".15em\")\n    .attr(\"transform\", \"rotate(-45)\");\n\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},0)`)\n    .call(d3.axisLeft(y).ticks(height / 40))\n    .call(g =&gt; g.select(\".domain\").remove())\n    .call(g =&gt; g.selectAll(\".tick line\").clone()\n      .attr(\"x2\", width - margin.left - margin.right)\n      .attr(\"stroke-opacity\", 0.1));\n\n  // Gradiente e cores\n  const colorScale = d3.scaleSequential(d3.interpolateViridis)\n    .domain([2024, 2070]);\n\n  const defs = svg.append(\"defs\");\n  const nestedData = d3.groups(data, d =&gt; d.ano);\n\n  nestedData.forEach(([year, values]) =&gt; {\n    const gradientId = `gradient-${title}-${year}`;\n    \n    const gradient = defs.append(\"linearGradient\")\n      .attr(\"id\", gradientId)\n      .attr(\"gradientUnits\", \"userSpaceOnUse\")\n      .attr(\"x1\", margin.left)\n      .attr(\"y1\", 0)\n      .attr(\"x2\", width - margin.right)\n      .attr(\"y2\", 0);\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"0%\")\n      .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"100%\")\n      .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070)));\n  });\n\n  // Linhas\n  const line = d3.line()\n    .x(d =&gt; x(d.faixa))\n    .y(d =&gt; y(d.prev));\n\n  nestedData.forEach(([year, values]) =&gt; {\n    svg.append(\"path\")\n      .datum(values)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", `url(#gradient-${title}-${year})`)\n      .attr(\"stroke-width\", 2.5)\n      .attr(\"d\", line);\n  });\n\n  // Legenda\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - margin.right - legendWidth;\n  const legendY = margin.top;\n\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", `legend-${title}`)\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", `url(#legend-${title})`);\n\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  // Título\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .style(\"font-size\", \"1.2em\")\n    .text(title);\n\n  return svg.node();\n}\n\n// Renderização dos gráficos\n{\n  const container = document.createElement('div');\n  container.style.display = \"grid\";\n  container.style.gap = \"2rem\";\n  container.style.justifyContent = \"center\";\n\n  if (qual.includes(\"Combinado\")) {\n    container.appendChild(createChart(data_filter1, \"Combinado\"));\n  }\n  if (qual.includes(\"Lee-Miler\")) {\n    container.appendChild(createChart(data_filter2, \"Lee-Miller\"));\n  }\n  if (qual.includes(\"Lee-Carter\")) {\n    container.appendChild(createChart(data_filter3, \"Lee-Carter\"));\n  }\n\n  return qual.length === 0 \n    ? html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n    : container;\n}"
  },
  {
    "objectID": "modelos.html#modelos-de-previsão-da-taxa-central-de-mortalidade",
    "href": "modelos.html#modelos-de-previsão-da-taxa-central-de-mortalidade",
    "title": "Modelos",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\n// Dados e filtros\nprev_comb = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\nprev_lm = await FileAttachment('dados/dados2/tabuas_lc.csv').csv() \nprev_lc = await FileAttachment('dados/dados2/tabuas_lm.csv').csv()\n\nviewof sexo = Inputs.radio([\"Ambos\", \"Homens\", \"Mulheres\"], {label: \"Sexo\", value: \"Homens\"})\n\ndata_filter1 = prev_comb.filter(d =&gt; d.Local === 'Brasil' && d.Sexo === sexo).map(d =&gt; ({\n  ano: +d.Ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.nMx_previsão)\n}))\n\ndata_filter2 = prev_lm.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\ndata_filter3 = prev_lc.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\nviewof qual = Inputs.checkbox(\n  ['Combinado', 'Lee-Carter', 'Lee-Miler'], \n  {value: ['Combinado'], label: 'Modelos:'}\n)\n\n// Função principal para criar gráficos\nfunction createChart(data, title) {\n  const width = 800;\n  const height = 550;\n  const margin = {top: 30, right: 20, bottom: 40, left: 50};\n  \n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [0, 0, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto;\");\n\n  // Escalas\n  const x = d3.scalePoint()\n    .domain([...new Set(data.map(d =&gt; d.faixa))])\n    .range([margin.left, width - margin.right])\n    .padding(0.5);\n\n  const y = d3.scaleLinear()\n    .domain(d3.extent(data, d =&gt; d.prev)).nice()\n    .range([height - margin.bottom, margin.top]);\n\n  // Eixos\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - margin.bottom})`)\n    .call(d3.axisBottom(x))\n    .selectAll(\"text\")\n    .style(\"text-anchor\", \"end\")\n    .attr(\"dx\", \"-.8em\")\n    .attr(\"dy\", \".15em\")\n    .attr(\"transform\", \"rotate(-45)\");\n\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},0)`)\n    .call(d3.axisLeft(y).ticks(height / 40))\n    .call(g =&gt; g.select(\".domain\").remove())\n    .call(g =&gt; g.selectAll(\".tick line\").clone()\n      .attr(\"x2\", width - margin.left - margin.right)\n      .attr(\"stroke-opacity\", 0.1));\n\n  // Gradiente e cores\n  const colorScale = d3.scaleSequential(d3.interpolateViridis)\n    .domain([2024, 2070]);\n\n  const defs = svg.append(\"defs\");\n  const nestedData = d3.groups(data, d =&gt; d.ano);\n\n  nestedData.forEach(([year, values]) =&gt; {\n    const gradientId = `gradient-${title}-${year}`;\n    \n    const gradient = defs.append(\"linearGradient\")\n      .attr(\"id\", gradientId)\n      .attr(\"gradientUnits\", \"userSpaceOnUse\")\n      .attr(\"x1\", margin.left)\n      .attr(\"y1\", 0)\n      .attr(\"x2\", width - margin.right)\n      .attr(\"y2\", 0);\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"0%\")\n      .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"100%\")\n      .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070)));\n  });\n\n  // Linhas\n  const line = d3.line()\n    .x(d =&gt; x(d.faixa))\n    .y(d =&gt; y(d.prev));\n\n  nestedData.forEach(([year, values]) =&gt; {\n    svg.append(\"path\")\n      .datum(values)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", `url(#gradient-${title}-${year})`)\n      .attr(\"stroke-width\", 2.5)\n      .attr(\"d\", line);\n  });\n\n  // Legenda\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - margin.right - legendWidth;\n  const legendY = margin.top;\n\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", `legend-${title}`)\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", `url(#legend-${title})`);\n\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  // Título\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .style(\"font-size\", \"1.2em\")\n    .text(title);\n\n  return svg.node();\n}\n\n// Renderização dos gráficos\n{\n  const container = document.createElement('div');\n  container.style.display = \"grid\";\n  container.style.gap = \"2rem\";\n  container.style.justifyContent = \"center\";\n\n  if (qual.includes(\"Combinado\")) {\n    container.appendChild(createChart(data_filter1, \"Combinado\"));\n  }\n  if (qual.includes(\"Lee-Miler\")) {\n    container.appendChild(createChart(data_filter2, \"Lee-Miller\"));\n  }\n  if (qual.includes(\"Lee-Carter\")) {\n    container.appendChild(createChart(data_filter3, \"Lee-Carter\"));\n  }\n\n  return qual.length === 0 \n    ? html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n    : container;\n}"
  }
]