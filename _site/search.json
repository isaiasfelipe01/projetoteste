[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sistemas Inteligentes para Gest√£o de Riscos e Previs√µes - SIGERIP",
    "section": "",
    "text": "O projeto tem como objetivo principal impactar a comunidade interna e externa por meio do desenvolvimento de sistemas inteligentes de apoio √† decis√£o com enfoque na gest√£o de riscos e previs√£o de dados demogr√°ficos e atuariais. Objetivos espec√≠ficos: Dessa maneira, os objetivos espec√≠ficos s√£o: - Oportunizar √† equipe do projeto uma forma√ß√£o cidad√£ e profissional ao resolver um problema real da sociedade, por meio de um sistema inteligente para web. - Promover a capacita√ß√£o dos discentes da UFPB, integrando ensino, extens√£o e pesquisa a partir de uma aplica√ß√£o de proje√ß√£o de mortalidade humana. - Desenvolver uma aplica√ß√£o web interativa a qual disponibilizar√° dados demogr√°ficos de expectativa de vida, quantitativo populacional, taxas de mortalidade, proje√ß√µes dessas informa√ß√µes e de c√°lculos atuariais. - Disponibilizar o sistema desenvolvido na web de forma gratuita para toda a sociedade. - Realizar oficinas para capacitar a comunidade externa a tomar melhor decis√µes dos dados e proje√ß√µes de taxa de mortalidade e expectativa de vida.\n\nviewof contatos = {\n  // Elementos do modal\n  const overlay = document.createElement('div');\n  const modal = document.createElement('div');\n  const closeBtn = document.createElement('span');\n  const content = document.createElement('div');\n\n  // Conte√∫do do modal\n  content.innerHTML = `\n  &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css\"&gt;\n  \n    \n    &lt;h3 style=\"margin:0;color:#2c3e50;padding-bottom:15px;border-bottom:2px solid #3498db\"&gt;Equipe SIGERIP&lt;/h3&gt;\n    &lt;div style=\"margin-top:20px;max-width: 450px;height: 450px;padding-right: 10px;overflow-y: scroll;overflow-x: hidden;line-height:1.6\"&gt;\n      &lt;ul class=\"lista-equipe\"&gt;\n\n      &lt;!-- Prof Filipe --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Filipe C. L. Duarte&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Coordenador - T√°buas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/filipeclduarte/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; filipe_pb_duarte@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Prof Gustavo --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Gustavo C. Xavier&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Coordenador Adjunto - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/gcxavier/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; gustavocorreiaxavier@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Prof Herick --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Herick C. G. Oliveira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Colaborador - Mortalidade intantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/herickcidarta/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; hcidarta@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n      \n      &lt;!-- TODO: FALTA EMAIL E LINKEDIN Tassia --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Tassia T. S. Oliveira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Colaboradora&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; email.aqui\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: falta linkedin Beatriz--&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Beatriz G. Olinpio&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Volunt√°ria - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; bgo@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Cleo --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Cleo D. Anacleto&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Bolsista - T√°buas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/cleo-decker-anacleto-66a69b133/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; cleodecker@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Cristiane --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Cristiane S. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Volunt√°ria - T√°buas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; css3@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: FALTA LINKEDIN Gabrielle --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Gabrielle S. M. Vieira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Volunt√°ria - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; gabrielle.samara230@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Igor --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Igor B. Kutelak&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Volunt√°rio - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/igor-kutelak-20b10a194/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; Kutelak.igor@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Isaias --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Isaias F. S. Sousa&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Volunt√°rio - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/isa%C3%ADas-felipe-silva-de-sousa-453902327/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; isaias.felipe@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: FALTA LINKEDIN Jefferson --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Jefferson G. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Volunt√°rio - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; jeffeersonguilhermeh@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- St√™nio --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Jo√£o P. S. F. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Volunt√°rio - T√°buas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/jo%C3%A3o-pedro-st%C3%AAnio-2861071b3/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; jpsfs2@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!--TODO: FALTA LINKEDIN Nathiely --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Nathiely B. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Volunt√°ria - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; nathiely.silva@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n      \n    &lt;/ul&gt;\n    &lt;/div&gt;\n  `;\n\n  // Estiliza√ß√£o do modal\n  Object.assign(overlay.style, {\n    display: 'none',\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0,0,0,0.5)',\n    zIndex: 1000\n  });\n\n  Object.assign(modal.style, {\n    position: 'fixed',\n    top: '50%',\n    left: '50%',\n    transform: 'translate(-50%, -50%)',\n    backgroundColor: 'white',\n    padding: '25px',\n    borderRadius: '10px',\n    width: 'min(90%, 500px)',\n    boxShadow: '0 5px 15px rgba(0,0,0,0.2)'\n  });\n\n  Object.assign(closeBtn.style, {\n    position: 'absolute',\n    right: '15px',\n    top: '10px',\n    cursor: 'pointer',\n    fontSize: '28px',\n    color: '#666',\n    transition: 'color 0.2s'\n  });\n\n  // Montagem do modal\n  closeBtn.innerHTML = '&times;';\n  modal.append(closeBtn, content);\n  overlay.append(modal);\n  document.body.append(overlay);\n\n  // Container para centraliza√ß√£o\n  const container = document.createElement('div');\n  Object.assign(container.style, {\n    display: 'flex',\n    justifyContent: 'center',\n    width: '100%',\n    margin: '30px 0'\n  });\n\n  // Cria√ß√£o do bot√£o centralizado\n  const btn = Inputs.button(\"üë• Conhe√ßa Nossa Equipe\");\n  btn.className = \"botao-equipe\"; // ‚Üê Adicione esta linha\n\n  // Efeitos de hover\n  btn.addEventListener('mouseenter', () =&gt; {\n    btn.style.transform = 'scale(1.05)';\n    btn.style.boxShadow = '0 6px 8px rgba(0,0,0,0.2)';\n  });\n\n  btn.addEventListener('mouseleave', () =&gt; {\n    btn.style.transform = 'scale(1)';\n    btn.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)';\n  });\n\n  // Event listeners\n  btn.addEventListener('click', () =&gt; overlay.style.display = 'block');\n  closeBtn.addEventListener('click', () =&gt; overlay.style.display = 'none');\n  overlay.addEventListener('click', e =&gt; e.target === overlay && (overlay.style.display = 'none'));\n  document.addEventListener('keydown', e =&gt; e.key === 'Escape' && (overlay.style.display = 'none'));\n\n  // Adiciona bot√£o ao container\n  container.append(btn);\n  \n  return container;\n}\n\n\n\n\n\n\nhtml`\n&lt;style&gt;\n  /* Estilos Gerais */\n  .equipe-container {\n    display: flex;\n    justify-content: center;\n    margin: 40px 0;\n  }\n\n  .botao-equipe {\n    padding: 15px 35px;\n    background: linear-gradient(135deg, #2c3e50, #3498db);\n    color: white;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 18px;\n    font-weight: 600;\n    transition: all 0.3s ease;\n    box-shadow: 0 4px 15px rgba(44, 62, 80, 0.2);\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n\n  .botao-equipe:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px rgba(44, 62, 80, 0.3);\n  }\n\n  .modal-overlay {\n    display: none;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0,0,0,0.5);\n    z-index: 1000;\n    backdrop-filter: blur(3px);\n  }\n\n  .modal-equipe {\n    position: relative;\n    background: white;\n    padding: 30px;\n    border-radius: 12px;\n    width: 90%;\n    max-width: 600px;\n    margin: 5% auto;\n    box-shadow: 0 10px 30px rgba(0,0,0,0.2);\n  }\n\n  .lista-equipe {\n    list-style: none;\n    padding: 0;\n    margin: 20px 0;\n  }\n\n  .membro-equipe {\n    padding: 15px;\n    margin: 10px 0;\n    background: #f8f9fa;\n    border-radius: 8px;\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    transition: transform 0.2s;\n  }\n\n  .membro-equipe:hover {\n    transform: translateX(10px);\n    background: #f1f3f5;\n  }\n\n  .fechar-modal {\n    position: absolute;\n    top: 15px;\n    right: 20px;\n    font-size: 28px;\n    cursor: pointer;\n    color: #666;\n    transition: color 0.2s;\n  }\n\n  .fechar-modal:hover {\n    color: #333;\n  }\n  .botao-equipe {\n  background: #343a40 !important; /* Azul mais claro */\n  color: #ffffff !important;\n  /* mant√©m o restante das propriedades */\n}\n&lt;/style&gt;\n\n&lt;script&gt;\n  // JavaScript Corrigido\n  document.addEventListener('DOMContentLoaded', () =&gt; {\n    const btnAbrir = document.getElementById('btnEquipe');\n    const btnFechar = document.getElementById('fecharModal');\n    const modal = document.getElementById('modalEquipe');\n\n    if(btnAbrir && btnFechar && modal) {\n      // Abrir modal\n      btnAbrir.addEventListener('click', () =&gt; {\n        modal.style.display = 'block';\n      });\n\n      // Fechar modal\n      btnFechar.addEventListener('click', () =&gt; {\n        modal.style.display = 'none';\n      });\n\n      // Fechar ao clicar fora\n      window.addEventListener('click', (e) =&gt; {\n        if(e.target === modal) {\n          modal.style.display = 'none';\n        }\n      });\n\n      // Fechar com ESC\n      document.addEventListener('keydown', (e) =&gt; {\n        if(e.key === 'Escape') {\n          modal.style.display = 'none';\n        }\n      });\n    } else {\n      console.error('Verifique os IDs dos elementos:', {btnAbrir, btnFechar, modal});\n    }\n  });\n  function copiarEmail() {\n        // Obt√©m o conte√∫do do elemento que cont√©m o email\n        const email = document.getElementById(\"email\").textContent;\n        \n        // Copia o email para a √°rea de transfer√™ncia usando a Clipboard API\n        navigator.clipboard.writeText(email)\n          .then(() =&gt; {\n            // Exibe uma mensagem de confirma√ß√£o\n            alert(\"Email copiado com sucesso!\");\n          })\n          .catch(err =&gt; {\n            console.error(\"Erro ao copiar o email:\", err);\n          });\n      }\n&lt;/script&gt;\n`"
  },
  {
    "objectID": "index.html#objetivo",
    "href": "index.html#objetivo",
    "title": "Sistemas Inteligentes para Gest√£o de Riscos e Previs√µes - SIGERIP",
    "section": "",
    "text": "O projeto tem como objetivo principal impactar a comunidade interna e externa por meio do desenvolvimento de sistemas inteligentes de apoio √† decis√£o com enfoque na gest√£o de riscos e previs√£o de dados demogr√°ficos e atuariais. Objetivos espec√≠ficos: Dessa maneira, os objetivos espec√≠ficos s√£o: - Oportunizar √† equipe do projeto uma forma√ß√£o cidad√£ e profissional ao resolver um problema real da sociedade, por meio de um sistema inteligente para web. - Promover a capacita√ß√£o dos discentes da UFPB, integrando ensino, extens√£o e pesquisa a partir de uma aplica√ß√£o de proje√ß√£o de mortalidade humana. - Desenvolver uma aplica√ß√£o web interativa a qual disponibilizar√° dados demogr√°ficos de expectativa de vida, quantitativo populacional, taxas de mortalidade, proje√ß√µes dessas informa√ß√µes e de c√°lculos atuariais. - Disponibilizar o sistema desenvolvido na web de forma gratuita para toda a sociedade. - Realizar oficinas para capacitar a comunidade externa a tomar melhor decis√µes dos dados e proje√ß√µes de taxa de mortalidade e expectativa de vida.\n\nviewof contatos = {\n  // Elementos do modal\n  const overlay = document.createElement('div');\n  const modal = document.createElement('div');\n  const closeBtn = document.createElement('span');\n  const content = document.createElement('div');\n\n  // Conte√∫do do modal\n  content.innerHTML = `\n  &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css\"&gt;\n  \n    \n    &lt;h3 style=\"margin:0;color:#2c3e50;padding-bottom:15px;border-bottom:2px solid #3498db\"&gt;Equipe SIGERIP&lt;/h3&gt;\n    &lt;div style=\"margin-top:20px;max-width: 450px;height: 450px;padding-right: 10px;overflow-y: scroll;overflow-x: hidden;line-height:1.6\"&gt;\n      &lt;ul class=\"lista-equipe\"&gt;\n\n      &lt;!-- Prof Filipe --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Filipe C. L. Duarte&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Coordenador - T√°buas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/filipeclduarte/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; filipe_pb_duarte@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Prof Gustavo --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Gustavo C. Xavier&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Coordenador Adjunto - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/gcxavier/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; gustavocorreiaxavier@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Prof Herick --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Prof. Dr. Herick C. G. Oliveira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Colaborador - Mortalidade intantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/herickcidarta/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; hcidarta@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n      \n      &lt;!-- TODO: FALTA EMAIL E LINKEDIN Tassia --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Tassia T. S. Oliveira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Colaboradora&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; email.aqui\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: falta linkedin Beatriz--&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Beatriz G. Olinpio&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Volunt√°ria - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; bgo@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Cleo --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Cleo D. Anacleto&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Bolsista - T√°buas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/cleo-decker-anacleto-66a69b133/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; cleodecker@hotmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Cristiane --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Cristiane S. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Volunt√°ria - T√°buas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; css3@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: FALTA LINKEDIN Gabrielle --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Gabrielle S. M. Vieira&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Volunt√°ria - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; gabrielle.samara230@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Igor --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Igor B. Kutelak&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Volunt√°rio - Mortalidade infantil&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/igor-kutelak-20b10a194/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; Kutelak.igor@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- Isaias --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Isaias F. S. Sousa&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Volunt√°rio - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/isa%C3%ADas-felipe-silva-de-sousa-453902327/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; isaias.felipe@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- TODO: FALTA LINKEDIN Jefferson --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Jefferson G. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Volunt√°rio - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; jeffeersonguilhermeh@gmail.com\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!-- St√™nio --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Jo√£o P. S. F. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluno Volunt√°rio - T√°buas de mortalidade&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"https://www.linkedin.com/in/jo%C3%A3o-pedro-st%C3%AAnio-2861071b3/\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; jpsfs2@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n\n      &lt;!--TODO: FALTA LINKEDIN Nathiely --&gt;\n      &lt;li class=\"membro-equipe\"&gt;\n          &lt;span style=\"font-size:24px\"&gt;&lt;/span&gt;\n          &lt;div&gt;\n              &lt;h3 style=\"margin: 0; color: #2c3e50;\"&gt;Nathiely B. Silva&lt;/h3&gt;\n              &lt;p style=\"margin: 5px 0; color: #666;\"&gt;Aluna Volunt√°ria - Sistema web&lt;/p&gt;\n              &lt;p style=\"margin: 0;\"&gt;\n                  &lt;!-- Link para o LinkedIn --&gt;\n                  &lt;a href=\"\" \n                    target=\"_blank\" \n                    style=\"color: #0077b5; text-decoration: none;\"&gt;\n                      &lt;i class=\"fab fa-linkedin\"&gt;&lt;/i&gt; LinkedIn\n                  &lt;/a&gt;\n                  &lt;br&gt;\n\n                  &lt;!-- Link para abrir o Gmail --&gt;\n                  &lt;i class=\"fas fa-envelope\"&gt;&lt;/i&gt; nathiely.silva@academico.ufpb.br\n                  \n              &lt;/p&gt;\n          &lt;/div&gt;\n      &lt;/li&gt;\n      \n    &lt;/ul&gt;\n    &lt;/div&gt;\n  `;\n\n  // Estiliza√ß√£o do modal\n  Object.assign(overlay.style, {\n    display: 'none',\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0,0,0,0.5)',\n    zIndex: 1000\n  });\n\n  Object.assign(modal.style, {\n    position: 'fixed',\n    top: '50%',\n    left: '50%',\n    transform: 'translate(-50%, -50%)',\n    backgroundColor: 'white',\n    padding: '25px',\n    borderRadius: '10px',\n    width: 'min(90%, 500px)',\n    boxShadow: '0 5px 15px rgba(0,0,0,0.2)'\n  });\n\n  Object.assign(closeBtn.style, {\n    position: 'absolute',\n    right: '15px',\n    top: '10px',\n    cursor: 'pointer',\n    fontSize: '28px',\n    color: '#666',\n    transition: 'color 0.2s'\n  });\n\n  // Montagem do modal\n  closeBtn.innerHTML = '&times;';\n  modal.append(closeBtn, content);\n  overlay.append(modal);\n  document.body.append(overlay);\n\n  // Container para centraliza√ß√£o\n  const container = document.createElement('div');\n  Object.assign(container.style, {\n    display: 'flex',\n    justifyContent: 'center',\n    width: '100%',\n    margin: '30px 0'\n  });\n\n  // Cria√ß√£o do bot√£o centralizado\n  const btn = Inputs.button(\"üë• Conhe√ßa Nossa Equipe\");\n  btn.className = \"botao-equipe\"; // ‚Üê Adicione esta linha\n\n  // Efeitos de hover\n  btn.addEventListener('mouseenter', () =&gt; {\n    btn.style.transform = 'scale(1.05)';\n    btn.style.boxShadow = '0 6px 8px rgba(0,0,0,0.2)';\n  });\n\n  btn.addEventListener('mouseleave', () =&gt; {\n    btn.style.transform = 'scale(1)';\n    btn.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)';\n  });\n\n  // Event listeners\n  btn.addEventListener('click', () =&gt; overlay.style.display = 'block');\n  closeBtn.addEventListener('click', () =&gt; overlay.style.display = 'none');\n  overlay.addEventListener('click', e =&gt; e.target === overlay && (overlay.style.display = 'none'));\n  document.addEventListener('keydown', e =&gt; e.key === 'Escape' && (overlay.style.display = 'none'));\n\n  // Adiciona bot√£o ao container\n  container.append(btn);\n  \n  return container;\n}\n\n\n\n\n\n\nhtml`\n&lt;style&gt;\n  /* Estilos Gerais */\n  .equipe-container {\n    display: flex;\n    justify-content: center;\n    margin: 40px 0;\n  }\n\n  .botao-equipe {\n    padding: 15px 35px;\n    background: linear-gradient(135deg, #2c3e50, #3498db);\n    color: white;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 18px;\n    font-weight: 600;\n    transition: all 0.3s ease;\n    box-shadow: 0 4px 15px rgba(44, 62, 80, 0.2);\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n\n  .botao-equipe:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px rgba(44, 62, 80, 0.3);\n  }\n\n  .modal-overlay {\n    display: none;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0,0,0,0.5);\n    z-index: 1000;\n    backdrop-filter: blur(3px);\n  }\n\n  .modal-equipe {\n    position: relative;\n    background: white;\n    padding: 30px;\n    border-radius: 12px;\n    width: 90%;\n    max-width: 600px;\n    margin: 5% auto;\n    box-shadow: 0 10px 30px rgba(0,0,0,0.2);\n  }\n\n  .lista-equipe {\n    list-style: none;\n    padding: 0;\n    margin: 20px 0;\n  }\n\n  .membro-equipe {\n    padding: 15px;\n    margin: 10px 0;\n    background: #f8f9fa;\n    border-radius: 8px;\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    transition: transform 0.2s;\n  }\n\n  .membro-equipe:hover {\n    transform: translateX(10px);\n    background: #f1f3f5;\n  }\n\n  .fechar-modal {\n    position: absolute;\n    top: 15px;\n    right: 20px;\n    font-size: 28px;\n    cursor: pointer;\n    color: #666;\n    transition: color 0.2s;\n  }\n\n  .fechar-modal:hover {\n    color: #333;\n  }\n  .botao-equipe {\n  background: #343a40 !important; /* Azul mais claro */\n  color: #ffffff !important;\n  /* mant√©m o restante das propriedades */\n}\n&lt;/style&gt;\n\n&lt;script&gt;\n  // JavaScript Corrigido\n  document.addEventListener('DOMContentLoaded', () =&gt; {\n    const btnAbrir = document.getElementById('btnEquipe');\n    const btnFechar = document.getElementById('fecharModal');\n    const modal = document.getElementById('modalEquipe');\n\n    if(btnAbrir && btnFechar && modal) {\n      // Abrir modal\n      btnAbrir.addEventListener('click', () =&gt; {\n        modal.style.display = 'block';\n      });\n\n      // Fechar modal\n      btnFechar.addEventListener('click', () =&gt; {\n        modal.style.display = 'none';\n      });\n\n      // Fechar ao clicar fora\n      window.addEventListener('click', (e) =&gt; {\n        if(e.target === modal) {\n          modal.style.display = 'none';\n        }\n      });\n\n      // Fechar com ESC\n      document.addEventListener('keydown', (e) =&gt; {\n        if(e.key === 'Escape') {\n          modal.style.display = 'none';\n        }\n      });\n    } else {\n      console.error('Verifique os IDs dos elementos:', {btnAbrir, btnFechar, modal});\n    }\n  });\n  function copiarEmail() {\n        // Obt√©m o conte√∫do do elemento que cont√©m o email\n        const email = document.getElementById(\"email\").textContent;\n        \n        // Copia o email para a √°rea de transfer√™ncia usando a Clipboard API\n        navigator.clipboard.writeText(email)\n          .then(() =&gt; {\n            // Exibe uma mensagem de confirma√ß√£o\n            alert(\"Email copiado com sucesso!\");\n          })\n          .catch(err =&gt; {\n            console.error(\"Erro ao copiar o email:\", err);\n          });\n      }\n&lt;/script&gt;\n`"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "graficos.html",
    "href": "graficos.html",
    "title": "Gr√°ficos",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n// Carregando os dados\nstateData1 = await FileAttachment(\"expec.csv\").csv()\nstateData = tabelaFiltrada2.map(d =&gt; ({\n  estado: d.estado,\n  valor: +d.valor // Converte para n√∫mero\n}))\ntabelaFiltrada2 = stateData1\n    .filter(d =&gt; +d.Ano === ano5)\n    .map(d =&gt; ({\n        estado: d.Local,\n        valor: d.ex\n    }));\n\n\ndados = FileAttachment(\"comp_pop.csv\").csv()\ntabelaFiltrada = dados.filter(d =&gt; d.new_local === estados &&\n                                   +d.Ano === ano6)"
  },
  {
    "objectID": "graficos.html#mapa-da-expectativa-de-vida-ao-nascer-por-unidade-federativa",
    "href": "graficos.html#mapa-da-expectativa-de-vida-ao-nascer-por-unidade-federativa",
    "title": "Gr√°ficos",
    "section": "Mapa da expectativa de vida ao nascer por Unidade Federativa",
    "text": "Mapa da expectativa de vida ao nascer por Unidade Federativa\nO mapa representa a expectativa de vida ao nascer distribuido entre estados e Distrito Federal ao longo dos anos de 2000 a 2023.\n\nPLotData\n\n\n\nviewof ano5 = Inputs.range([2000, 2023],\n       {\n        value: [2000],\n        step: 1,\n        label: \"Ano: \"\n    }\n)\n\n// Carregar o GeoJSON dos estados brasileiros\ngeoData = await fetch(\"https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/brazil-states.geojson\")\n  .then(response =&gt; response.json())\n\n// Criar o mapa\nwidth = 800;\nheight = 600;\n\nchart3 = {\n  const svg = d3.create(\"svg\")\n    .attr(\"viewBox\", [0, 0, width, height])\n    .style(\"width\", \"100%\")\n    .style(\"height\", \"auto\");\n\n  // Configurar a proje√ß√£o\n  const projection = d3.geoMercator()\n    .center([-52, -15]) // Centralizar no Brasil\n    .scale(700)\n    .translate([width / 2, height / 2]);\n\n  const path = d3.geoPath().projection(projection);\n\n  // Criar escala de cores\n  const valores = stateData.map(d =&gt; d.valor);\n  const colorScale = d3.scaleSequential()\n    .domain([d3.min(valores), d3.max(valores)])\n    .interpolator(d3.interpolateBlues);\n\n  // Fun√ß√£o para normalizar nomes (remover acentos)\n  const normalizeName = name =&gt; name\n    ? name.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").toLowerCase()\n    : \"\";\n\n  // Criar mapa\n  svg.selectAll(\"path\")\n    .data(geoData.features)\n    .join(\"path\")\n    .attr(\"d\", path)\n    .attr(\"fill\", d =&gt; {\n      const state = stateData.find(s =&gt;\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n      return state ? colorScale(state.valor) : \"#ccc\";\n    })\n    .attr(\"stroke\", \"white\")\n    .attr(\"stroke-width\", 0.5);\n\n  // Adicionar tooltip\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .attr(\"class\", \"tooltip\")\n    .style(\"opacity\", 0)\n    .style(\"position\", \"absolute\")\n    .style(\"background-color\", \"white\")\n    .style(\"border\", \"solid\")\n    .style(\"border-width\", \"1px\")\n    .style(\"border-radius\", \"5px\")\n    .style(\"padding\", \"5px\");\n\n  svg.selectAll(\"path\")\n    .on(\"mouseover\", (event, d) =&gt; {\n      const state = stateData.find(s =&gt;\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", .9);\n\n      tooltip.html(`\n        Estado: ${d.properties.name}&lt;br/&gt;\n        Valor: ${state ? state.valor : 'Sem dados'}\n      `)\n        .style(\"left\", (event.pageX + 10) + \"px\")\n        .style(\"top\", (event.pageY - 28) + \"px\");\n    })\n    .on(\"mouseout\", () =&gt; {\n      tooltip.transition()\n        .duration(500)\n        .style(\"opacity\", 0);\n    });\n\n  // Adicionar barra de cores (legenda)\n  const legendWidth = 400;\n  const legendHeight = 20;\n\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${(width - legendWidth) / 2}, ${height - 25})`);\n\n  const gradient = legend.append(\"defs\")\n    .append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"y2\", \"0%\");\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"0%\")\n    .attr(\"stop-color\", colorScale(d3.min(valores)));\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"100%\")\n    .attr(\"stop-color\", colorScale(d3.max(valores)));\n\n  legend.append(\"rect\")\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Adicionar r√≥tulos na barra de cores\n  legend.append(\"text\")\n    .attr(\"x\", 0)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"start\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.min(valores)));\n\n  legend.append(\"text\")\n    .attr(\"x\", legendWidth)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"end\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.max(valores)));\n\n  return svg.node();\n}\n\n// Mostrar valores m√≠nimos e m√°ximos\n    minMaxValues = {\n    const valores = stateData.map(d =&gt; d.valor);\n    return {\n        min: d3.min(valores),\n        max: d3.max(valores)\n    };\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.table(tabelaFiltrada2)\n\n\n\n\n\n\n\nhtml`\n&lt;body&gt;\n    &lt;a href=\"expec.csv\" download&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ‚¨áÔ∏è Baixar CSV completo\n        &lt;/button&gt;\n    &lt;/a&gt;\n    &lt;a download=\"tabelaFiltrada2.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\"&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ‚¨áÔ∏è Baixar CSV filtrado\n        &lt;/button&gt;\n&lt;/a&gt;\n&lt;/body&gt;\n`"
  },
  {
    "objectID": "graficos.html#evolu√ß√£o-da-popula√ß√£o-por-faixa-et√°ria",
    "href": "graficos.html#evolu√ß√£o-da-popula√ß√£o-por-faixa-et√°ria",
    "title": "Gr√°ficos",
    "section": "Evolu√ß√£o da Popula√ß√£o por faixa-et√°ria",
    "text": "Evolu√ß√£o da Popula√ß√£o por faixa-et√°ria\nO gr√°fico representa uma compara√ß√£o entre dados interpolados pelo IBGE e por n√≥s (SIGERIP), que nos demonstra a popula√ß√£o por faixa-et√°ria sellecionado por na√ß√£o, regi√µes, estados e distrito federal.\n\nPLotData\n\n\n\nviewof ano6 = Inputs.range([2000, 2023],\n       {\n        value: [2000],\n        step: 1,\n        label: \"Ano: \"\n    }\n)\n\nviewof estados = Inputs.select(['Brasil', 'Norte', 'Nordeste', 'Sudeste', 'Sul', 'Centro-Oeste',\n       'Rond√¥nia', 'Acre', 'Amazonas', 'Roraima', 'Par√°', 'Amap√°',\n       'Tocantins', 'Maranh√£o', 'Piau√≠', 'Cear√°', 'Rio Grande do Norte',\n       'Para√≠ba', 'Pernambuco', 'Alagoas', 'Sergipe', 'Bahia',\n       'Minas Gerais', 'Esp√≠rito Santo', 'Rio de Janeiro', 'S√£o Paulo',\n       'Paran√°', 'Santa Catarina', 'Rio Grande do Sul',\n       'Mato Grosso do Sul', 'Mato Grosso', 'Goi√°s', 'Distrito Federal'],\n       {\n        value: 'Brasil',\n        label: \"Local: \"\n        }\n       )\n\n// Gr√°fico\nchart = {{\n  // Defini√ß√£o das dimens√µes do gr√°fico\n  const width = 828;  // Largura do gr√°fico\n  const height = 600; // Altura do gr√°fico\n  const marginTop = 20;    // Margem superior\n  const marginRight = 20;  // Margem direita\n  const marginBottom = 30; // Margem inferior\n  const marginLeft = 50;   // Margem esquerda\n\n  // Escala para o eixo X (Ano)\n  const x = d3.scaleLinear()\n    .domain(d3.extent(tabelaFiltrada, d =&gt; +d.new_faixa))  // Determina o intervalo de valores para o eixo X com base no ano\n    .range([marginLeft, width - marginRight]);  // Define o intervalo de pixels no eixo X\n\n  // Escala para o eixo Y (Total)\n  const y = d3.scaleLinear()\n    .domain([d3.min(tabelaFiltrada, d =&gt; +d.Total), d3.max(tabelaFiltrada, d =&gt; +d.Total)]).nice()  // Define o intervalo de valores para o eixo Y com base no total\n    .range([height - marginBottom, marginTop]);  // Define o intervalo de pixels no eixo Y\n\n  // Defini√ß√£o de cores para as linhas\n  const color = d3.scaleOrdinal(d3.schemeCategory10);  // Usa uma paleta de cores pr√©-definida do D3\n\n  // Cria√ß√£o do elemento SVG para o gr√°fico\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)  // Define a largura do SVG\n    .attr(\"height\", height)  // Define a altura do SVG\n    .attr(\"viewBox\", [0, 0, width, height])  // Define a visualiza√ß√£o do SVG com base nas dimens√µes\n    .style(\"max-width\", \"100%\")  // Estilo para garantir que o gr√°fico seja responsivo\n    .style(\"height\", \"auto\")  // Estilo para ajustar a altura automaticamente\n    .style(\"overflow\", \"visible\")  // Permite que os elementos do gr√°fico saiam do limite do SVG\n    .style(\"font\", \"10px sans-serif\");  // Define o estilo da fonte no gr√°fico\n\n  // Adiciona o eixo X (ano)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - marginBottom})`)  // Posiciona o eixo X na parte inferior\n    .call(d3.axisBottom(x).tickFormat(d3.format(\"d\")));  // Aplica a escala X e formata os ticks como n√∫meros inteiros\n\n  // Adiciona o eixo Y (total)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${marginLeft},0)`)  // Posiciona o eixo Y √† esquerda\n    .call(d3.axisLeft(y))  // Aplica a escala Y\n    .call(g =&gt; g.select(\".domain\").remove())  // Remove a linha do eixo Y\n    .call(g =&gt; g.append(\"text\")  // Adiciona texto ao lado do eixo Y\n      .attr(\"x\", -marginLeft)  // Posiciona o texto √† esquerda do gr√°fico\n      .attr(\"y\", 10)  // Posiciona o texto no eixo Y\n      .attr(\"fill\", \"currentColor\")  // Define a cor do texto\n      .attr(\"text-anchor\", \"start\")  // Define o alinhamento do texto\n      .text(\"‚Üë Total (%)\"));  // Texto do eixo Y\n\n  // Agrupa os dados pela coluna UF (Unidade Federativa)\n  const groupedData = d3.group(tabelaFiltrada, d =&gt; d.Fonte);\n\n  // Define a fun√ß√£o para desenhar as linhas no gr√°fico\n  const line = d3.line()\n    .x(d =&gt; x(+d.new_faixa))  // Define a posi√ß√£o X da linha com base no ano\n    .y(d =&gt; y(+d.Total));  // Define a posi√ß√£o Y da linha com base no total\n\n  // Adiciona as linhas para cada grupo de dados\n  const paths = svg.append(\"g\")\n    .selectAll(\"path\")  // Seleciona todos os elementos \"path\" (caminhos das linhas)\n    .data(groupedData)  // Vincula os dados agrupados (por UF)\n    .join(\"path\")  // Cria um novo \"path\" para cada grupo de dados\n    .attr(\"fill\", \"none\")  // Define que as linhas n√£o ter√£o preenchimento\n    .attr(\"stroke\", ([key]) =&gt; color(key))  // Define a cor da linha de acordo com a UF\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da linha\n    .attr(\"d\", ([, values]) =&gt; line(values));  // Desenha a linha para cada conjunto de dados\n\n  // Adiciona o texto com o nome da UF na extremidade de cada linha\n  svg.append(\"g\")\n    .selectAll(\"text\")\n    .data(groupedData)\n    .join(\"text\")\n    .attr(\"font-size\", 20)  // Define o tamanho da fonte do texto\n    .attr(\"x\", width - marginRight)  // Posiciona o texto √† direita\n    .attr(\"y\", ([, values]) =&gt; y(+values[values.length - 1].Total))  // Posiciona o texto na √∫ltima coordenada da linha\n    .attr(\"dy\", \"0.35em\")  // Ajusta a posi√ß√£o vertical do texto\n    .attr(\"text-anchor\", \"start\")  // Alinha o texto √† esquerda\n    .attr(\"fill\", ([key]) =&gt; color(key))  // Define a cor do texto de acordo com a UF\n    .text(([key]) =&gt; key);  // Define o texto como o nome da UF\n  \n  // Adiciona os pontos no gr√°fico\n  svg.append(\"g\")\n    .selectAll(\"circle\")\n    .data(tabelaFiltrada)\n    .join(\"circle\")\n    .attr(\"cx\", d =&gt; x(+d.new_faixa))  // Posi√ß√£o horizontal baseada no ano\n    .attr(\"cy\", d =&gt; y(+d.Total))  // Posi√ß√£o vertical baseada no total\n    .attr(\"r\", 4)  // Define o raio do c√≠rculo\n    .attr(\"fill\", d =&gt; color(d.Fonte))  // Define a cor do ponto com base na UF\n    .attr(\"stroke\", \"white\")  // Adiciona uma borda branca ao ponto\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da borda\n    ;\n\n  // Cria√ß√£o do tooltip (caixa de informa√ß√£o ao passar o mouse)\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .style(\"position\", \"absolute\")  // Define a posi√ß√£o absoluta do tooltip\n    .style(\"background\", \"white\")  // Define o fundo branco do tooltip\n    .style(\"border\", \"1px solid #ccc\")  // Define a borda do tooltip\n    .style(\"padding\", \"5px\")  // Adiciona o espa√ßamento interno\n    .style(\"border-radius\", \"5px\")  // Define bordas arredondadas\n    .style(\"font-size\", \"12px\")  // Define o tamanho da fonte\n    .style(\"pointer-events\", \"none\")  // Impede a intera√ß√£o do tooltip com o gr√°fico\n    .style(\"opacity\", 0);  // Inicialmente o tooltip √© invis√≠vel\n\n  // Adiciona intera√ß√£o para mostrar o tooltip quando o mouse passa sobre a linha\n  paths.on(\"pointermove\", (event, [uf, values]) =&gt; {\n    // Encontra o ponto mais pr√≥ximo do mouse na linha\n    const [xm, ym] = d3.pointer(event);\n    const closest = d3.least(values, d =&gt; Math.hypot(x(+d.Ano) - xm, y(+d.Total) - ym));\n    \n    if (closest) {\n      const { Ano, Total } = closest;  // Obt√©m os dados do ponto mais pr√≥ximo\n\n      // Destaque da linha: reduz opacidade das outras e aumenta a espessura da linha ativa\n      paths.attr(\"stroke-opacity\", 0.2);  \n      d3.select(event.target).attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 2.5);\n\n      // Atualiza o tooltip com os dados do ponto mais pr√≥ximo\n      tooltip.style(\"opacity\", 1)\n        .html(`Fonte: ${uf}&lt;br&gt;Ano: ${Ano}&lt;br&gt;Total: ${Total}`)\n        .style(\"left\", `${event.pageX + 10}px`)  // Posiciona o tooltip ao lado do mouse\n        .style(\"top\", `${event.pageY + 10}px`);  // Posiciona o tooltip acima do mouse\n    }\n  });\n\n  // Esconde o tooltip e restaura a opacidade das linhas quando o mouse sai\n  paths.on(\"pointerleave\", () =&gt; {\n    paths.attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 1.5);  // Restaura a opacidade e espessura das linhas\n    tooltip.style(\"opacity\", 0);  // Oculta o tooltip\n  });\n\n  return svg.node();  // Retorna o elemento SVG para ser exibido\n}};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.table(tabelaFiltrada)\n\n\n\n\n\n\n\nhtml`\n&lt;body&gt;\n    &lt;a href=\"comp_pop.csv\" download&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ‚¨áÔ∏è Baixar CSV completo\n        &lt;/button&gt;\n    &lt;/a&gt;\n    &lt;a download=\"tabelaFiltrada.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\"&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ‚¨áÔ∏è Baixar CSV filtrado\n        &lt;/button&gt;\n&lt;/a&gt;\n&lt;/body&gt;\n`"
  },
  {
    "objectID": "graficos.html#mortalidade-por-faixa-et√°ria",
    "href": "graficos.html#mortalidade-por-faixa-et√°ria",
    "title": "Gr√°ficos",
    "section": "Mortalidade por faixa-et√°ria",
    "text": "Mortalidade por faixa-et√°ria\nO gr√°fico representa a mortalidade ao longo do tempo por na√ß√£o, regi√µes, estado e distrito federal, podendo selecionar faixa et√°ria no qual deseja ver a sua evolu√ß√£o ao longo do tempo (2000 - 2023).\n\nPLotData\n\n\n\nmortalidade = FileAttachment(\"mortalidade1.csv\").csv()\nmortalidade_filtrada = mortalidade\n    .filter(d =&gt; d.idade === faixa_etaria_mortalidade &&\n                 (estados_mortalidade.includes(\"Todos estados\") || estados_mortalidade.includes(d.UF))\n    )\n    .map(d =&gt; ({\n        Ano: d.Ano,\n        UF: d.UF,\n        Total: d.Total\n    }));\n\nviewof faixa_etaria_mortalidade = Inputs.select(\n    ['Menos de 1 ano', '1 a 4 anos', '5 a 9 anos', '10 a 14 anos', '15 a 19 anos', '20 a 24 anos', '25 a 29 anos', '30 a 34 anos', '35 a 39 anos', '40 a 44 anos', '45 a 49 anos', '50 a 54 anos', '55 a 59 anos', '60 a 64 anos', '65 a 69 anos', '70 a 74 anos', '75 a 79 anos', '80 anos ou mais'],\n    {\n        value: ['Menos de 1 ano'],\n        label: \"Faixa et√°ria: \"\n    }\n)\nviewof estados_mortalidade = Inputs.checkbox(\n  [\n    \"AC\", \"AL\", \"AM\", \"AP\", \"BA\", \"CE\", \"DF\", \"ES\", \"GO\", \"MA\", \n    \"MT\", \"MS\", \"MG\", \"PA\", \"PB\", \"PE\", \"PI\", \"PR\", \"RJ\", \"RN\", \n    \"RO\", \"RR\", \"RS\", \"SC\", \"SE\", \"SP\", \"TO\", \"Todos estados\"\n  ],\n  {\n    value: [\"Todos estados\"], // Define \"Todos estados\" como valor inicial selecionado\n    label: \"Local: \",\n    sort: true, // Ordena alfabeticamente\n    unique: true // Evita duplicatas\n  }\n)\n\n\n// Gr√°fico\nchart1 = {{\n  // Defini√ß√£o das dimens√µes do gr√°fico\n  const width = 928;  // Largura do gr√°fico\n  const height = 600; // Altura do gr√°fico\n  const marginTop = 20;    // Margem superior\n  const marginRight = 20;  // Margem direita\n  const marginBottom = 30; // Margem inferior\n  const marginLeft = 50;   // Margem esquerda\n\n  // Escala para o eixo X (Ano)\n  const x = d3.scaleLinear()\n    .domain(d3.extent(mortalidade_filtrada, d =&gt; +d.Ano))  // Determina o intervalo de valores para o eixo X com base no ano\n    .range([marginLeft, width - marginRight]);  // Define o intervalo de pixels no eixo X\n\n  // Escala para o eixo Y (Total)\n  const y = d3.scaleLinear()\n    .domain([d3.min(mortalidade_filtrada, d =&gt; +d.Total), d3.max(mortalidade_filtrada, d =&gt; +d.Total)]).nice()  // Define o intervalo de valores para o eixo Y com base no total\n    .range([height - marginBottom, marginTop]);  // Define o intervalo de pixels no eixo Y\n\n  // Defini√ß√£o de cores para as linhas\n  const color = d3.scaleOrdinal(d3.schemeCategory10);  // Usa uma paleta de cores pr√©-definida do D3\n\n  // Cria√ß√£o do elemento SVG para o gr√°fico\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)  // Define a largura do SVG\n    .attr(\"height\", height)  // Define a altura do SVG\n    .attr(\"viewBox\", [0, 0, width, height])  // Define a visualiza√ß√£o do SVG com base nas dimens√µes\n    .style(\"max-width\", \"100%\")  // Estilo para garantir que o gr√°fico seja responsivo\n    .style(\"height\", \"auto\")  // Estilo para ajustar a altura automaticamente\n    .style(\"overflow\", \"visible\")  // Permite que os elementos do gr√°fico saiam do limite do SVG\n    .style(\"font\", \"10px sans-serif\");  // Define o estilo da fonte no gr√°fico\n\n  // Adiciona o eixo X (ano)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - marginBottom})`)  // Posiciona o eixo X na parte inferior\n    .call(d3.axisBottom(x).tickFormat(d3.format(\"d\")));  // Aplica a escala X e formata os ticks como n√∫meros inteiros\n\n  // Adiciona o eixo Y (total)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${marginLeft},0)`)  // Posiciona o eixo Y √† esquerda\n    .call(d3.axisLeft(y))  // Aplica a escala Y\n    .call(g =&gt; g.select(\".domain\").remove())  // Remove a linha do eixo Y\n    .call(g =&gt; g.append(\"text\")  // Adiciona texto ao lado do eixo Y\n      .attr(\"x\", -marginLeft)  // Posiciona o texto √† esquerda do gr√°fico\n      .attr(\"y\", 10)  // Posiciona o texto no eixo Y\n      .attr(\"fill\", \"currentColor\")  // Define a cor do texto\n      .attr(\"text-anchor\", \"start\")  // Define o alinhamento do texto\n      .text(\"‚Üë Total (%)\"));  // Texto do eixo Y\n\n  // Agrupa os dados pela coluna UF (Unidade Federativa)\n  const groupedData = d3.group(mortalidade_filtrada, d =&gt; d.UF);\n\n  // Define a fun√ß√£o para desenhar as linhas no gr√°fico\n  const line = d3.line()\n    .x(d =&gt; x(+d.Ano))  // Define a posi√ß√£o X da linha com base no ano\n    .y(d =&gt; y(+d.Total));  // Define a posi√ß√£o Y da linha com base no total\n\n  // Adiciona as linhas para cada grupo de dados\n  const paths = svg.append(\"g\")\n    .selectAll(\"path\")  // Seleciona todos os elementos \"path\" (caminhos das linhas)\n    .data(groupedData)  // Vincula os dados agrupados (por UF)\n    .join(\"path\")  // Cria um novo \"path\" para cada grupo de dados\n    .attr(\"fill\", \"none\")  // Define que as linhas n√£o ter√£o preenchimento\n    .attr(\"stroke\", ([key]) =&gt; color(key))  // Define a cor da linha de acordo com a UF\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da linha\n    .attr(\"d\", ([, values]) =&gt; line(values));  // Desenha a linha para cada conjunto de dados\n\n  // Adiciona o texto com o nome da UF na extremidade de cada linha\n  svg.append(\"g\")\n    .selectAll(\"text\")\n    .data(groupedData)\n    .join(\"text\")\n    .attr(\"font-size\", 10)  // Define o tamanho da fonte do texto\n    .attr(\"x\", width - marginRight)  // Posiciona o texto √† direita\n    .attr(\"y\", ([, values]) =&gt; y(+values[values.length - 1].Total))  // Posiciona o texto na √∫ltima coordenada da linha\n    .attr(\"dy\", \"0.35em\")  // Ajusta a posi√ß√£o vertical do texto\n    .attr(\"text-anchor\", \"start\")  // Alinha o texto √† esquerda\n    .attr(\"fill\", ([key]) =&gt; color(key))  // Define a cor do texto de acordo com a UF\n    .text(([key]) =&gt; key);  // Define o texto como o nome da UF\n\n\n\n  // Cria√ß√£o do tooltip (caixa de informa√ß√£o ao passar o mouse)\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .style(\"position\", \"absolute\")  // Define a posi√ß√£o absoluta do tooltip\n    .style(\"background\", \"white\")  // Define o fundo branco do tooltip\n    .style(\"border\", \"1px solid #ccc\")  // Define a borda do tooltip\n    .style(\"padding\", \"5px\")  // Adiciona o espa√ßamento interno\n    .style(\"border-radius\", \"5px\")  // Define bordas arredondadas\n    .style(\"font-size\", \"12px\")  // Define o tamanho da fonte\n    .style(\"pointer-events\", \"none\")  // Impede a intera√ß√£o do tooltip com o gr√°fico\n    .style(\"opacity\", 0);  // Inicialmente o tooltip √© invis√≠vel\n\n  // Adiciona intera√ß√£o para mostrar o tooltip quando o mouse passa sobre a linha\n  paths.on(\"pointermove\", (event, [uf, values]) =&gt; {\n    // Encontra o ponto mais pr√≥ximo do mouse na linha\n    const [xm, ym] = d3.pointer(event);\n    const closest = d3.least(values, d =&gt; Math.hypot(x(+d.Ano) - xm, y(+d.Total) - ym));\n    \n    if (closest) {\n      const { Ano, Total } = closest;  // Obt√©m os dados do ponto mais pr√≥ximo\n\n      // Destaque da linha: reduz opacidade das outras e aumenta a espessura da linha ativa\n      paths.attr(\"stroke-opacity\", 0.2);  \n      d3.select(event.target).attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 2.5);\n\n      // Atualiza o tooltip com os dados do ponto mais pr√≥ximo\n      tooltip.style(\"opacity\", 1)\n        .html(`UF: ${uf}&lt;br&gt;Ano: ${Ano}&lt;br&gt;Total: ${Total}`)\n        .style(\"left\", `${event.pageX + 10}px`)  // Posiciona o tooltip ao lado do mouse\n        .style(\"top\", `${event.pageY + 10}px`);  // Posiciona o tooltip acima do mouse\n    }\n  });\n\n  // Esconde o tooltip e restaura a opacidade das linhas quando o mouse sai\n  paths.on(\"pointerleave\", () =&gt; {\n    paths.attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 1.5);  // Restaura a opacidade e espessura das linhas\n    tooltip.style(\"opacity\", 0);  // Oculta o tooltip\n  });\n\n  return svg.node();  // Retorna o elemento SVG para ser exibido\n}};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.table(tabelaFiltrada)\n\n\n\n\n\n\n\nfunction converterParaCSV(dados) {\n  const cabecalho = Object.keys(dados[0]).join(\",\")\n  const linhas = dados.map(obj =&gt; \n    Object.values(obj).map(v =&gt; \n      `\"${String(v).replace(/\"/g, '\"\"')}\"`\n    ).join(\",\")\n  )\n  return [cabecalho, ...linhas].join(\"\\n\")\n}\ncsv = converterParaCSV(mortalidade_filtrada)\nhtml`\n&lt;body&gt;\n    &lt;a href=\"mortalidade1.csv\" download&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ‚¨áÔ∏è Baixar CSV completo\n        &lt;/button&gt;\n    &lt;/a&gt;\n    &lt;a download=\"mortalidade_filtrada.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\"&gt;\n        &lt;button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\"&gt;\n          ‚¨áÔ∏è Baixar CSV filtrado\n        &lt;/button&gt;\n&lt;/a&gt;\n&lt;/body&gt;\n`"
  },
  {
    "objectID": "graficos.html#plot",
    "href": "graficos.html#plot",
    "title": "Gr√°ficos",
    "section": "PLot",
    "text": "PLot\n\nviewof ano5 = Inputs.range([2000, 2023],\n       {\n        value: [2000],\n        step: 1,\n        label: \"Ano: \"\n    }\n)\n\n// Carregar o GeoJSON dos estados brasileiros\ngeoData = await fetch(\"https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/brazil-states.geojson\")\n  .then(response =&gt; response.json())\n\n// Criar o mapa\nwidth = 800;\nheight = 600;\n\nchart3 = {\n  const svg = d3.create(\"svg\")\n    .attr(\"viewBox\", [0, 0, width, height])\n    .style(\"width\", \"100%\")\n    .style(\"height\", \"auto\");\n\n  // Configurar a proje√ß√£o\n  const projection = d3.geoMercator()\n    .center([-52, -15]) // Centralizar no Brasil\n    .scale(700)\n    .translate([width / 2, height / 2]);\n\n  const path = d3.geoPath().projection(projection);\n\n  // Criar escala de cores\n  const valores = stateData.map(d =&gt; d.valor);\n  const colorScale = d3.scaleSequential()\n    .domain([d3.min(valores), d3.max(valores)])\n    .interpolator(d3.interpolateBlues);\n\n  // Fun√ß√£o para normalizar nomes (remover acentos)\n  const normalizeName = name =&gt; name\n    ? name.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").toLowerCase()\n    : \"\";\n\n  // Criar mapa\n  svg.selectAll(\"path\")\n    .data(geoData.features)\n    .join(\"path\")\n    .attr(\"d\", path)\n    .attr(\"fill\", d =&gt; {\n      const state = stateData.find(s =&gt;\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n      return state ? colorScale(state.valor) : \"#ccc\";\n    })\n    .attr(\"stroke\", \"white\")\n    .attr(\"stroke-width\", 0.5);\n\n  // Adicionar tooltip\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .attr(\"class\", \"tooltip\")\n    .style(\"opacity\", 0)\n    .style(\"position\", \"absolute\")\n    .style(\"background-color\", \"white\")\n    .style(\"border\", \"solid\")\n    .style(\"border-width\", \"1px\")\n    .style(\"border-radius\", \"5px\")\n    .style(\"padding\", \"5px\");\n\n  svg.selectAll(\"path\")\n    .on(\"mouseover\", (event, d) =&gt; {\n      const state = stateData.find(s =&gt;\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", .9);\n\n      tooltip.html(`\n        Estado: ${d.properties.name}&lt;br/&gt;\n        Valor: ${state ? state.valor : 'Sem dados'}\n      `)\n        .style(\"left\", (event.pageX + 10) + \"px\")\n        .style(\"top\", (event.pageY - 28) + \"px\");\n    })\n    .on(\"mouseout\", () =&gt; {\n      tooltip.transition()\n        .duration(500)\n        .style(\"opacity\", 0);\n    });\n\n  // Adicionar barra de cores (legenda)\n  const legendWidth = 400;\n  const legendHeight = 20;\n\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${(width - legendWidth) / 2}, ${height - 25})`);\n\n  const gradient = legend.append(\"defs\")\n    .append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"y2\", \"0%\");\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"0%\")\n    .attr(\"stop-color\", colorScale(d3.min(valores)));\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"100%\")\n    .attr(\"stop-color\", colorScale(d3.max(valores)));\n\n  legend.append(\"rect\")\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Adicionar r√≥tulos na barra de cores\n  legend.append(\"text\")\n    .attr(\"x\", 0)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"start\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.min(valores)));\n\n  legend.append(\"text\")\n    .attr(\"x\", legendWidth)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"end\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.max(valores)));\n\n  return svg.node();\n}\n\n// Mostrar valores m√≠nimos e m√°ximos\n    minMaxValues = {\n    const valores = stateData.map(d =&gt; d.valor);\n    return {\n        min: d3.min(valores),\n        max: d3.max(valores)\n    };\n}"
  },
  {
    "objectID": "graficos.html#data",
    "href": "graficos.html#data",
    "title": "Gr√°ficos",
    "section": "Data",
    "text": "Data\n\nInputs.table(tabelaFiltrada2)\n\n\n\n\n\n\n:::"
  },
  {
    "objectID": "mortalidade.html",
    "href": "mortalidade.html",
    "title": "Dados de Mortalidade",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\ndata = await FileAttachment(\"dados/dados2/erros.csv\").csv()\ntabua_comb = await FileAttachment(\"dados/dados1/previsoes_combinado.csv\").csv()\n\ndata_filter = data.filter(\n    d =&gt; d.faixa_etaria === '0' && d.regiao === 'Brasil' && d.taxa === 'Total'\n)\n\n\nhtml`\n&lt;p style=\"text-align: justify;\"&gt;Aqui, voc√™ encontrar√° um conjunto de dados detalhados sobre mortalidade dividido entre: Brasil, Regi√µes e Estados, combinando informa√ß√µes reais extra√≠das do Instituto Brasileiro de Geografia e Estat√≠stica (IBGE) com proje√ß√µes e an√°lises desenvolvidas por nossa equipe.&lt;/p&gt;\n&lt;p style=\"text-align: justify;\"&gt;Nosso objetivo √© oferecer uma vis√£o clara e acess√≠vel sobre a evolu√ß√£o dos padr√µes de mortalidade, permitindo compara√ß√µes entre os dados hist√≥ricos e nossas estimativas futuras. Utilizamos modelos estat√≠sticos e atuariais para gerar previs√µes que podem ser aplicadas em diversas √°reas, como seguros, previd√™ncia, sa√∫de p√∫blica e planejamento estrat√©gico.&lt;/p&gt;\n&lt;p style=\"text-align: justify;\"&gt;Explore nossos gr√°ficos interativos e relat√≥rios para entender melhor as tend√™ncias e impactos da longevidade no Brasil.&lt;/p&gt;\n`"
  },
  {
    "objectID": "mortalidade.html#gr√°ficos",
    "href": "mortalidade.html#gr√°ficos",
    "title": "Mortalidade",
    "section": "Gr√°ficos",
    "text": "Gr√°ficos\n\n{\n  const width = 1000;\n  const height = 800;\n  const margin = { top: 20, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cria√ß√£o do SVG principal\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  // Calcula dimens√µes dos subplots\n  const subplotWidth = (width - margin.left - margin.right) / numCols;\n  const subplotHeight = (height - margin.top - margin.bottom) / numRows;\n\n  // Cria√ß√£o dos subplots\n  for (let row = 0; row &lt; numRows; row++) {\n    for (let col = 0; col &lt; numCols; col++) {\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left + col * subplotWidth}, \n                                      ${margin.top + row * subplotHeight})`);\n      \n      // Adicione elementos gr√°ficos aqui\n      // Exemplo de ret√¢ngulo de fundo\n      subplot.append(\"rect\")\n        .attr(\"width\", subplotWidth - 10)\n        .attr(\"height\", subplotHeight - 10)\n        .attr(\"fill\", \"#f0f0f0\");\n\n      // Exemplo de gr√°fico de barras (adaptar para seus dados)\n      subplot.selectAll(\"rect.bar\")\n        .data([1, 2, 3, 4, 5]) // Dados de exemplo\n        .join(\"rect\")\n          .attr(\"class\", \"bar\")\n          .attr(\"x\", 5)\n          .attr(\"y\", 20)\n          .attr(\"width\", 10)\n          .attr(\"height\", 30)\n          .attr(\"fill\", \"steelblue\");\n\n      // Adicione eixos\n      const xScale = d3.scaleLinear()\n        .domain([0, 5])\n        .range([0, subplotWidth - margin.left - margin.right]);\n\n      const yScale = d3.scaleLinear()\n        .domain([0, 5])\n        .range([subplotHeight - margin.bottom, margin.top]);\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale));\n\n      subplot.append(\"g\")\n        .call(d3.axisLeft(yScale));\n    }\n  }\n\n  return svg.node();\n}\n\n\n\n\n\n\n\n{\n  const width = 1200;\n  const height = 1000;\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 4;\n  const numCols = 5;\n  \n  // Cria√ß√£o do SVG principal\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  // Extrai faixas et√°rias √∫nicas e ordena\n  const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n  \n  // Calcula dimens√µes dos subplots\n  const subplotWidth = width / numCols;\n  const subplotHeight = height / numRows;\n\n  // Cria√ß√£o dos subplots\n  for (let row = 0; row &lt; numRows; row++) {\n    for (let col = 0; col &lt; numCols; col++) {\n      const index = row * numCols + col;\n      if (index &gt;= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n      \n      // Filtra dados para a faixa et√°ria atual\n      const filteredData = data.filter(d =&gt; \n        d.faixa_etaria === currentAge && \n        d.regiao === 'Brasil' && \n        d.taxa === 'Total'\n      ).map(d =&gt; ({\n        ...d,\n        ano: +d.ano,\n        mx_real: +d.mx_real\n      }));\n      \n      // Configura escalas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d =&gt; d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n      \n      const yScale = d3.scaleLinear()\n        .domain([0, d3.max(filteredData, d =&gt; d.mx_real)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Adiciona eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5));\n      \n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5));\n      \n      // Adiciona linha\n      const line = d3.line()\n        .x(d =&gt; xScale(d.ano))\n        .y(d =&gt; yScale(d.mx_real));\n      \n      subplot.append(\"path\")\n        .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n        .attr(\"d\", line)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"steelblue\")\n        .attr(\"stroke-width\", 2);\n      \n      // Adiciona t√≠tulo\n      subplot.append(\"text\")\n        .attr(\"x\", margin.left)\n        .attr(\"y\", margin.top)\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n\n  return svg.node();\n}"
  },
  {
    "objectID": "mortalidade.html#taxa-central-de-mortalidade",
    "href": "mortalidade.html#taxa-central-de-mortalidade",
    "title": "Dados de Mortalidade",
    "section": "Taxa Central de Mortalidade",
    "text": "Taxa Central de Mortalidade\n\n{\n  const width = 800;\n  const height = 650;\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cria√ß√£o do SVG principal\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  // Extrai faixas et√°rias √∫nicas e ordena\n  const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n  \n  // Calcula dimens√µes dos subplots\n  const subplotWidth = width / numCols;\n  const subplotHeight = height / numRows;\n\n  // Cria√ß√£o dos subplots\n  for (let row = 0; row &lt; numRows; row++) {\n    for (let col = 0; col &lt; numCols; col++) {\n      const index = row * numCols + col;\n      if (index &gt;= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n      \n      // Filtra dados para a faixa et√°ria atual\n      const filteredData = data.filter(d =&gt; \n        d.faixa_etaria === currentAge && \n        d.regiao === 'Brasil' && \n        d.taxa === 'Total'\n      ).map(d =&gt; ({\n        ...d,\n        ano: +d.ano,\n        mx_real: Math.log(+d.mx_real)\n      }));\n      \n      // Configura escalas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d =&gt; d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n      \n      const yScale = d3.scaleLinear()\n        .domain([d3.min(filteredData, d =&gt; d.mx_real), d3.max(filteredData, d =&gt; d.mx_real)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Adiciona eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5));\n      \n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5));\n      \n      // Adiciona linha\n      const line = d3.line()\n        .x(d =&gt; xScale(d.ano))\n        .y(d =&gt; yScale(d.mx_real));\n      \n      subplot.append(\"path\")\n        .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n        .attr(\"d\", line)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"steelblue\")\n        .attr(\"stroke-width\", 2);\n      \n      // Adiciona t√≠tulo\n      subplot.append(\"text\")\n        .attr(\"x\", margin.left)\n        .attr(\"y\", margin.top)\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\", \"center\");\n    }\n  }\n\n  return svg.node();\n}"
  },
  {
    "objectID": "mortalidade.html#taxa-central-de-mortalidade-2000-√†-2023",
    "href": "mortalidade.html#taxa-central-de-mortalidade-2000-√†-2023",
    "title": "Dados de Mortalidade",
    "section": "Taxa Central de Mortalidade 2000 √† 2023",
    "text": "Taxa Central de Mortalidade 2000 √† 2023\n\nviewof qual = Inputs.checkbox(['Lee-Carter', 'Lee-Miler', 'Dados real'], {value: ['Lee-Miler', 'Lee-Carter', 'Dados real'], label: 'Modelos:'}) \n\nviewof regiao = Inputs.select([\n  \"Brasil\",\n  \"Norte\",\n  \"Nordeste\",\n  \"Centro-Oeste\",\n  \"Sudeste\",\n  \"Sul\",\n  \"Acre\",\n  \"Alagoas\",\n  \"Amap√°\",\n  \"Amazonas\",\n  \"Bahia\",\n  \"Cear√°\",\n  \"Distrito Federal\",\n  \"Esp√≠rito Santo\",\n  \"Goi√°s\",\n  \"Maranh√£o\",\n  \"Mato Grosso\",\n  \"Mato Grosso do Sul\",\n  \"Minas Gerais\",\n  \"Par√°\",\n  \"Para√≠ba\",\n  \"Paran√°\",\n  \"Pernambuco\",\n  \"Piau√≠\",\n  \"Rio de Janeiro\",\n  \"Rio Grande do Norte\",\n  \"Rio Grande do Sul\",\n  \"Rond√¥nia\",\n  \"Roraima\",\n  \"Santa Catarina\",\n  \"S√£o Paulo\",\n  \"Sergipe\",\n  \"Tocantins\"],\n  {\n        value: ['Brasil'],\n        label: \"Local: \"\n    })\n\nhtml`\n&lt;div class=\"grafico-container\"&gt;\n  &lt;!-- Legenda HTML --&gt;\n  &lt;div class=\"legenda\"&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: steelblue\"&gt;&lt;/div&gt;\n      &lt;span&gt;Real&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: darkorange\"&gt;&lt;/div&gt;\n      &lt;span&gt;Modelo LC&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: green\"&gt;&lt;/div&gt;\n      &lt;span&gt;Modelo LM&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n\n  &lt;!-- Container do gr√°fico SVG ser√° injetado aqui --&gt;\n  &lt;div id=\"grafico\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n.grafico-container {\n  max-width: 800px;\n  margin: 0 auto;\n  font-family: sans-serif;\n}\n\n.legenda {\n  display: flex;\n  gap: 1.5rem;\n  justify-content: center;\n  margin-bottom: 1.5rem;\n}\n\n.legenda-item {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.25rem 0.75rem;\n  background: #f5f5f5;\n  border-radius: 1rem;\n}\n\n.cor-marcador {\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n}\n\n&lt;/style&gt;\n`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction lm_lc(){\n  //lm e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada s√©rie\n    const cores = {\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transforma√ß√£o\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transforma√ß√£o\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [ d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Fun√ß√£o para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as tr√™s linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // T√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lm(){\n  //real e lm\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada s√©rie\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transforma√ß√£o\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Fun√ß√£o para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as tr√™s linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // T√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lc(){\n  //real e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada s√©rie\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transforma√ß√£o\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lc]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Fun√ß√£o para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as tr√™s linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        \n        // T√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n\n\nfunction todos(){\n  //todos\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada s√©rie\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transforma√ß√£o\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transforma√ß√£o\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Fun√ß√£o para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as tr√™s linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // T√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n//real\nfunction real(){\n  {\n    const width = 800;\n    const height = 750;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cria√ß√£o do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas et√°rias √∫nicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimens√µes dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Cria√ß√£o dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa et√°ria atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_real), d3.max(filteredData, d =&gt; d.mx_real)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_real));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"steelblue\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona t√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lm\nfunction mx_lm(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cria√ß√£o do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas et√°rias √∫nicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimens√µes dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Cria√ß√£o dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa et√°ria atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_lm), d3.max(filteredData, d =&gt; d.mx_lm)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_lm));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"green\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona t√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lc\nfunction mx_lc(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cria√ß√£o do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas et√°rias √∫nicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimens√µes dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Cria√ß√£o dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa et√°ria atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_lc), d3.max(filteredData, d =&gt; d.mx_lc)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_lc));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"darkorange\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona t√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Dados real\")\nlm = qual.includes(\"Lee-Miler\")\nlc = qual.includes(\"Lee-Carter\")\n\n{\n  if(totalSelecionado === 1 ){\n    if (rea) return real();\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  }else if (totalSelecionado === 3){\n    return todos()\n  }else if (totalSelecionado === 2){\n    if (rea && lm) return real_lm();\n    if (rea && lc) return real_lc();\n    if (lm && lc) return lm_lc();\n  }else if (totalSelecionado == 0){\n    return html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncleo = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\n//faixaeta = Array.from(d3.group(cleo, d =&gt; d.faixa_etaria).keys());\nviewof faixa_etaria = Inputs.select(Array.from(d3.group(cleo, d =&gt; d.faixa_etaria).keys()))\ndata_filter2 = cleo.filter(\n    d =&gt; d.faixa_etaria === faixa_etaria && d.Local === 'Brasil' && d.Sexo === 'Ambos'\n).map(\n  d =&gt; ({\n    ano: d.Ano,\n    prev: Math.log(d.nMx_previs√£o)\n  }))\n\nviewof ano = Inputs.select(Array.from(d3.group(cleo, d =&gt; d.Ano).keys()))\ndata_filter1 = cleo.filter(\n    d =&gt; d.Ano === ano && d.Local === 'Brasil' && d.Sexo === 'Ambos'\n).map(\n  d =&gt; ({\n    faixa: d.faixa_etaria,\n    prev: Math.log(d.nMx_previs√£o)\n  }))\nInputs.table(data_filter1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n  // Declare the chart dimensions and margins.\n  const width = 800;\n  const height = 650;\n  const marginTop = 30;\n  const marginRight = 20;\n  const marginBottom = 40;\n  const marginLeft = 50;\n\n  // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n  const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n  \n  // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n  const x = d3.scalePoint()\n      .domain(faixaValues)\n      .range([marginLeft, width - marginRight])\n      .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n  // Declare the y (vertical position) scale.\n  const y = d3.scaleLinear()\n      .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n      .range([height - marginBottom, marginTop]);\n\n  // Declare the line generator.\n  const line = d3.line()\n      .x(d =&gt; x(d.faixa))\n      .y(d =&gt; y(d.prev));\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  // Add the x-axis.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x))\n      .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n      .style(\"text-anchor\", \"end\")\n      .attr(\"dx\", \"-.8em\")\n      .attr(\"dy\", \".15em\")\n      .attr(\"transform\", \"rotate(-45)\");\n\n  // Add the y-axis, remove the domain line, add grid lines and a label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).ticks(height / 40))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.selectAll(\".tick line\").clone()\n          .attr(\"x2\", width - marginLeft - marginRight)\n          .attr(\"stroke-opacity\", 0.1))\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"‚Üë Preval√™ncia\"));\n\n  // Append a path for the line.\n  svg.append(\"path\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"steelblue\")\n      .attr(\"stroke-width\", 1.5)\n      .attr(\"d\", line(data_filter1));\n\n  return svg.node();\n}"
  },
  {
    "objectID": "mortalidade.html#testando",
    "href": "mortalidade.html#testando",
    "title": "Dados de Mortalidade",
    "section": "testando",
    "text": "testando\n\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Dados real\")\nlm = qual.includes(\"Lee-Miler\")\nlc = qual.includes(\"Lee-Carter\")\n\n{\n  if(totalSelecionado === 1 ){\n    if (rea) return real();\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  }else if (totalSelecionado === 3){\n    return todos()\n  }else if (totalSelecionado === 2){\n    if (rea && lm) return real_lm();\n    if (rea && lc) return real_lc();\n    if (lm && lc) return \"lm lc\";\n  }\n\n}"
  },
  {
    "objectID": "mortalidade.html#taxa-central-de-mortalidade-de-2000-√†-2023-para-os-modelos-de-lee-miler-e-lee-carter",
    "href": "mortalidade.html#taxa-central-de-mortalidade-de-2000-√†-2023-para-os-modelos-de-lee-miler-e-lee-carter",
    "title": "Dados de Mortalidade",
    "section": "Taxa central de mortalidade de 2000 √† 2023 para os modelos de Lee-Miler e Lee-Carter",
    "text": "Taxa central de mortalidade de 2000 √† 2023 para os modelos de Lee-Miler e Lee-Carter\n\nviewof qual = Inputs.checkbox(['Lee-Carter', 'Lee-Miler', 'Observado'], {value: ['Lee-Miler', 'Lee-Carter', 'Observado'], label: 'Modelos:'}) \n\nviewof regiao = Inputs.select([\n  \"Brasil\",\n  \"Norte\",\n  \"Nordeste\",\n  \"Centro-Oeste\",\n  \"Sudeste\",\n  \"Sul\",\n  \"Acre\",\n  \"Alagoas\",\n  \"Amap√°\",\n  \"Amazonas\",\n  \"Bahia\",\n  \"Cear√°\",\n  \"Distrito Federal\",\n  \"Esp√≠rito Santo\",\n  \"Goi√°s\",\n  \"Maranh√£o\",\n  \"Mato Grosso\",\n  \"Mato Grosso do Sul\",\n  \"Minas Gerais\",\n  \"Par√°\",\n  \"Para√≠ba\",\n  \"Paran√°\",\n  \"Pernambuco\",\n  \"Piau√≠\",\n  \"Rio de Janeiro\",\n  \"Rio Grande do Norte\",\n  \"Rio Grande do Sul\",\n  \"Rond√¥nia\",\n  \"Roraima\",\n  \"Santa Catarina\",\n  \"S√£o Paulo\",\n  \"Sergipe\",\n  \"Tocantins\"],\n  {\n        value: ['Brasil'],\n        label: \"Local: \"\n    })\n\nhtml`\n&lt;div class=\"grafico-container\"&gt;\n  &lt;!-- Legenda HTML --&gt;\n  &lt;div class=\"legenda\"&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: steelblue\"&gt;&lt;/div&gt;\n      &lt;span&gt;Observado&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: darkorange\"&gt;&lt;/div&gt;\n      &lt;span&gt;Modelo LC&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=\"legenda-item\"&gt;\n      &lt;div class=\"cor-marcador\" style=\"background: green\"&gt;&lt;/div&gt;\n      &lt;span&gt;Modelo LM&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n\n  &lt;!-- Container do gr√°fico SVG ser√° injetado aqui --&gt;\n  &lt;div id=\"grafico\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n.grafico-container {\n  max-width: 800px;\n  margin: 0 auto;\n  font-family: sans-serif;\n}\n\n.legenda {\n  display: flex;\n  gap: 1.5rem;\n  justify-content: center;\n  margin-bottom: 1.5rem;\n}\n\n.legenda-item {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.25rem 0.75rem;\n  background: #f5f5f5;\n  border-radius: 1rem;\n}\n\n.cor-marcador {\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n}\n\n&lt;/style&gt;\n`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction lm_lc(){\n  //lm e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada s√©rie\n    const cores = {\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transforma√ß√£o\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transforma√ß√£o\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [ d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Fun√ß√£o para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as tr√™s linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // T√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lm(){\n  //real e lm\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada s√©rie\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transforma√ß√£o\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Fun√ß√£o para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as tr√™s linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // T√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lc(){\n  //real e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada s√©rie\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transforma√ß√£o\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lc]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Fun√ß√£o para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as tr√™s linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        \n        // T√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n\n\nfunction todos(){\n  //todos\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada s√©rie\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transforma√ß√£o\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transforma√ß√£o\n        })).sort((a, b) =&gt; a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d =&gt; [d.mx_real, d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Fun√ß√£o para gerar linhas\n        const gerarLinha = (variavel, cor) =&gt; {\n          const linha = d3.line()\n            .x(d =&gt; xScale(d.ano))\n            .y(d =&gt; yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as tr√™s linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // T√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n//real\nfunction real(){\n  {\n    const width = 800;\n    const height = 750;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cria√ß√£o do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas et√°rias √∫nicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimens√µes dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Cria√ß√£o dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa et√°ria atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_real), d3.max(filteredData, d =&gt; d.mx_real)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_real));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"steelblue\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona t√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lm\nfunction mx_lm(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cria√ß√£o do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas et√°rias √∫nicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimens√µes dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Cria√ß√£o dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa et√°ria atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_lm), d3.max(filteredData, d =&gt; d.mx_lm)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_lm));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"green\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona t√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lc\nfunction mx_lc(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cria√ß√£o do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas et√°rias √∫nicas e ordena\n    const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n    \n    // Calcula dimens√µes dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Cria√ß√£o dos subplots\n    for (let row = 0; row &lt; numRows; row++) {\n      for (let col = 0; col &lt; numCols; col++) {\n        const index = row * numCols + col;\n        if (index &gt;= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa et√°ria atual\n        const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d =&gt; d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d =&gt; d.mx_lc), d3.max(filteredData, d =&gt; d.mx_lc)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d.mx_lc));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) =&gt; a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"darkorange\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona t√≠tulo\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Observado\")\nlm = qual.includes(\"Lee-Miler\")\nlc = qual.includes(\"Lee-Carter\")\n\n{\n  if(totalSelecionado === 1 ){\n    if (rea) return real();\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  }else if (totalSelecionado === 3){\n    return todos()\n  }else if (totalSelecionado === 2){\n    if (rea && lm) return real_lm();\n    if (rea && lc) return real_lc();\n    if (lm && lc) return lm_lc();\n  }else if (totalSelecionado == 0){\n    return html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n  }\n\n}"
  },
  {
    "objectID": "mortalidade.html#proje√ß√£o-da-taxa-central-de-mortalidade-de-2024-√†-2070-para-o-modelo-combinado-arima-ets-ponderado",
    "href": "mortalidade.html#proje√ß√£o-da-taxa-central-de-mortalidade-de-2024-√†-2070-para-o-modelo-combinado-arima-ets-ponderado",
    "title": "Dados de Mortalidade",
    "section": "Proje√ß√£o da taxa central de mortalidade de 2024 √† 2070 para o modelo combinado (ARIMA + ETS Ponderado)",
    "text": "Proje√ß√£o da taxa central de mortalidade de 2024 √† 2070 para o modelo combinado (ARIMA + ETS Ponderado)\n\ncleo = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\nviewof sexo = Inputs.radio([\"Ambos\", \"Homens\", \"Mulheres\"], {label: \"Sexo\", value: \"Ambos\"})\n\ndata_filter1 = cleo.filter(\n    d =&gt; d.Local === 'ParaiÃÅba' && d.Sexo === sexo\n).map(\n  d =&gt; ({\n    ano: +d.Ano,\n    faixa: d.faixa_etaria,\n    prev: Math.log(d.nMx_previs√£o)\n  }))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n  // Declare the chart dimensions and margins.\n  const width = 800;\n  const height = 650;\n  const marginTop = 30;\n  const marginRight = 20;\n  const marginBottom = 40;\n  const marginLeft = 50;\n\n  // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n  const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n  \n  // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n  const x = d3.scalePoint()\n      .domain(faixaValues)\n      .range([marginLeft, width - marginRight])\n      .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n  // Declare the y (vertical position) scale.\n  const y = d3.scaleLinear()\n      .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n      .range([height - marginBottom, marginTop]);\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  // Adicionar defini√ß√µes para gradientes\n  const defs = svg.append(\"defs\");\n\n  // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n  const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n  \n  // Mapeando os anos entre 2024 e 2070 para cores\n  const colorScale = d3.scaleSequential()\n      .domain([2024, 2070])\n      .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n  // Adicionar um gradiente para cada linha\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const gradientId = `line-gradient-${year}`;\n\n    // Criar gradiente linear\n    const gradient = defs.append(\"linearGradient\")\n        .attr(\"id\", gradientId)\n        .attr(\"gradientUnits\", \"userSpaceOnUse\")\n        .attr(\"x1\", marginLeft)\n        .attr(\"y1\", 0)\n        .attr(\"x2\", width - marginRight)\n        .attr(\"y2\", 0);\n\n    // Adicionar paradas de cor para o gradiente\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"0%\")\n        .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"100%\")\n        .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n  });\n\n  // Add the x-axis.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x))\n      .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n      .style(\"text-anchor\", \"end\")\n      .attr(\"dx\", \"-.8em\")\n      .attr(\"dy\", \".15em\")\n      .attr(\"transform\", \"rotate(-45)\");\n\n  // Add the y-axis, remove the domain line, add grid lines and a label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).ticks(height / 40))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.selectAll(\".tick line\").clone()\n          .attr(\"x2\", width - marginLeft - marginRight)\n          .attr(\"stroke-opacity\", 0.1))\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Log Previs√£o\"));\n\n  // Declare the line generator.\n  const line = d3.line()\n      .x(d =&gt; x(d.faixa))\n      .y(d =&gt; y(d.prev));\n\n  // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const values = yearGroup[1];\n\n    // Desenhar a linha com gradiente\n    svg.append(\"path\")\n        .datum(values)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n        .attr(\"stroke-width\", 2.5)\n        .attr(\"d\", line);\n  });\n\n  // Adicionar legenda para os anos\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - marginRight - legendWidth;\n  const legendY = marginTop;\n\n  // Legenda de gradiente horizontal\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  // Adicionar paradas de cor para a legenda\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  // Ret√¢ngulo da legenda com gradiente\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Texto para a legenda\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  // R√≥tulos dos anos na legenda\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  return svg.node();\n}"
  },
  {
    "objectID": "modelos.html",
    "href": "modelos.html",
    "title": "Modelos",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\ndata = await FileAttachment(\"dados/dados2/erros.csv\").csv()\ntabua_comb = await FileAttachment(\"dados/dados1/previsoes_combinado.csv\").csv()\n\n\n\nhtml`\n&lt;p style=\"text-align: justify;\"&gt;Aqui, voc√™ encontrar√° um conjunto de dados detalhados sobre mortalidade dividido entre: Brasil, Regi√µes e Estados, combinando informa√ß√µes reais extra√≠das do Instituto Brasileiro de Geografia e Estat√≠stica (IBGE) com proje√ß√µes e an√°lises desenvolvidas por nossa equipe.&lt;/p&gt;\n&lt;p style=\"text-align: justify;\"&gt;Nosso objetivo √© oferecer uma vis√£o clara e acess√≠vel sobre a evolu√ß√£o dos padr√µes de mortalidade, permitindo compara√ß√µes entre os dados hist√≥ricos e nossas estimativas futuras. Utilizamos modelos estat√≠sticos e atuariais para gerar previs√µes que podem ser aplicadas em diversas √°reas, como seguros, previd√™ncia, sa√∫de p√∫blica e planejamento estrat√©gico.&lt;/p&gt;\n&lt;p style=\"text-align: justify;\"&gt;Explore nossos gr√°ficos interativos e relat√≥rios para entender melhor as tend√™ncias e impactos da longevidade no Brasil.&lt;/p&gt;\n`"
  },
  {
    "objectID": "modelos.html#proje√ß√£o-da-taxa-central-de-mortalidade-de-2024-√†-2070-para-o-modelo-combinado-arima-ets-ponderado",
    "href": "modelos.html#proje√ß√£o-da-taxa-central-de-mortalidade-de-2024-√†-2070-para-o-modelo-combinado-arima-ets-ponderado",
    "title": "Modelos",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\nprev_comb = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\nviewof sexo = Inputs.radio([\"Ambos\", \"Homens\", \"Mulheres\"], {label: \"Sexo\", value: \"Homens\"})\n\n\n\nprev_lm = await FileAttachment('dados/dados2/tabuas_lc.csv').csv() \nprev_lc = await FileAttachment('dados/dados2/tabuas_lm.csv').csv()\n\ndata_filter1 = prev_comb.filter(\n    d =&gt; d.Local === 'Brasil' && d.Sexo === sexo\n).map(\n  d =&gt; ({\n    ano: +d.Ano,\n    faixa: d.faixa_etaria,\n    prev: Math.log(d.nMx_previs√£o)\n  }))\n\ndata_filter2 = prev_lm.filter(\n    d =&gt; d.local === 'Brasil' && d.sexo === sexo\n).map(\n  d =&gt; ({\n    ano: +d.ano,\n    faixa: d.faixa_etaria,\n    prev: Math.log(d.mx_previsto)\n  }))\n\ndata_filter3 = prev_lc.filter(\n    d =&gt; d.local === 'Brasil' && d.sexo === sexo\n).map(\n  d =&gt; ({\n    ano: +d.ano,\n    faixa: d.faixa_etaria,\n    prev: Math.log(d.mx_previsto)\n  }))\n\n\nviewof qual = Inputs.checkbox(['Lee-Carter', 'Lee-Miler', 'Combinado'], {value: ['Combinado'], label: 'Modelos:'})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//combinado\nfunction combinado(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n\n\n\n\n\n\n//lm\nfunction mx_lm(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter2.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter2, d =&gt; d.prev), d3.max(data_filter2, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter2, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n\n\n\n\n\n\nfunction mx_lc(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter3.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter3, d =&gt; d.prev), d3.max(data_filter3, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter3, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n//comb_lm\nfunction comb_lm(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n  //divsoria\n  html`&lt;h2&gt;div&lt;/h2&gt;`\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter2.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter2, d =&gt; d.prev), d3.max(data_filter2, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter2, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n//comb_lc\nfunction comb_lc(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n  html`&lt;h2&gt;div&lt;/h2&gt;`\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter3.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter3, d =&gt; d.prev), d3.max(data_filter3, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter3, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n\n//lm lc\nfunction lm_lc(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter2.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter2, d =&gt; d.prev), d3.max(data_filter2, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter2, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n  html`&lt;h2&gt;div&lt;/h2&gt;`\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter3.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter3, d =&gt; d.prev), d3.max(data_filter3, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter3, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n//comb_lm lc\nfunction todos(){\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n  \n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter2.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter2, d =&gt; d.prev), d3.max(data_filter2, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter2, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n  html`&lt;h2&gt;div&lt;/h2&gt;`\n  {\n    // Declare the chart dimensions and margins.\n    const width = 800;\n    const height = 650;\n    const marginTop = 30;\n    const marginRight = 20;\n    const marginBottom = 40;\n    const marginLeft = 50;\n\n    // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n    const faixaValues = [...new Set(data_filter3.map(d =&gt; d.faixa))];\n    \n    // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n    const x = d3.scalePoint()\n        .domain(faixaValues)\n        .range([marginLeft, width - marginRight])\n        .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n    // Declare the y (vertical position) scale.\n    const y = d3.scaleLinear()\n        .domain([d3.min(data_filter3, d =&gt; d.prev), d3.max(data_filter3, d =&gt; d.prev)]).nice()\n        .range([height - marginBottom, marginTop]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"viewBox\", [0, 0, width, height])\n        .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    // Adicionar defini√ß√µes para gradientes\n    const defs = svg.append(\"defs\");\n\n    // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n    const nestedData = d3.groups(data_filter3, d =&gt; d.ano);\n    \n    // Mapeando os anos entre 2024 e 2070 para cores\n    const colorScale = d3.scaleSequential()\n        .domain([2024, 2070])\n        .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n    // Adicionar um gradiente para cada linha\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const gradientId = `line-gradient-${year}`;\n\n      // Criar gradiente linear\n      const gradient = defs.append(\"linearGradient\")\n          .attr(\"id\", gradientId)\n          .attr(\"gradientUnits\", \"userSpaceOnUse\")\n          .attr(\"x1\", marginLeft)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", width - marginRight)\n          .attr(\"y2\", 0);\n\n      // Adicionar paradas de cor para o gradiente\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", colorScale(year));\n\n      gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n    });\n\n    // Add the x-axis.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(0,${height - marginBottom})`)\n        .call(d3.axisBottom(x))\n        .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n        .style(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-.8em\")\n        .attr(\"dy\", \".15em\")\n        .attr(\"transform\", \"rotate(-45)\");\n\n    // Add the y-axis, remove the domain line, add grid lines and a label.\n    svg.append(\"g\")\n        .attr(\"transform\", `translate(${marginLeft},0)`)\n        .call(d3.axisLeft(y).ticks(height / 40))\n        .call(g =&gt; g.select(\".domain\").remove())\n        .call(g =&gt; g.selectAll(\".tick line\").clone()\n            .attr(\"x2\", width - marginLeft - marginRight)\n            .attr(\"stroke-opacity\", 0.1))\n        .call(g =&gt; g.append(\"text\")\n            .attr(\"x\", -marginLeft)\n            .attr(\"y\", 10)\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"text-anchor\", \"start\")\n            .text(\"Log Previs√£o\"));\n\n    // Declare the line generator.\n    const line = d3.line()\n        .x(d =&gt; x(d.faixa))\n        .y(d =&gt; y(d.prev));\n\n    // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n    nestedData.forEach((yearGroup, i) =&gt; {\n      const year = yearGroup[0];\n      const values = yearGroup[1];\n\n      // Desenhar a linha com gradiente\n      svg.append(\"path\")\n          .datum(values)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n          .attr(\"stroke-width\", 2.5)\n          .attr(\"d\", line);\n    });\n\n    // Adicionar legenda para os anos\n    const legendWidth = 200;\n    const legendHeight = 20;\n    const legendX = width - marginRight - legendWidth;\n    const legendY = marginTop;\n\n    // Legenda de gradiente horizontal\n    const legendGradient = defs.append(\"linearGradient\")\n      .attr(\"id\", \"legend-gradient\")\n      .attr(\"x1\", \"0%\")\n      .attr(\"y1\", \"0%\")\n      .attr(\"x2\", \"100%\")\n      .attr(\"y2\", \"0%\");\n\n    // Adicionar paradas de cor para a legenda\n    const years = [2024, 2035, 2045, 2055, 2070];\n    years.forEach((year, i) =&gt; {\n      legendGradient.append(\"stop\")\n        .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n        .attr(\"stop-color\", colorScale(year));\n    });\n\n    // Ret√¢ngulo da legenda com gradiente\n    svg.append(\"rect\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"url(#legend-gradient)\");\n\n    // Texto para a legenda\n    svg.append(\"text\")\n      .attr(\"x\", legendX)\n      .attr(\"y\", legendY - 5)\n      .attr(\"font-size\", \"12px\")\n      .text(\"Anos (2024-2070)\");\n\n    // R√≥tulos dos anos na legenda\n    years.forEach((year, i) =&gt; {\n      svg.append(\"text\")\n        .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n        .attr(\"y\", legendY + legendHeight + 15)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(year);\n    });\n\n    return svg.node();\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Combinado\");\nlm = qual.includes(\"Lee-Miler\");\nlc = qual.includes(\"Lee-Carter\");\n\n{\n  if (totalSelecionado === 1) {\n    if (rea) return combinado();\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  } \n  else if (totalSelecionado === 3) {\n    return [combinado(), mx_lm(), mx_lc()]; // Retorna array com todos\n  } \n  else if (totalSelecionado === 2) {\n    if (rea && lm) return [combinado(), mx_lm()];\n    if (rea && lc) return [combinado(), mx_lc()];\n    if (lm && lc) return [mx_lm(), mx_lc()];\n  } \n  else if (totalSelecionado === 0) {\n    return html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`;\n  }\n  \n  // Caso inesperado (opcional)\n  return html`&lt;p&gt;Sele√ß√£o inv√°lida&lt;/p&gt;`;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhtml`&lt;h2&gt;Combinado&lt;/h2&gt;`\n\n\n\n\n\n\n\n{\n  // Declare the chart dimensions and margins.\n  const width = 800;\n  const height = 650;\n  const marginTop = 30;\n  const marginRight = 20;\n  const marginBottom = 40;\n  const marginLeft = 50;\n\n  // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n  const faixaValues = [...new Set(data_filter1.map(d =&gt; d.faixa))];\n  \n  // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n  const x = d3.scalePoint()\n      .domain(faixaValues)\n      .range([marginLeft, width - marginRight])\n      .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n  // Declare the y (vertical position) scale.\n  const y = d3.scaleLinear()\n      .domain([d3.min(data_filter1, d =&gt; d.prev), d3.max(data_filter1, d =&gt; d.prev+1)]).nice()\n      .range([height - marginBottom, marginTop]);\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  // Adicionar defini√ß√µes para gradientes\n  const defs = svg.append(\"defs\");\n\n  // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n  const nestedData = d3.groups(data_filter1, d =&gt; d.ano);\n  \n  // Mapeando os anos entre 2024 e 2070 para cores\n  const colorScale = d3.scaleSequential()\n      .domain([2024, 2070])\n      .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n  // Adicionar um gradiente para cada linha\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const gradientId = `line-gradient-${year}`;\n\n    // Criar gradiente linear\n    const gradient = defs.append(\"linearGradient\")\n        .attr(\"id\", gradientId)\n        .attr(\"gradientUnits\", \"userSpaceOnUse\")\n        .attr(\"x1\", marginLeft)\n        .attr(\"y1\", 0)\n        .attr(\"x2\", width - marginRight)\n        .attr(\"y2\", 0);\n\n    // Adicionar paradas de cor para o gradiente\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"0%\")\n        .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"100%\")\n        .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n  });\n\n  // Add the x-axis.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x))\n      .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n      .style(\"text-anchor\", \"end\")\n      .attr(\"dx\", \"-.8em\")\n      .attr(\"dy\", \".15em\")\n      .attr(\"transform\", \"rotate(-45)\");\n\n  // Add the y-axis, remove the domain line, add grid lines and a label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).ticks(height / 40))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.selectAll(\".tick line\").clone()\n          .attr(\"x2\", width - marginLeft - marginRight)\n          .attr(\"stroke-opacity\", 0.1))\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Log Previs√£o\"));\n\n  // Declare the line generator.\n  const line = d3.line()\n      .x(d =&gt; x(d.faixa))\n      .y(d =&gt; y(d.prev));\n\n  // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const values = yearGroup[1];\n\n    // Desenhar a linha com gradiente\n    svg.append(\"path\")\n        .datum(values)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n        .attr(\"stroke-width\", 2.5)\n        .attr(\"d\", line);\n  });\n\n  // Adicionar legenda para os anos\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - marginRight - legendWidth;\n  const legendY = marginTop;\n\n  // Legenda de gradiente horizontal\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  // Adicionar paradas de cor para a legenda\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  // Ret√¢ngulo da legenda com gradiente\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Texto para a legenda\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  // R√≥tulos dos anos na legenda\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  return svg.node();\n}\n\n\n\n\n\n\n\nhtml`&lt;h2&gt;Lee-Miler&lt;/h2&gt;`\n\n\n\n\n\n\n\n{\n  // Declare the chart dimensions and margins.\n  const width = 800;\n  const height = 650;\n  const marginTop = 30;\n  const marginRight = 20;\n  const marginBottom = 40;\n  const marginLeft = 50;\n\n  // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n  const faixaValues = [...new Set(data_filter2.map(d =&gt; d.faixa))];\n  \n  // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n  const x = d3.scalePoint()\n      .domain(faixaValues)\n      .range([marginLeft, width - marginRight])\n      .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n  // Declare the y (vertical position) scale.\n  const y = d3.scaleLinear()\n      .domain([d3.min(data_filter2, d =&gt; d.prev), d3.max(data_filter2, d =&gt; d.prev+1)]).nice()\n      .range([height - marginBottom, marginTop]);\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  // Adicionar defini√ß√µes para gradientes\n  const defs = svg.append(\"defs\");\n\n  // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n  const nestedData = d3.groups(data_filter2, d =&gt; d.ano);\n  \n  // Mapeando os anos entre 2024 e 2070 para cores\n  const colorScale = d3.scaleSequential()\n      .domain([2024, 2070])\n      .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n  // Adicionar um gradiente para cada linha\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const gradientId = `line-gradient-${year}`;\n\n    // Criar gradiente linear\n    const gradient = defs.append(\"linearGradient\")\n        .attr(\"id\", gradientId)\n        .attr(\"gradientUnits\", \"userSpaceOnUse\")\n        .attr(\"x1\", marginLeft)\n        .attr(\"y1\", 0)\n        .attr(\"x2\", width - marginRight)\n        .attr(\"y2\", 0);\n\n    // Adicionar paradas de cor para o gradiente\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"0%\")\n        .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"100%\")\n        .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n  });\n\n  // Add the x-axis.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x))\n      .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n      .style(\"text-anchor\", \"end\")\n      .attr(\"dx\", \"-.8em\")\n      .attr(\"dy\", \".15em\")\n      .attr(\"transform\", \"rotate(-45)\");\n\n  // Add the y-axis, remove the domain line, add grid lines and a label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).ticks(height / 40))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.selectAll(\".tick line\").clone()\n          .attr(\"x2\", width - marginLeft - marginRight)\n          .attr(\"stroke-opacity\", 0.1))\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Log Previs√£o\"));\n\n  // Declare the line generator.\n  const line = d3.line()\n      .x(d =&gt; x(d.faixa))\n      .y(d =&gt; y(d.prev));\n\n  // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const values = yearGroup[1];\n\n    // Desenhar a linha com gradiente\n    svg.append(\"path\")\n        .datum(values)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n        .attr(\"stroke-width\", 2.5)\n        .attr(\"d\", line);\n  });\n\n  // Adicionar legenda para os anos\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - marginRight - legendWidth;\n  const legendY = marginTop;\n\n  // Legenda de gradiente horizontal\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  // Adicionar paradas de cor para a legenda\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  // Ret√¢ngulo da legenda com gradiente\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Texto para a legenda\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  // R√≥tulos dos anos na legenda\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  return svg.node();\n}\n\n\n\n\n\n\n\nhtml`&lt;h2&gt;Lee-Carter&lt;/h2&gt;`\n\n\n\n\n\n\n\n{\n  // Declare the chart dimensions and margins.\n  const width = 800;\n  const height = 650;\n  const marginTop = 30;\n  const marginRight = 20;\n  const marginBottom = 40;\n  const marginLeft = 50;\n\n  // Extraia os valores √∫nicos de faixa e ordene-os se necess√°rio\n  const faixaValues = [...new Set(data_filter3.map(d =&gt; d.faixa))];\n  \n  // Use scalePoint para valores de string - isso coloca cada valor em um ponto espec√≠fico\n  const x = d3.scalePoint()\n      .domain(faixaValues)\n      .range([marginLeft, width - marginRight])\n      .padding(0.5); // Adiciona espa√ßo nas extremidades\n\n  // Declare the y (vertical position) scale.\n  const y = d3.scaleLinear()\n      .domain([d3.min(data_filter3, d =&gt; d.prev), d3.max(data_filter3, d =&gt; d.prev+1)]).nice()\n      .range([height - marginBottom, marginTop]);\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  // Adicionar defini√ß√µes para gradientes\n  const defs = svg.append(\"defs\");\n\n  // Separar os dados por ano (ou outro agrupamento conforme necess√°rio)\n  const nestedData = d3.groups(data_filter3, d =&gt; d.ano);\n  \n  // Mapeando os anos entre 2024 e 2070 para cores\n  const colorScale = d3.scaleSequential()\n      .domain([2024, 2070])\n      .interpolator(d3.interpolateViridis); // Pode usar outras op√ß√µes: d3.interpolateInferno, d3.interpolateRainbow, etc.\n\n  // Adicionar um gradiente para cada linha\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const gradientId = `line-gradient-${year}`;\n\n    // Criar gradiente linear\n    const gradient = defs.append(\"linearGradient\")\n        .attr(\"id\", gradientId)\n        .attr(\"gradientUnits\", \"userSpaceOnUse\")\n        .attr(\"x1\", marginLeft)\n        .attr(\"y1\", 0)\n        .attr(\"x2\", width - marginRight)\n        .attr(\"y2\", 0);\n\n    // Adicionar paradas de cor para o gradiente\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"0%\")\n        .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"100%\")\n        .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070))); // Gradiente para 10 anos √† frente ou at√© 2070\n  });\n\n  // Add the x-axis.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x))\n      .selectAll(\"text\")  // Ajuste para textos inclinados se necess√°rio\n      .style(\"text-anchor\", \"end\")\n      .attr(\"dx\", \"-.8em\")\n      .attr(\"dy\", \".15em\")\n      .attr(\"transform\", \"rotate(-45)\");\n\n  // Add the y-axis, remove the domain line, add grid lines and a label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).ticks(height / 40))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.selectAll(\".tick line\").clone()\n          .attr(\"x2\", width - marginLeft - marginRight)\n          .attr(\"stroke-opacity\", 0.1))\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Log Previs√£o\"));\n\n  // Declare the line generator.\n  const line = d3.line()\n      .x(d =&gt; x(d.faixa))\n      .y(d =&gt; y(d.prev));\n\n  // Desenhar uma linha para cada ano com seu pr√≥prio gradiente\n  nestedData.forEach((yearGroup, i) =&gt; {\n    const year = yearGroup[0];\n    const values = yearGroup[1];\n\n    // Desenhar a linha com gradiente\n    svg.append(\"path\")\n        .datum(values)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", `url(#line-gradient-${year})`) // Aplicar gradiente aqui\n        .attr(\"stroke-width\", 2.5)\n        .attr(\"d\", line);\n  });\n\n  // Adicionar legenda para os anos\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - marginRight - legendWidth;\n  const legendY = marginTop;\n\n  // Legenda de gradiente horizontal\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  // Adicionar paradas de cor para a legenda\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  // Ret√¢ngulo da legenda com gradiente\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Texto para a legenda\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  // R√≥tulos dos anos na legenda\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  return svg.node();\n}"
  },
  {
    "objectID": "teste.html",
    "href": "teste.html",
    "title": "Modelos",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\n// Dados e filtros\nprev_comb = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\nprev_lm = await FileAttachment('dados/dados2/tabuas_lc.csv').csv() \nprev_lc = await FileAttachment('dados/dados2/tabuas_lm.csv').csv()\n\nviewof sexo = Inputs.radio([\"Ambos\", \"Homens\", \"Mulheres\"], {label: \"Sexo\", value: \"Homens\"})\n\ndata_filter1 = prev_comb.filter(d =&gt; d.Local === 'Brasil' && d.Sexo === sexo).map(d =&gt; ({\n  ano: +d.Ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.nMx_previs√£o)\n}))\n\ndata_filter2 = prev_lm.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\ndata_filter3 = prev_lc.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\nviewof qual = Inputs.checkbox(\n  ['Lee-Carter', 'Lee-Miler', 'Combinado'], \n  {value: ['Combinado'], label: 'Modelos:'}\n)\n\n// Fun√ß√£o principal para criar gr√°ficos\nfunction createChart(data, title) {\n  const width = 800;\n  const height = 650;\n  const margin = {top: 30, right: 20, bottom: 40, left: 50};\n  \n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [0, 0, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto;\");\n\n  // Escalas\n  const x = d3.scalePoint()\n    .domain([...new Set(data.map(d =&gt; d.faixa))])\n    .range([margin.left, width - margin.right])\n    .padding(0.5);\n\n  const y = d3.scaleLinear()\n    .domain(d3.extent(data, d =&gt; d.prev)).nice()\n    .range([height - margin.bottom, margin.top]);\n\n  // Eixos\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - margin.bottom})`)\n    .call(d3.axisBottom(x))\n    .selectAll(\"text\")\n    .style(\"text-anchor\", \"end\")\n    .attr(\"dx\", \"-.8em\")\n    .attr(\"dy\", \".15em\")\n    .attr(\"transform\", \"rotate(-45)\");\n\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},0)`)\n    .call(d3.axisLeft(y).ticks(height / 40))\n    .call(g =&gt; g.select(\".domain\").remove())\n    .call(g =&gt; g.selectAll(\".tick line\").clone()\n      .attr(\"x2\", width - margin.left - margin.right)\n      .attr(\"stroke-opacity\", 0.1));\n\n  // Gradiente e cores\n  const colorScale = d3.scaleSequential(d3.interpolateViridis)\n    .domain([2024, 2070]);\n\n  const defs = svg.append(\"defs\");\n  const nestedData = d3.groups(data, d =&gt; d.ano);\n\n  nestedData.forEach(([year, values]) =&gt; {\n    const gradientId = `gradient-${title}-${year}`;\n    \n    const gradient = defs.append(\"linearGradient\")\n      .attr(\"id\", gradientId)\n      .attr(\"gradientUnits\", \"userSpaceOnUse\")\n      .attr(\"x1\", margin.left)\n      .attr(\"y1\", 0)\n      .attr(\"x2\", width - margin.right)\n      .attr(\"y2\", 0);\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"0%\")\n      .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"100%\")\n      .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070)));\n  });\n\n  // Linhas\n  const line = d3.line()\n    .x(d =&gt; x(d.faixa))\n    .y(d =&gt; y(d.prev));\n\n  nestedData.forEach(([year, values]) =&gt; {\n    svg.append(\"path\")\n      .datum(values)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", `url(#gradient-${title}-${year})`)\n      .attr(\"stroke-width\", 2.5)\n      .attr(\"d\", line);\n  });\n\n  // Legenda\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - margin.right - legendWidth;\n  const legendY = margin.top;\n\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", `legend-${title}`)\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", `url(#legend-${title})`);\n\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  // T√≠tulo\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .style(\"font-size\", \"1.2em\")\n    .text(title);\n\n  return svg.node();\n}\n\n// Renderiza√ß√£o dos gr√°ficos\n{\n  const container = document.createElement('div');\n  container.style.display = \"grid\";\n  container.style.gap = \"2rem\";\n  container.style.justifyContent = \"center\";\n\n  if (qual.includes(\"Combinado\")) {\n    container.appendChild(createChart(data_filter1, \"Combinado\"));\n  }\n  if (qual.includes(\"Lee-Miler\")) {\n    container.appendChild(createChart(data_filter2, \"Lee-Miller\"));\n  }\n  if (qual.includes(\"Lee-Carter\")) {\n    container.appendChild(createChart(data_filter3, \"Lee-Carter\"));\n  }\n\n  return qual.length === 0 \n    ? html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n    : container;\n}"
  },
  {
    "objectID": "modelos.html#modelos-de-previs√£o-da-taxa-central-de-mortalidade",
    "href": "modelos.html#modelos-de-previs√£o-da-taxa-central-de-mortalidade",
    "title": "Modelos",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\n// Dados e filtros\nprev_comb = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\nprev_lm = await FileAttachment('dados/dados2/tabuas_lc.csv').csv() \nprev_lc = await FileAttachment('dados/dados2/tabuas_lm.csv').csv()\n\nviewof sexo = Inputs.radio([\"Ambos\", \"Homens\", \"Mulheres\"], {label: \"Sexo\", value: \"Homens\"})\n\ndata_filter1 = prev_comb.filter(d =&gt; d.Local === 'Brasil' && d.Sexo === sexo).map(d =&gt; ({\n  ano: +d.Ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.nMx_previs√£o)\n}))\n\ndata_filter2 = prev_lm.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\ndata_filter3 = prev_lc.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\nviewof qual = Inputs.checkbox(\n  ['Combinado', 'Lee-Carter', 'Lee-Miler'], \n  {value: ['Combinado'], label: 'Modelos:'}\n)\n\n// Fun√ß√£o principal para criar gr√°ficos\nfunction createChart(data, title) {\n  const width = 800;\n  const height = 550;\n  const margin = {top: 30, right: 20, bottom: 40, left: 50};\n  \n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [0, 0, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto;\");\n\n  // Escalas\n  const x = d3.scalePoint()\n    .domain([...new Set(data.map(d =&gt; d.faixa))])\n    .range([margin.left, width - margin.right])\n    .padding(0.5);\n\n  const y = d3.scaleLinear()\n    .domain(d3.extent(data, d =&gt; d.prev)).nice()\n    .range([height - margin.bottom, margin.top]);\n\n  // Eixos\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - margin.bottom})`)\n    .call(d3.axisBottom(x))\n    .selectAll(\"text\")\n    .style(\"text-anchor\", \"end\")\n    .attr(\"dx\", \"-.8em\")\n    .attr(\"dy\", \".15em\")\n    .attr(\"transform\", \"rotate(-45)\");\n\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},0)`)\n    .call(d3.axisLeft(y).ticks(height / 40))\n    .call(g =&gt; g.select(\".domain\").remove())\n    .call(g =&gt; g.selectAll(\".tick line\").clone()\n      .attr(\"x2\", width - margin.left - margin.right)\n      .attr(\"stroke-opacity\", 0.1));\n\n  // Gradiente e cores\n  const colorScale = d3.scaleSequential(d3.interpolateViridis)\n    .domain([2024, 2070]);\n\n  const defs = svg.append(\"defs\");\n  const nestedData = d3.groups(data, d =&gt; d.ano);\n\n  nestedData.forEach(([year, values]) =&gt; {\n    const gradientId = `gradient-${title}-${year}`;\n    \n    const gradient = defs.append(\"linearGradient\")\n      .attr(\"id\", gradientId)\n      .attr(\"gradientUnits\", \"userSpaceOnUse\")\n      .attr(\"x1\", margin.left)\n      .attr(\"y1\", 0)\n      .attr(\"x2\", width - margin.right)\n      .attr(\"y2\", 0);\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"0%\")\n      .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"100%\")\n      .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070)));\n  });\n\n  // Linhas\n  const line = d3.line()\n    .x(d =&gt; x(d.faixa))\n    .y(d =&gt; y(d.prev));\n\n  nestedData.forEach(([year, values]) =&gt; {\n    svg.append(\"path\")\n      .datum(values)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", `url(#gradient-${title}-${year})`)\n      .attr(\"stroke-width\", 2.5)\n      .attr(\"d\", line);\n  });\n\n  // Legenda\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - margin.right - legendWidth;\n  const legendY = margin.top;\n\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", `legend-${title}`)\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", `url(#legend-${title})`);\n\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  // T√≠tulo\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .style(\"font-size\", \"1.2em\")\n    .text(title);\n\n  return svg.node();\n}\n\n// Renderiza√ß√£o dos gr√°ficos\n{\n  const container = document.createElement('div');\n  container.style.display = \"grid\";\n  container.style.gap = \"2rem\";\n  container.style.justifyContent = \"center\";\n\n  if (qual.includes(\"Combinado\")) {\n    container.appendChild(createChart(data_filter1, \"Combinado\"));\n  }\n  if (qual.includes(\"Lee-Miler\")) {\n    container.appendChild(createChart(data_filter2, \"Lee-Miller\"));\n  }\n  if (qual.includes(\"Lee-Carter\")) {\n    container.appendChild(createChart(data_filter3, \"Lee-Carter\"));\n  }\n\n  return qual.length === 0 \n    ? html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n    : container;\n}"
  },
  {
    "objectID": "previsao.html",
    "href": "previsao.html",
    "title": "Previs√µes",
    "section": "",
    "text": "Gr√°ficosDados\n\n\n\nd3 = require(\"d3@7\")\n\n// Dados e filtros\nprev_comb = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\nprev_lm = await FileAttachment('dados/dados2/tabuas_lc.csv').csv() \nprev_lc = await FileAttachment('dados/dados2/tabuas_lm.csv').csv()\n\nviewof sexo = Inputs.radio([\"Ambos\", \"Homens\", \"Mulheres\"], {label: \"Sexo\", value: \"Homens\"})\n\nviewof regiao = Inputs.select([\n  \"Brasil\",\n  \"Norte\",\n  \"Nordeste\",\n  \"Centro-Oeste\",\n  \"Sudeste\",\n  \"Sul\",\n  \"Acre\",\n  \"Alagoas\",\n  \"Amap√°\",\n  \"Amazonas\",\n  \"Bahia\",\n  \"Cear√°\",\n  \"Distrito Federal\",\n  \"Esp√≠rito Santo\",\n  \"Goi√°s\",\n  \"Maranh√£o\",\n  \"Mato Grosso\",\n  \"Mato Grosso do Sul\",\n  \"Minas Gerais\",\n  \"Par√°\",\n  \"Para√≠ba\",\n  \"Paran√°\",\n  \"Pernambuco\",\n  \"Piau√≠\",\n  \"Rio de Janeiro\",\n  \"Rio Grande do Norte\",\n  \"Rio Grande do Sul\",\n  \"Rond√¥nia\",\n  \"Roraima\",\n  \"Santa Catarina\",\n  \"S√£o Paulo\",\n  \"Sergipe\",\n  \"Tocantins\"],\n  {\n        value: ['Brasil'],\n        label: \"Local: \"\n    })\n\ndata_filter1 = prev_comb.filter(d =&gt; d.Local === regiao && d.Sexo === sexo).map(d =&gt; ({\n  ano: +d.Ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.nMx_previs√£o)\n}))\n\ndata_filter2 = prev_lm.filter(d =&gt; d.local === regiao && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\ndata_filter3 = prev_lc.filter(d =&gt; d.local === regiao && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\nviewof qual = Inputs.checkbox(\n  ['Combinado', 'Lee-Carter', 'Lee-Miler'], \n  {value: ['Combinado'], label: 'Modelos:'}\n)\n\n// Fun√ß√£o principal para criar gr√°ficos\nfunction createChart(data, title) {\n  const width = 800;\n  const height = 550;\n  const margin = {top: 30, right: 20, bottom: 40, left: 50};\n  \n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [0, 0, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto;\");\n\n  // Escalas\n  const x = d3.scalePoint()\n    .domain([...new Set(data.map(d =&gt; d.faixa))])\n    .range([margin.left, width - margin.right])\n    .padding(0.5);\n\n  const y = d3.scaleLinear()\n    .domain(d3.extent(data, d =&gt; d.prev)).nice()\n    .range([height - margin.bottom, margin.top]);\n\n  // Eixos\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - margin.bottom})`)\n    .call(d3.axisBottom(x))\n    .selectAll(\"text\")\n    .style(\"text-anchor\", \"end\")\n    .attr(\"dx\", \"-.8em\")\n    .attr(\"dy\", \".15em\")\n    .attr(\"transform\", \"rotate(-45)\");\n\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},0)`)\n    .call(d3.axisLeft(y).ticks(height / 40))\n    .call(g =&gt; g.select(\".domain\").remove())\n    .call(g =&gt; g.selectAll(\".tick line\").clone()\n      .attr(\"x2\", width - margin.left - margin.right)\n      .attr(\"stroke-opacity\", 0.1));\n\n  // Gradiente e cores\n  const colorScale = d3.scaleSequential(d3.interpolateViridis)\n    .domain([2024, 2070]);\n\n  const defs = svg.append(\"defs\");\n  const nestedData = d3.groups(data, d =&gt; d.ano);\n\n  nestedData.forEach(([year, values]) =&gt; {\n    const gradientId = `gradient-${title}-${year}`;\n    \n    const gradient = defs.append(\"linearGradient\")\n      .attr(\"id\", gradientId)\n      .attr(\"gradientUnits\", \"userSpaceOnUse\")\n      .attr(\"x1\", margin.left)\n      .attr(\"y1\", 0)\n      .attr(\"x2\", width - margin.right)\n      .attr(\"y2\", 0);\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"0%\")\n      .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"100%\")\n      .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070)));\n  });\n\n  // Linhas\n  const line = d3.line()\n    .x(d =&gt; x(d.faixa))\n    .y(d =&gt; y(d.prev));\n\n  nestedData.forEach(([year, values]) =&gt; {\n    svg.append(\"path\")\n      .datum(values)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", `url(#gradient-${title}-${year})`)\n      .attr(\"stroke-width\", 2.5)\n      .attr(\"d\", line);\n  });\n\n  // Legenda\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - margin.right - legendWidth;\n  const legendY = margin.top;\n\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", `legend-${title}`)\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", `url(#legend-${title})`);\n\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  // T√≠tulo\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .style(\"font-size\", \"1.2em\")\n    .text(title);\n\n  return svg.node();\n}\n\n// Renderiza√ß√£o dos gr√°ficos\n{\n  const container = document.createElement('div');\n  container.style.display = \"grid\";\n  container.style.gap = \"2rem\";\n  container.style.justifyContent = \"center\";\n\n  if (qual.includes(\"Combinado\")) {\n    container.appendChild(createChart(data_filter1, \"Combinado\"));\n  }\n  if (qual.includes(\"Lee-Miler\")) {\n    container.appendChild(createChart(data_filter2, \"Lee-Miller\"));\n  }\n  if (qual.includes(\"Lee-Carter\")) {\n    container.appendChild(createChart(data_filter3, \"Lee-Carter\"));\n  }\n\n  return qual.length === 0 \n    ? html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n    : container;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.table(prev_comb)\n\n\n\n\n\n\n\nhtml`\n&lt;body&gt;\n    &lt;br&gt;\n    &lt;p&gt;Baixar \n    &lt;a href=\"dados/dados1/tabuas_combinado.csv\" download&gt;\n        dados.\n    &lt;/a&gt;\n    &lt;/p&gt;\n&lt;/body&gt;\n`\n\n\n\n\n\n\n\nInputs.table(prev_lm)\n\n\n\n\n\n\n\nhtml`\n&lt;body&gt;\n    &lt;br&gt;\n    &lt;p&gt;Baixar \n    &lt;a href=\"dados/dados2/tabuas_lm.csv\" download&gt;\n        dados.\n    &lt;/a&gt;\n    &lt;/p&gt;\n&lt;/body&gt;\n`\n\n\n\n\n\n\n\nInputs.table(prev_lc)\n\n\n\n\n\n\n\nhtml`\n&lt;body&gt;\n    &lt;br&gt;\n    &lt;p&gt;Baixar \n    &lt;a href=\"dados/dados2/tabuas_lc.csv\" download&gt;\n        dados.\n    &lt;/a&gt;\n    &lt;/p&gt;\n&lt;/body&gt;\n`"
  },
  {
    "objectID": "previsao.html#modelos-de-previs√£o-da-taxa-central-de-mortalidade",
    "href": "previsao.html#modelos-de-previs√£o-da-taxa-central-de-mortalidade",
    "title": "Previs√µes",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\n// Dados e filtros\nprev_comb = await FileAttachment('dados/dados1/previsoes_combinado.csv').csv()\nprev_lm = await FileAttachment('dados/dados2/tabuas_lc.csv').csv() \nprev_lc = await FileAttachment('dados/dados2/tabuas_lm.csv').csv()\n\nviewof sexo = Inputs.radio([\"Ambos\", \"Homens\", \"Mulheres\"], {label: \"Sexo\", value: \"Homens\"})\n\ndata_filter1 = prev_comb.filter(d =&gt; d.Local === 'Brasil' && d.Sexo === sexo).map(d =&gt; ({\n  ano: +d.Ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.nMx_previs√£o)\n}))\n\ndata_filter2 = prev_lm.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\ndata_filter3 = prev_lc.filter(d =&gt; d.local === 'Brasil' && d.sexo === sexo).map(d =&gt; ({\n  ano: +d.ano,\n  faixa: d.faixa_etaria,\n  prev: Math.log(d.mx_previsto)\n}))\n\nviewof qual = Inputs.checkbox(\n  ['Combinado', 'Lee-Carter', 'Lee-Miler'], \n  {value: ['Combinado'], label: 'Modelos:'}\n)\n\n// Fun√ß√£o principal para criar gr√°ficos\nfunction createChart(data, title) {\n  const width = 800;\n  const height = 550;\n  const margin = {top: 30, right: 20, bottom: 40, left: 50};\n  \n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [0, 0, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto;\");\n\n  // Escalas\n  const x = d3.scalePoint()\n    .domain([...new Set(data.map(d =&gt; d.faixa))])\n    .range([margin.left, width - margin.right])\n    .padding(0.5);\n\n  const y = d3.scaleLinear()\n    .domain(d3.extent(data, d =&gt; d.prev)).nice()\n    .range([height - margin.bottom, margin.top]);\n\n  // Eixos\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - margin.bottom})`)\n    .call(d3.axisBottom(x))\n    .selectAll(\"text\")\n    .style(\"text-anchor\", \"end\")\n    .attr(\"dx\", \"-.8em\")\n    .attr(\"dy\", \".15em\")\n    .attr(\"transform\", \"rotate(-45)\");\n\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},0)`)\n    .call(d3.axisLeft(y).ticks(height / 40))\n    .call(g =&gt; g.select(\".domain\").remove())\n    .call(g =&gt; g.selectAll(\".tick line\").clone()\n      .attr(\"x2\", width - margin.left - margin.right)\n      .attr(\"stroke-opacity\", 0.1));\n\n  // Gradiente e cores\n  const colorScale = d3.scaleSequential(d3.interpolateViridis)\n    .domain([2024, 2070]);\n\n  const defs = svg.append(\"defs\");\n  const nestedData = d3.groups(data, d =&gt; d.ano);\n\n  nestedData.forEach(([year, values]) =&gt; {\n    const gradientId = `gradient-${title}-${year}`;\n    \n    const gradient = defs.append(\"linearGradient\")\n      .attr(\"id\", gradientId)\n      .attr(\"gradientUnits\", \"userSpaceOnUse\")\n      .attr(\"x1\", margin.left)\n      .attr(\"y1\", 0)\n      .attr(\"x2\", width - margin.right)\n      .attr(\"y2\", 0);\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"0%\")\n      .attr(\"stop-color\", colorScale(year));\n\n    gradient.append(\"stop\")\n      .attr(\"offset\", \"100%\")\n      .attr(\"stop-color\", colorScale(Math.min(year + 10, 2070)));\n  });\n\n  // Linhas\n  const line = d3.line()\n    .x(d =&gt; x(d.faixa))\n    .y(d =&gt; y(d.prev));\n\n  nestedData.forEach(([year, values]) =&gt; {\n    svg.append(\"path\")\n      .datum(values)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", `url(#gradient-${title}-${year})`)\n      .attr(\"stroke-width\", 2.5)\n      .attr(\"d\", line);\n  });\n\n  // Legenda\n  const legendWidth = 200;\n  const legendHeight = 20;\n  const legendX = width - margin.right - legendWidth;\n  const legendY = margin.top;\n\n  const legendGradient = defs.append(\"linearGradient\")\n    .attr(\"id\", `legend-${title}`)\n    .attr(\"x1\", \"0%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y2\", \"0%\");\n\n  const years = [2024, 2035, 2045, 2055, 2070];\n  years.forEach((year, i) =&gt; {\n    legendGradient.append(\"stop\")\n      .attr(\"offset\", `${i * 100 / (years.length - 1)}%`)\n      .attr(\"stop-color\", colorScale(year));\n  });\n\n  svg.append(\"rect\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY)\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", `url(#legend-${title})`);\n\n  svg.append(\"text\")\n    .attr(\"x\", legendX)\n    .attr(\"y\", legendY - 5)\n    .attr(\"font-size\", \"12px\")\n    .text(\"Anos (2024-2070)\");\n\n  years.forEach((year, i) =&gt; {\n    svg.append(\"text\")\n      .attr(\"x\", legendX + (i * legendWidth / (years.length - 1)))\n      .attr(\"y\", legendY + legendHeight + 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", \"10px\")\n      .text(year);\n  });\n\n  // T√≠tulo\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .style(\"font-size\", \"1.2em\")\n    .text(title);\n\n  return svg.node();\n}\n\n// Renderiza√ß√£o dos gr√°ficos\n{\n  const container = document.createElement('div');\n  container.style.display = \"grid\";\n  container.style.gap = \"2rem\";\n  container.style.justifyContent = \"center\";\n\n  if (qual.includes(\"Combinado\")) {\n    container.appendChild(createChart(data_filter1, \"Combinado\"));\n  }\n  if (qual.includes(\"Lee-Miler\")) {\n    container.appendChild(createChart(data_filter2, \"Lee-Miller\"));\n  }\n  if (qual.includes(\"Lee-Carter\")) {\n    container.appendChild(createChart(data_filter3, \"Lee-Carter\"));\n  }\n\n  return qual.length === 0 \n    ? html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n    : container;\n}"
  },
  {
    "objectID": "modelos.html#taxa-central-de-mortalidade-de-2000-√†-2023-para-os-modelos-de-lee-miler-e-lee-carter",
    "href": "modelos.html#taxa-central-de-mortalidade-de-2000-√†-2023-para-os-modelos-de-lee-miler-e-lee-carter",
    "title": "Modelos",
    "section": "Taxa central de mortalidade de 2000 √† 2023 para os modelos de Lee-Miler e Lee-Carter",
    "text": "Taxa central de mortalidade de 2000 √† 2023 para os modelos de Lee-Miler e Lee-Carter\n\nviewof qual = Inputs.checkbox(['Lee-Carter', 'Lee-Miler'], {value: ['Lee-Miler', 'Lee-Carter'], label: 'Modelos:'}) \n\nviewof regiao = Inputs.select([\n  \"Brasil\",\n  \"Norte\",\n  \"Nordeste\",\n  \"Centro-Oeste\",\n  \"Sudeste\",\n  \"Sul\",\n  \"Acre\",\n  \"Alagoas\",\n  \"Amap√°\",\n  \"Amazonas\",\n  \"Bahia\",\n  \"Cear√°\",\n  \"Distrito Federal\",\n  \"Esp√≠rito Santo\",\n  \"Goi√°s\",\n  \"Maranh√£o\",\n  \"Mato Grosso\",\n  \"Mato Grosso do Sul\",\n  \"Minas Gerais\",\n  \"Par√°\",\n  \"Para√≠ba\",\n  \"Paran√°\",\n  \"Pernambuco\",\n  \"Piau√≠\",\n  \"Rio de Janeiro\",\n  \"Rio Grande do Norte\",\n  \"Rio Grande do Sul\",\n  \"Rond√¥nia\",\n  \"Roraima\",\n  \"Santa Catarina\",\n  \"S√£o Paulo\",\n  \"Sergipe\",\n  \"Tocantins\"],\n  {\n        value: ['Brasil'],\n        label: \"Local: \"\n    })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGr√°ficoDados\n\n\n\nfunction lm_lc(){\n  //lm e lc\n  {\n  const width = 800;\n  const height = 700; // Aumentei a altura total para acomodar a legenda\n  const legendHeight = 50; // Altura dedicada para a legenda\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cores para cada s√©rie\n  const cores = {\n    mx_lm: \"blue\",\n    mx_lc: \"darkred\"\n  };\n  \n  const estilos = {\n  mx_lm: \"solid\",      // Linha s√≥lida\n  mx_lc: \"dashed\"      // Linha tracejada\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n  \n  // T√≠tulo geral\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"Mortalidade por Faixa Et√°ria no Brasil (2000 - 2023) por Modelos de Previs√£o\")\n    .attr(\"font-size\", \"16px\")\n    .attr(\"font-weight\", \"bold\");\n    \n  // Adiciona legenda em linha horizontal acima dos gr√°ficos\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${width/2 - 150}, 35)`);\n    \n  const legendItems = Object.entries(cores);\n  const legendItemWidth = 100; // Largura de cada item da legenda\n  \n  legendItems.forEach(([key, color], i) =&gt; {\n    const itemX = i * legendItemWidth;\n    \n    legend.append(\"rect\")\n      .attr(\"x\", itemX)\n      .attr(\"y\", 0)\n      .attr(\"width\", 15)\n      .attr(\"height\", 15)\n      .attr(\"fill\", color);\n      \n    legend.append(\"text\")\n      .attr(\"x\", itemX + 20)\n      .attr(\"y\", 12)\n      .text(key.charAt(0).toUpperCase() + key.slice(1))\n      .attr(\"font-size\", \"12px\");\n  });\n\n  // Ajuste a √°rea dos gr√°ficos para come√ßar ap√≥s a legenda\n  const graphsStartY = legendHeight + 10;\n  \n  const subplotWidth = width / numCols;\n  const subplotHeight = (height - graphsStartY) / numRows;\n\n  for (let row = 0; row &lt; numRows; row++) {\n    for (let col = 0; col &lt; numCols; col++) {\n      const index = row * numCols + col;\n      if (index &gt;= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${graphsStartY + row * subplotHeight})`);\n      \n      // Processamento dos dados - filtrando por faixa et√°ria\n      const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm),\n          mx_lc: Math.log(+d.mx_lc)  // Adiciona transforma√ß√£o\n        })).sort((a, b) =&gt; a.ano - b.ano);\n      \n      // Verifica se existem dados para esta faixa et√°ria\n      if (filteredData.length === 0) {\n        subplot.append(\"text\")\n          .attr(\"x\", subplotWidth / 2)\n          .attr(\"y\", subplotHeight / 2)\n          .attr(\"text-anchor\", \"middle\")\n          .text(`Sem dados para: ${currentAge}`)\n          .attr(\"font-size\", \"12px\");\n        continue;\n      }\n      \n      // Escalas atualizadas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d =&gt; d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n\n      const yValues = filteredData.flatMap(d =&gt; [d.mx_lm, d.mx_lc]);\n      const yScale = d3.scaleLinear()\n        .domain([d3.min(yValues), d3.max(yValues)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5))\n        .append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", 30)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"Ano\")\n        .attr(\"fill\", \"black\");\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5))\n        .append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"y\", -30)\n        .attr(\"x\", -subplotHeight / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"log(Mx)\")\n        .attr(\"fill\", \"black\");\n\n      // Fun√ß√£o para gerar linhas\n      const gerarLinha = (variavel, cor, estilo) =&gt; {\n        const linha = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d[variavel]));\n          //.curve(d3.curveMonotoneX); // Adiciona suaviza√ß√£o para as linhas\n        \n        subplot.append(\"path\")\n          .datum(filteredData)\n          .attr(\"d\", linha)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", cor)\n          .attr(\"stroke-dasharray\", estilo === \"dashed\" ? \"5,5\" : \"0\")\n          .attr(\"stroke-width\", 2);\n\n      };\n\n      // Adiciona as tr√™s linhas\n      gerarLinha(\"mx_lm\", cores.mx_lm, estilos.mx_lm);\n      gerarLinha(\"mx_lc\", cores.mx_lc, estilos.mx_lc);\n      \n      // T√≠tulo\n      subplot.append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", margin.top / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n    \n  return svg.node();\n}}\n\nfunction mx_lm(){\n  //real e lm\n  {\n  const width = 800;\n  const height = 700; // Aumentei a altura total para acomodar a legenda\n  const legendHeight = 50; // Altura dedicada para a legenda\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cores para cada s√©rie\n  const cores = {\n    mx_lm: \"blue\",\n    mx_lc: \"darckred\"\n  };\n  \n  const estilos = {\n  mx_lm: \"solid\",      // Linha s√≥lida\n  mx_lc: \"dashed\"      // Linha tracejada\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n  \n  // T√≠tulo geral\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"Mortalidade por Faixa Et√°ria no Brasil (2000 - 2023) por Modelos de Previs√£o\")\n    .attr(\"font-size\", \"16px\")\n    .attr(\"font-weight\", \"bold\");\n    \n  // Adiciona legenda em linha horizontal acima dos gr√°ficos\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${width/2 - 150}, 35)`);\n    \n  const legendItems = Object.entries(cores);\n  const legendItemWidth = 100; // Largura de cada item da legenda\n  \n  legendItems.forEach(([key, color], i) =&gt; {\n    const itemX = i * legendItemWidth;\n    \n    legend.append(\"rect\")\n      .attr(\"x\", itemX)\n      .attr(\"y\", 0)\n      .attr(\"width\", 15)\n      .attr(\"height\", 15)\n      .attr(\"fill\", color);\n      \n    legend.append(\"text\")\n      .attr(\"x\", itemX + 20)\n      .attr(\"y\", 12)\n      .text(key.charAt(0).toUpperCase() + key.slice(1))\n      .attr(\"font-size\", \"12px\");\n  });\n\n  // Ajuste a √°rea dos gr√°ficos para come√ßar ap√≥s a legenda\n  const graphsStartY = legendHeight + 10;\n  \n  const subplotWidth = width / numCols;\n  const subplotHeight = (height - graphsStartY) / numRows;\n\n  for (let row = 0; row &lt; numRows; row++) {\n    for (let col = 0; col &lt; numCols; col++) {\n      const index = row * numCols + col;\n      if (index &gt;= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${graphsStartY + row * subplotHeight})`);\n      \n      // Processamento dos dados - filtrando por faixa et√°ria\n      const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm),\n          mx_lc: Math.log(+d.mx_lc)  // Adiciona transforma√ß√£o\n        })).sort((a, b) =&gt; a.ano - b.ano);\n      \n      // Verifica se existem dados para esta faixa et√°ria\n      if (filteredData.length === 0) {\n        subplot.append(\"text\")\n          .attr(\"x\", subplotWidth / 2)\n          .attr(\"y\", subplotHeight / 2)\n          .attr(\"text-anchor\", \"middle\")\n          .text(`Sem dados para: ${currentAge}`)\n          .attr(\"font-size\", \"12px\");\n        continue;\n      }\n      \n      // Escalas atualizadas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d =&gt; d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n\n      const yValues = filteredData.flatMap(d =&gt; [d.mx_lm, d.mx_lc]);\n      const yScale = d3.scaleLinear()\n        .domain([d3.min(yValues), d3.max(yValues)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5))\n        .append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", 30)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"Ano\")\n        .attr(\"fill\", \"black\");\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5))\n        .append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"y\", -30)\n        .attr(\"x\", -subplotHeight / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"log(Mx)\")\n        .attr(\"fill\", \"black\");\n\n      // Fun√ß√£o para gerar linhas\n      const gerarLinha = (variavel, cor, estilo) =&gt; {\n        const linha = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d[variavel]));\n          //.curve(d3.curveMonotoneX); // Adiciona suaviza√ß√£o para as linhas\n        \n        subplot.append(\"path\")\n          .datum(filteredData)\n          .attr(\"d\", linha)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", cor)\n          .attr(\"stroke-dasharray\", estilo === \"dashed\" ? \"5,5\" : \"0\")\n          .attr(\"stroke-width\", 2);\n\n      };\n\n      // Adiciona as tr√™s linhas\n      gerarLinha(\"mx_lm\", cores.mx_lm, estilos.mx_lm);\n      //gerarLinha(\"mx_lc\", cores.mx_lc, estilos.mx_lc);\n      \n      // T√≠tulo\n      subplot.append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", margin.top / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n    \n  return svg.node();\n}\n}\n\nfunction mx_lc(){\n  //real e lc\n  {\n  const width = 800;\n  const height = 700; // Aumentei a altura total para acomodar a legenda\n  const legendHeight = 50; // Altura dedicada para a legenda\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cores para cada s√©rie\n  const cores = {\n    mx_lm: \"blue\",\n    mx_lc: \"darckred\"\n  };\n  \n  const estilos = {\n  mx_lm: \"solid\",      // Linha s√≥lida\n  mx_lc: \"solid\"      // Linha tracejada\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  const ageGroups = [...new Set(data.map(d =&gt; d.faixa_etaria))].sort();\n  \n  // T√≠tulo geral\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"Mortalidade por Faixa Et√°ria no Brasil (2000 - 2023) por Modelos de Previs√£o\")\n    .attr(\"font-size\", \"16px\")\n    .attr(\"font-weight\", \"bold\");\n    \n  // Adiciona legenda em linha horizontal acima dos gr√°ficos\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${width/2 - 150}, 35)`);\n    \n  const legendItems = Object.entries(cores);\n  const legendItemWidth = 100; // Largura de cada item da legenda\n  \n  legendItems.forEach(([key, color], i) =&gt; {\n    const itemX = i * legendItemWidth;\n    \n    legend.append(\"rect\")\n      .attr(\"x\", itemX)\n      .attr(\"y\", 0)\n      .attr(\"width\", 15)\n      .attr(\"height\", 15)\n      .attr(\"fill\", color);\n      \n    legend.append(\"text\")\n      .attr(\"x\", itemX + 20)\n      .attr(\"y\", 12)\n      .text(key.charAt(0).toUpperCase() + key.slice(1))\n      .attr(\"font-size\", \"12px\");\n  });\n\n  // Ajuste a √°rea dos gr√°ficos para come√ßar ap√≥s a legenda\n  const graphsStartY = legendHeight + 10;\n  \n  const subplotWidth = width / numCols;\n  const subplotHeight = (height - graphsStartY) / numRows;\n\n  for (let row = 0; row &lt; numRows; row++) {\n    for (let col = 0; col &lt; numCols; col++) {\n      const index = row * numCols + col;\n      if (index &gt;= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${graphsStartY + row * subplotHeight})`);\n      \n      // Processamento dos dados - filtrando por faixa et√°ria\n      const filteredData = data.filter(d =&gt; \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d =&gt; ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm),\n          mx_lc: Math.log(+d.mx_lc)  // Adiciona transforma√ß√£o\n        })).sort((a, b) =&gt; a.ano - b.ano);\n      \n      // Verifica se existem dados para esta faixa et√°ria\n      if (filteredData.length === 0) {\n        subplot.append(\"text\")\n          .attr(\"x\", subplotWidth / 2)\n          .attr(\"y\", subplotHeight / 2)\n          .attr(\"text-anchor\", \"middle\")\n          .text(`Sem dados para: ${currentAge}`)\n          .attr(\"font-size\", \"12px\");\n        continue;\n      }\n      \n      // Escalas atualizadas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d =&gt; d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n\n      const yValues = filteredData.flatMap(d =&gt; [d.mx_lm, d.mx_lc]);\n      const yScale = d3.scaleLinear()\n        .domain([d3.min(yValues), d3.max(yValues)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5))\n        .append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", 30)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"Ano\")\n        .attr(\"fill\", \"black\");\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5))\n        .append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"y\", -30)\n        .attr(\"x\", -subplotHeight / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"log(Mx)\")\n        .attr(\"fill\", \"black\");\n\n      // Fun√ß√£o para gerar linhas\n      const gerarLinha = (variavel, cor, estilo) =&gt; {\n        const linha = d3.line()\n          .x(d =&gt; xScale(d.ano))\n          .y(d =&gt; yScale(d[variavel]));\n          //.curve(d3.curveMonotoneX); // Adiciona suaviza√ß√£o para as linhas\n        \n        subplot.append(\"path\")\n          .datum(filteredData)\n          .attr(\"d\", linha)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", cor)\n          .attr(\"stroke-dasharray\", estilo === \"dashed\" ? \"5,5\" : \"0\")\n          .attr(\"stroke-width\", 2);\n\n      };\n\n      // Adiciona as tr√™s linhas\n      //gerarLinha(\"mx_lm\", cores.mx_lm, estilos.mx_lm);\n      gerarLinha(\"mx_lc\", cores.mx_lc, estilos.mx_lc);\n      \n      // T√≠tulo\n      subplot.append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", margin.top / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n    \n  return svg.node();\n}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Observado\")\nlm = qual.includes(\"Lee-Miler\")\nlc = qual.includes(\"Lee-Carter\")\n\n{\n  if(totalSelecionado === 1 ){\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  }else if (totalSelecionado === 2){\n    if (lm && lc) return lm_lc();\n  }else if (totalSelecionado == 0){\n    return html`&lt;p&gt;Nenhum dado selecionado.&lt;/p&gt;`\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.table(data)\n\n\n\n\n\n\n\nhtml`\n&lt;body&gt;\n    &lt;br&gt;\n    &lt;p&gt;Baixar \n    &lt;a href=\"dados/dados2/erros.csv\" download&gt;\n        dados.\n    &lt;/a&gt;\n    &lt;/p&gt;\n&lt;/body&gt;\n`"
  },
  {
    "objectID": "base_de_dados.html",
    "href": "base_de_dados.html",
    "title": "SIGERIP",
    "section": "",
    "text": "d3 = require(\"d3@7\")\ndados = await FileAttachment(\"dados/base_dados/tabua_concatenada.csv\").csv()\ntabua = await FileAttachment(\"dados/base_dados/taxa_mortalidade.csv\").csv()\n\n\nviewof regiao = Inputs.select([\n  \"Brasil\",\n  \"Norte\",\n  \"Nordeste\",\n  \"Centro-Oeste\",\n  \"Sudeste\",\n  \"Sul\",\n  \"Acre\",\n  \"Alagoas\",\n  \"Amap√°\",\n  \"Amazonas\",\n  \"Bahia\",\n  \"Cear√°\",\n  \"Distrito Federal\",\n  \"Esp√≠rito Santo\",\n  \"Goi√°s\",\n  \"Maranh√£o\",\n  \"Mato Grosso\",\n  \"Mato Grosso do Sul\",\n  \"Minas Gerais\",\n  \"Par√°\",\n  \"Para√≠ba\",\n  \"Paran√°\",\n  \"Pernambuco\",\n  \"Piau√≠\",\n  \"Rio de Janeiro\",\n  \"Rio Grande do Norte\",\n  \"Rio Grande do Sul\",\n  \"Rond√¥nia\",\n  \"Roraima\",\n  \"Santa Catarina\",\n  \"S√£o Paulo\",\n  \"Sergipe\",\n  \"Tocantins\"],\n  {\n        value: ['Brasil'],\n        label: \"Local: \"\n    })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGr√°ficoBase de Dados\n\n\n\n{\n  const width = 800;\n  const height = 650; // Aumentei a altura total para acomodar a legenda\n  const legendHeight = 50; // Altura dedicada para a legenda\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cores para cada s√©rie\n  const cores = {\n    ambos: \"steelblue\",\n    masculino: \"darkorange\",\n    feminino: \"green\"\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  const ageGroups = [...new Set(tabua.map(d =&gt; d.faixa_etaria))].sort();\n  \n  // T√≠tulo geral\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"Mortalidade por Faixa Et√°ria no Brasil (2000 - 2023)\")\n    .attr(\"font-size\", \"16px\")\n    .attr(\"font-weight\", \"bold\");\n    \n  // Adiciona legenda em linha horizontal acima dos gr√°ficos\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${width/2 - 150}, 35)`);\n    \n  const legendItems = Object.entries(cores);\n  const legendItemWidth = 100; // Largura de cada item da legenda\n  \n  legendItems.forEach(([key, color], i) =&gt; {\n    const itemX = i * legendItemWidth;\n    \n    legend.append(\"rect\")\n      .attr(\"x\", itemX)\n      .attr(\"y\", 0)\n      .attr(\"width\", 15)\n      .attr(\"height\", 15)\n      .attr(\"fill\", color);\n      \n    legend.append(\"text\")\n      .attr(\"x\", itemX + 20)\n      .attr(\"y\", 12)\n      .text(key.charAt(0).toUpperCase() + key.slice(1))\n      .attr(\"font-size\", \"12px\");\n  });\n\n  // Ajuste a √°rea dos gr√°ficos para come√ßar ap√≥s a legenda\n  const graphsStartY = legendHeight + 10;\n  \n  const subplotWidth = width / numCols;\n  const subplotHeight = (height - graphsStartY) / numRows;\n\n  for (let row = 0; row &lt; numRows; row++) {\n    for (let col = 0; col &lt; numCols; col++) {\n      const index = row * numCols + col;\n      if (index &gt;= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${graphsStartY + row * subplotHeight})`);\n      \n      // Processamento dos dados - filtrando por faixa et√°ria\n      const filteredData = tabua.filter(d =&gt;  \n          d.local === 'Brasil' && d.faixa_etaria === currentAge\n        ).map(d =&gt; ({\n          ...d,\n          Ano: +d.Ano,\n          ambos: Math.log(+d.ambos),\n          feminino: Math.log(+d.feminino),\n          masculino: Math.log(+d.masculino)\n        })).sort((a, b) =&gt; a.Ano - b.Ano);\n      \n      // Verifica se existem dados para esta faixa et√°ria\n      if (filteredData.length === 0) {\n        subplot.append(\"text\")\n          .attr(\"x\", subplotWidth / 2)\n          .attr(\"y\", subplotHeight / 2)\n          .attr(\"text-anchor\", \"middle\")\n          .text(`Sem dados para: ${currentAge}`)\n          .attr(\"font-size\", \"12px\");\n        continue;\n      }\n      \n      // Escalas atualizadas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d =&gt; d.Ano))\n        .range([margin.left, subplotWidth - margin.right]);\n\n      const yValues = filteredData.flatMap(d =&gt; [d.ambos, d.feminino, d.masculino]);\n      const yScale = d3.scaleLinear()\n        .domain([d3.min(yValues), d3.max(yValues)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5))\n        .append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", 30)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"Ano\")\n        .attr(\"fill\", \"black\");\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5))\n        .append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"y\", -30)\n        .attr(\"x\", -subplotHeight / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"log(Mx)\")\n        .attr(\"fill\", \"black\");\n\n      // Fun√ß√£o para gerar linhas\n      const gerarLinha = (variavel, cor) =&gt; {\n        const linha = d3.line()\n          .x(d =&gt; xScale(d.Ano))\n          .y(d =&gt; yScale(d[variavel]))\n          //.curve(d3.curveMonotoneX); // Adiciona suaviza√ß√£o para as linhas\n        \n        subplot.append(\"path\")\n          .datum(filteredData)\n          .attr(\"d\", linha)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", cor)\n          .attr(\"stroke-width\", 2);\n\n      };\n\n      // Adiciona as tr√™s linhas\n      gerarLinha(\"ambos\", cores.ambos);\n      gerarLinha(\"masculino\", cores.masculino);\n      gerarLinha(\"feminino\", cores.feminino);\n      \n      // T√≠tulo\n      subplot.append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", margin.top / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n    \n  return svg.node();\n}\n\n\n\n\n\n\n\n\n\nInputs.table(dados)\n\n\n\n\n\n\n\nhtml`\n&lt;body&gt;\n    &lt;br&gt;\n    &lt;p&gt;Baixar \n    &lt;a href=\"dados/base_dados/tabua_concatenada.csv\" download&gt;\n        dados.\n    &lt;/a&gt;\n    &lt;/p&gt;\n&lt;/body&gt;\n`"
  },
  {
    "objectID": "base_de_dados.html#base-de-dados",
    "href": "base_de_dados.html#base-de-dados",
    "title": "SIGERIP",
    "section": "",
    "text": "d3 = require(\"d3@7\")\ntabua = await FileAttachment(\"dados/base_dados/tabua_concatenada.csv\").csv()\nInputs.table(tabua)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhtml`\n&lt;body&gt;\n    &lt;br&gt;\n    &lt;p&gt;Baixar a \n    &lt;a href=\"dados/base_dados/tabua_concatenada.csv\" download&gt;\n        Tabua\n    &lt;/a&gt;\n    &lt;/p&gt;\n&lt;/body&gt;\n`"
  }
]