{"title":"Gráficos","markdown":{"yaml":{"title":"Gráficos","execute":{"echo":false,"panel":"sidebar"}},"headingText":"Mapa da expectativa de vida ao nascer por Unidade Federativa","containsRefs":false,"markdown":"\n\n```{ojs}\n// Importar D3.js\nd3 = require(\"d3@7\")\n// Carregando os dados\nstateData1 = await FileAttachment(\"expec.csv\").csv()\nstateData = tabelaFiltrada2.map(d => ({\n  estado: d.estado,\n  valor: +d.valor // Converte para número\n}))\ntabelaFiltrada2 = stateData1\n    .filter(d => +d.Ano === ano5)\n    .map(d => ({\n        estado: d.Local,\n        valor: d.ex\n    }));\n\n\ndados = FileAttachment(\"comp_pop.csv\").csv()\ntabelaFiltrada = dados.filter(d => d.new_local === estados &&\n                                   +d.Ano === ano6)\n\n```\n\nO mapa representa a expectativa de vida ao nascer distribuido entre estados e Distrito Federal ao longo dos anos de 2000 a 2023.\n\n::: {.panel-tabset}\n\n## PLot\n```{ojs}\nviewof ano5 = Inputs.range([2000, 2023],\n       {\n        value: [2000],\n        step: 1,\n        label: \"Ano: \"\n    }\n)\n\n// Carregar o GeoJSON dos estados brasileiros\ngeoData = await fetch(\"https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/brazil-states.geojson\")\n  .then(response => response.json())\n\n// Criar o mapa\nwidth = 800;\nheight = 600;\n\nchart3 = {\n  const svg = d3.create(\"svg\")\n    .attr(\"viewBox\", [0, 0, width, height])\n    .style(\"width\", \"100%\")\n    .style(\"height\", \"auto\");\n\n  // Configurar a projeção\n  const projection = d3.geoMercator()\n    .center([-52, -15]) // Centralizar no Brasil\n    .scale(700)\n    .translate([width / 2, height / 2]);\n\n  const path = d3.geoPath().projection(projection);\n\n  // Criar escala de cores\n  const valores = stateData.map(d => d.valor);\n  const colorScale = d3.scaleSequential()\n    .domain([d3.min(valores), d3.max(valores)])\n    .interpolator(d3.interpolateBlues);\n\n  // Função para normalizar nomes (remover acentos)\n  const normalizeName = name => name\n    ? name.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").toLowerCase()\n    : \"\";\n\n  // Criar mapa\n  svg.selectAll(\"path\")\n    .data(geoData.features)\n    .join(\"path\")\n    .attr(\"d\", path)\n    .attr(\"fill\", d => {\n      const state = stateData.find(s =>\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n      return state ? colorScale(state.valor) : \"#ccc\";\n    })\n    .attr(\"stroke\", \"white\")\n    .attr(\"stroke-width\", 0.5);\n\n  // Adicionar tooltip\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .attr(\"class\", \"tooltip\")\n    .style(\"opacity\", 0)\n    .style(\"position\", \"absolute\")\n    .style(\"background-color\", \"white\")\n    .style(\"border\", \"solid\")\n    .style(\"border-width\", \"1px\")\n    .style(\"border-radius\", \"5px\")\n    .style(\"padding\", \"5px\");\n\n  svg.selectAll(\"path\")\n    .on(\"mouseover\", (event, d) => {\n      const state = stateData.find(s =>\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", .9);\n\n      tooltip.html(`\n        Estado: ${d.properties.name}<br/>\n        Valor: ${state ? state.valor : 'Sem dados'}\n      `)\n        .style(\"left\", (event.pageX + 10) + \"px\")\n        .style(\"top\", (event.pageY - 28) + \"px\");\n    })\n    .on(\"mouseout\", () => {\n      tooltip.transition()\n        .duration(500)\n        .style(\"opacity\", 0);\n    });\n\n  // Adicionar barra de cores (legenda)\n  const legendWidth = 400;\n  const legendHeight = 20;\n\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${(width - legendWidth) / 2}, ${height - 25})`);\n\n  const gradient = legend.append(\"defs\")\n    .append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"y2\", \"0%\");\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"0%\")\n    .attr(\"stop-color\", colorScale(d3.min(valores)));\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"100%\")\n    .attr(\"stop-color\", colorScale(d3.max(valores)));\n\n  legend.append(\"rect\")\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Adicionar rótulos na barra de cores\n  legend.append(\"text\")\n    .attr(\"x\", 0)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"start\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.min(valores)));\n\n  legend.append(\"text\")\n    .attr(\"x\", legendWidth)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"end\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.max(valores)));\n\n  return svg.node();\n}\n\n// Mostrar valores mínimos e máximos\n    minMaxValues = {\n    const valores = stateData.map(d => d.valor);\n    return {\n        min: d3.min(valores),\n        max: d3.max(valores)\n    };\n}\n```\n\n## Data\n\n```{ojs}\nInputs.table(tabelaFiltrada2)\nhtml`\n<body>\n    <a href=\"expec.csv\" download>\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV completo\n        </button>\n    </a>\n    <a download=\"tabelaFiltrada2.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\">\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV filtrado\n        </button>\n</a>\n</body>\n`\n```\n\n:::\n\n## Evolução da População por faixa-etária\nO gráfico representa uma comparação entre dados interpolados pelo IBGE e por nós (SIGERIP), que nos demonstra a população por faixa-etária sellecionado por nação, regiões, estados e distrito federal.\n\n::: {.panel-tabset}\n\n## PLot\n```{ojs}\nviewof ano6 = Inputs.range([2000, 2023],\n       {\n        value: [2000],\n        step: 1,\n        label: \"Ano: \"\n    }\n)\n\nviewof estados = Inputs.select(['Brasil', 'Norte', 'Nordeste', 'Sudeste', 'Sul', 'Centro-Oeste',\n       'Rondônia', 'Acre', 'Amazonas', 'Roraima', 'Pará', 'Amapá',\n       'Tocantins', 'Maranhão', 'Piauí', 'Ceará', 'Rio Grande do Norte',\n       'Paraíba', 'Pernambuco', 'Alagoas', 'Sergipe', 'Bahia',\n       'Minas Gerais', 'Espírito Santo', 'Rio de Janeiro', 'São Paulo',\n       'Paraná', 'Santa Catarina', 'Rio Grande do Sul',\n       'Mato Grosso do Sul', 'Mato Grosso', 'Goiás', 'Distrito Federal'],\n       {\n        value: 'Brasil',\n        label: \"Local: \"\n        }\n       )\n\n// Gráfico\nchart = {{\n  // Definição das dimensões do gráfico\n  const width = 828;  // Largura do gráfico\n  const height = 600; // Altura do gráfico\n  const marginTop = 20;    // Margem superior\n  const marginRight = 20;  // Margem direita\n  const marginBottom = 30; // Margem inferior\n  const marginLeft = 50;   // Margem esquerda\n\n  // Escala para o eixo X (Ano)\n  const x = d3.scaleLinear()\n    .domain(d3.extent(tabelaFiltrada, d => +d.new_faixa))  // Determina o intervalo de valores para o eixo X com base no ano\n    .range([marginLeft, width - marginRight]);  // Define o intervalo de pixels no eixo X\n\n  // Escala para o eixo Y (Total)\n  const y = d3.scaleLinear()\n    .domain([d3.min(tabelaFiltrada, d => +d.Total), d3.max(tabelaFiltrada, d => +d.Total)]).nice()  // Define o intervalo de valores para o eixo Y com base no total\n    .range([height - marginBottom, marginTop]);  // Define o intervalo de pixels no eixo Y\n\n  // Definição de cores para as linhas\n  const color = d3.scaleOrdinal(d3.schemeCategory10);  // Usa uma paleta de cores pré-definida do D3\n\n  // Criação do elemento SVG para o gráfico\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)  // Define a largura do SVG\n    .attr(\"height\", height)  // Define a altura do SVG\n    .attr(\"viewBox\", [0, 0, width, height])  // Define a visualização do SVG com base nas dimensões\n    .style(\"max-width\", \"100%\")  // Estilo para garantir que o gráfico seja responsivo\n    .style(\"height\", \"auto\")  // Estilo para ajustar a altura automaticamente\n    .style(\"overflow\", \"visible\")  // Permite que os elementos do gráfico saiam do limite do SVG\n    .style(\"font\", \"10px sans-serif\");  // Define o estilo da fonte no gráfico\n\n  // Adiciona o eixo X (ano)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - marginBottom})`)  // Posiciona o eixo X na parte inferior\n    .call(d3.axisBottom(x).tickFormat(d3.format(\"d\")));  // Aplica a escala X e formata os ticks como números inteiros\n\n  // Adiciona o eixo Y (total)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${marginLeft},0)`)  // Posiciona o eixo Y à esquerda\n    .call(d3.axisLeft(y))  // Aplica a escala Y\n    .call(g => g.select(\".domain\").remove())  // Remove a linha do eixo Y\n    .call(g => g.append(\"text\")  // Adiciona texto ao lado do eixo Y\n      .attr(\"x\", -marginLeft)  // Posiciona o texto à esquerda do gráfico\n      .attr(\"y\", 10)  // Posiciona o texto no eixo Y\n      .attr(\"fill\", \"currentColor\")  // Define a cor do texto\n      .attr(\"text-anchor\", \"start\")  // Define o alinhamento do texto\n      .text(\"↑ Total (%)\"));  // Texto do eixo Y\n\n  // Agrupa os dados pela coluna UF (Unidade Federativa)\n  const groupedData = d3.group(tabelaFiltrada, d => d.Fonte);\n\n  // Define a função para desenhar as linhas no gráfico\n  const line = d3.line()\n    .x(d => x(+d.new_faixa))  // Define a posição X da linha com base no ano\n    .y(d => y(+d.Total));  // Define a posição Y da linha com base no total\n\n  // Adiciona as linhas para cada grupo de dados\n  const paths = svg.append(\"g\")\n    .selectAll(\"path\")  // Seleciona todos os elementos \"path\" (caminhos das linhas)\n    .data(groupedData)  // Vincula os dados agrupados (por UF)\n    .join(\"path\")  // Cria um novo \"path\" para cada grupo de dados\n    .attr(\"fill\", \"none\")  // Define que as linhas não terão preenchimento\n    .attr(\"stroke\", ([key]) => color(key))  // Define a cor da linha de acordo com a UF\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da linha\n    .attr(\"d\", ([, values]) => line(values));  // Desenha a linha para cada conjunto de dados\n\n  // Adiciona o texto com o nome da UF na extremidade de cada linha\n  svg.append(\"g\")\n    .selectAll(\"text\")\n    .data(groupedData)\n    .join(\"text\")\n    .attr(\"font-size\", 20)  // Define o tamanho da fonte do texto\n    .attr(\"x\", width - marginRight)  // Posiciona o texto à direita\n    .attr(\"y\", ([, values]) => y(+values[values.length - 1].Total))  // Posiciona o texto na última coordenada da linha\n    .attr(\"dy\", \"0.35em\")  // Ajusta a posição vertical do texto\n    .attr(\"text-anchor\", \"start\")  // Alinha o texto à esquerda\n    .attr(\"fill\", ([key]) => color(key))  // Define a cor do texto de acordo com a UF\n    .text(([key]) => key);  // Define o texto como o nome da UF\n  \n  // Adiciona os pontos no gráfico\n  svg.append(\"g\")\n    .selectAll(\"circle\")\n    .data(tabelaFiltrada)\n    .join(\"circle\")\n    .attr(\"cx\", d => x(+d.new_faixa))  // Posição horizontal baseada no ano\n    .attr(\"cy\", d => y(+d.Total))  // Posição vertical baseada no total\n    .attr(\"r\", 4)  // Define o raio do círculo\n    .attr(\"fill\", d => color(d.Fonte))  // Define a cor do ponto com base na UF\n    .attr(\"stroke\", \"white\")  // Adiciona uma borda branca ao ponto\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da borda\n    ;\n\n  // Criação do tooltip (caixa de informação ao passar o mouse)\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .style(\"position\", \"absolute\")  // Define a posição absoluta do tooltip\n    .style(\"background\", \"white\")  // Define o fundo branco do tooltip\n    .style(\"border\", \"1px solid #ccc\")  // Define a borda do tooltip\n    .style(\"padding\", \"5px\")  // Adiciona o espaçamento interno\n    .style(\"border-radius\", \"5px\")  // Define bordas arredondadas\n    .style(\"font-size\", \"12px\")  // Define o tamanho da fonte\n    .style(\"pointer-events\", \"none\")  // Impede a interação do tooltip com o gráfico\n    .style(\"opacity\", 0);  // Inicialmente o tooltip é invisível\n\n  // Adiciona interação para mostrar o tooltip quando o mouse passa sobre a linha\n  paths.on(\"pointermove\", (event, [uf, values]) => {\n    // Encontra o ponto mais próximo do mouse na linha\n    const [xm, ym] = d3.pointer(event);\n    const closest = d3.least(values, d => Math.hypot(x(+d.Ano) - xm, y(+d.Total) - ym));\n    \n    if (closest) {\n      const { Ano, Total } = closest;  // Obtém os dados do ponto mais próximo\n\n      // Destaque da linha: reduz opacidade das outras e aumenta a espessura da linha ativa\n      paths.attr(\"stroke-opacity\", 0.2);  \n      d3.select(event.target).attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 2.5);\n\n      // Atualiza o tooltip com os dados do ponto mais próximo\n      tooltip.style(\"opacity\", 1)\n        .html(`Fonte: ${uf}<br>Ano: ${Ano}<br>Total: ${Total}`)\n        .style(\"left\", `${event.pageX + 10}px`)  // Posiciona o tooltip ao lado do mouse\n        .style(\"top\", `${event.pageY + 10}px`);  // Posiciona o tooltip acima do mouse\n    }\n  });\n\n  // Esconde o tooltip e restaura a opacidade das linhas quando o mouse sai\n  paths.on(\"pointerleave\", () => {\n    paths.attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 1.5);  // Restaura a opacidade e espessura das linhas\n    tooltip.style(\"opacity\", 0);  // Oculta o tooltip\n  });\n\n  return svg.node();  // Retorna o elemento SVG para ser exibido\n}};\n```\n## Data\n\n```{ojs}\nInputs.table(tabelaFiltrada)\nhtml`\n<body>\n    <a href=\"comp_pop.csv\" download>\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV completo\n        </button>\n    </a>\n    <a download=\"tabelaFiltrada.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\">\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV filtrado\n        </button>\n</a>\n</body>\n`\n```\n\n:::\n## Mortalidade por faixa-etária\nO gráfico representa a mortalidade ao longo do tempo por nação, regiões, estado e distrito federal, podendo selecionar faixa etária no qual deseja ver a sua evolução ao longo do tempo (2000 - 2023).\n\n::: {.panel-tabset}\n\n## PLot\n```{ojs}\nmortalidade = FileAttachment(\"mortalidade1.csv\").csv()\nmortalidade_filtrada = mortalidade\n    .filter(d => d.idade === faixa_etaria_mortalidade &&\n                 (estados_mortalidade.includes(\"Todos estados\") || estados_mortalidade.includes(d.UF))\n    )\n    .map(d => ({\n        Ano: d.Ano,\n        UF: d.UF,\n        Total: d.Total\n    }));\n\nviewof faixa_etaria_mortalidade = Inputs.select(\n    ['Menos de 1 ano', '1 a 4 anos', '5 a 9 anos', '10 a 14 anos', '15 a 19 anos', '20 a 24 anos', '25 a 29 anos', '30 a 34 anos', '35 a 39 anos', '40 a 44 anos', '45 a 49 anos', '50 a 54 anos', '55 a 59 anos', '60 a 64 anos', '65 a 69 anos', '70 a 74 anos', '75 a 79 anos', '80 anos ou mais'],\n    {\n        value: ['Menos de 1 ano'],\n        label: \"Faixa etária: \"\n    }\n)\nviewof estados_mortalidade = Inputs.checkbox(\n  [\n    \"AC\", \"AL\", \"AM\", \"AP\", \"BA\", \"CE\", \"DF\", \"ES\", \"GO\", \"MA\", \n    \"MT\", \"MS\", \"MG\", \"PA\", \"PB\", \"PE\", \"PI\", \"PR\", \"RJ\", \"RN\", \n    \"RO\", \"RR\", \"RS\", \"SC\", \"SE\", \"SP\", \"TO\", \"Todos estados\"\n  ],\n  {\n    value: [\"Todos estados\"], // Define \"Todos estados\" como valor inicial selecionado\n    label: \"Local: \",\n    sort: true, // Ordena alfabeticamente\n    unique: true // Evita duplicatas\n  }\n)\n\n\n// Gráfico\nchart1 = {{\n  // Definição das dimensões do gráfico\n  const width = 928;  // Largura do gráfico\n  const height = 600; // Altura do gráfico\n  const marginTop = 20;    // Margem superior\n  const marginRight = 20;  // Margem direita\n  const marginBottom = 30; // Margem inferior\n  const marginLeft = 50;   // Margem esquerda\n\n  // Escala para o eixo X (Ano)\n  const x = d3.scaleLinear()\n    .domain(d3.extent(mortalidade_filtrada, d => +d.Ano))  // Determina o intervalo de valores para o eixo X com base no ano\n    .range([marginLeft, width - marginRight]);  // Define o intervalo de pixels no eixo X\n\n  // Escala para o eixo Y (Total)\n  const y = d3.scaleLinear()\n    .domain([d3.min(mortalidade_filtrada, d => +d.Total), d3.max(mortalidade_filtrada, d => +d.Total)]).nice()  // Define o intervalo de valores para o eixo Y com base no total\n    .range([height - marginBottom, marginTop]);  // Define o intervalo de pixels no eixo Y\n\n  // Definição de cores para as linhas\n  const color = d3.scaleOrdinal(d3.schemeCategory10);  // Usa uma paleta de cores pré-definida do D3\n\n  // Criação do elemento SVG para o gráfico\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)  // Define a largura do SVG\n    .attr(\"height\", height)  // Define a altura do SVG\n    .attr(\"viewBox\", [0, 0, width, height])  // Define a visualização do SVG com base nas dimensões\n    .style(\"max-width\", \"100%\")  // Estilo para garantir que o gráfico seja responsivo\n    .style(\"height\", \"auto\")  // Estilo para ajustar a altura automaticamente\n    .style(\"overflow\", \"visible\")  // Permite que os elementos do gráfico saiam do limite do SVG\n    .style(\"font\", \"10px sans-serif\");  // Define o estilo da fonte no gráfico\n\n  // Adiciona o eixo X (ano)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - marginBottom})`)  // Posiciona o eixo X na parte inferior\n    .call(d3.axisBottom(x).tickFormat(d3.format(\"d\")));  // Aplica a escala X e formata os ticks como números inteiros\n\n  // Adiciona o eixo Y (total)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${marginLeft},0)`)  // Posiciona o eixo Y à esquerda\n    .call(d3.axisLeft(y))  // Aplica a escala Y\n    .call(g => g.select(\".domain\").remove())  // Remove a linha do eixo Y\n    .call(g => g.append(\"text\")  // Adiciona texto ao lado do eixo Y\n      .attr(\"x\", -marginLeft)  // Posiciona o texto à esquerda do gráfico\n      .attr(\"y\", 10)  // Posiciona o texto no eixo Y\n      .attr(\"fill\", \"currentColor\")  // Define a cor do texto\n      .attr(\"text-anchor\", \"start\")  // Define o alinhamento do texto\n      .text(\"↑ Total (%)\"));  // Texto do eixo Y\n\n  // Agrupa os dados pela coluna UF (Unidade Federativa)\n  const groupedData = d3.group(mortalidade_filtrada, d => d.UF);\n\n  // Define a função para desenhar as linhas no gráfico\n  const line = d3.line()\n    .x(d => x(+d.Ano))  // Define a posição X da linha com base no ano\n    .y(d => y(+d.Total));  // Define a posição Y da linha com base no total\n\n  // Adiciona as linhas para cada grupo de dados\n  const paths = svg.append(\"g\")\n    .selectAll(\"path\")  // Seleciona todos os elementos \"path\" (caminhos das linhas)\n    .data(groupedData)  // Vincula os dados agrupados (por UF)\n    .join(\"path\")  // Cria um novo \"path\" para cada grupo de dados\n    .attr(\"fill\", \"none\")  // Define que as linhas não terão preenchimento\n    .attr(\"stroke\", ([key]) => color(key))  // Define a cor da linha de acordo com a UF\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da linha\n    .attr(\"d\", ([, values]) => line(values));  // Desenha a linha para cada conjunto de dados\n\n  // Adiciona o texto com o nome da UF na extremidade de cada linha\n  svg.append(\"g\")\n    .selectAll(\"text\")\n    .data(groupedData)\n    .join(\"text\")\n    .attr(\"font-size\", 10)  // Define o tamanho da fonte do texto\n    .attr(\"x\", width - marginRight)  // Posiciona o texto à direita\n    .attr(\"y\", ([, values]) => y(+values[values.length - 1].Total))  // Posiciona o texto na última coordenada da linha\n    .attr(\"dy\", \"0.35em\")  // Ajusta a posição vertical do texto\n    .attr(\"text-anchor\", \"start\")  // Alinha o texto à esquerda\n    .attr(\"fill\", ([key]) => color(key))  // Define a cor do texto de acordo com a UF\n    .text(([key]) => key);  // Define o texto como o nome da UF\n\n\n\n  // Criação do tooltip (caixa de informação ao passar o mouse)\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .style(\"position\", \"absolute\")  // Define a posição absoluta do tooltip\n    .style(\"background\", \"white\")  // Define o fundo branco do tooltip\n    .style(\"border\", \"1px solid #ccc\")  // Define a borda do tooltip\n    .style(\"padding\", \"5px\")  // Adiciona o espaçamento interno\n    .style(\"border-radius\", \"5px\")  // Define bordas arredondadas\n    .style(\"font-size\", \"12px\")  // Define o tamanho da fonte\n    .style(\"pointer-events\", \"none\")  // Impede a interação do tooltip com o gráfico\n    .style(\"opacity\", 0);  // Inicialmente o tooltip é invisível\n\n  // Adiciona interação para mostrar o tooltip quando o mouse passa sobre a linha\n  paths.on(\"pointermove\", (event, [uf, values]) => {\n    // Encontra o ponto mais próximo do mouse na linha\n    const [xm, ym] = d3.pointer(event);\n    const closest = d3.least(values, d => Math.hypot(x(+d.Ano) - xm, y(+d.Total) - ym));\n    \n    if (closest) {\n      const { Ano, Total } = closest;  // Obtém os dados do ponto mais próximo\n\n      // Destaque da linha: reduz opacidade das outras e aumenta a espessura da linha ativa\n      paths.attr(\"stroke-opacity\", 0.2);  \n      d3.select(event.target).attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 2.5);\n\n      // Atualiza o tooltip com os dados do ponto mais próximo\n      tooltip.style(\"opacity\", 1)\n        .html(`UF: ${uf}<br>Ano: ${Ano}<br>Total: ${Total}`)\n        .style(\"left\", `${event.pageX + 10}px`)  // Posiciona o tooltip ao lado do mouse\n        .style(\"top\", `${event.pageY + 10}px`);  // Posiciona o tooltip acima do mouse\n    }\n  });\n\n  // Esconde o tooltip e restaura a opacidade das linhas quando o mouse sai\n  paths.on(\"pointerleave\", () => {\n    paths.attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 1.5);  // Restaura a opacidade e espessura das linhas\n    tooltip.style(\"opacity\", 0);  // Oculta o tooltip\n  });\n\n  return svg.node();  // Retorna o elemento SVG para ser exibido\n}};\n```\n## Data\n\n```{ojs}\nInputs.table(tabelaFiltrada)\nfunction converterParaCSV(dados) {\n  const cabecalho = Object.keys(dados[0]).join(\",\")\n  const linhas = dados.map(obj => \n    Object.values(obj).map(v => \n      `\"${String(v).replace(/\"/g, '\"\"')}\"`\n    ).join(\",\")\n  )\n  return [cabecalho, ...linhas].join(\"\\n\")\n}\ncsv = converterParaCSV(mortalidade_filtrada)\nhtml`\n<body>\n    <a href=\"mortalidade1.csv\" download>\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV completo\n        </button>\n    </a>\n    <a download=\"mortalidade_filtrada.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\">\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV filtrado\n        </button>\n</a>\n</body>\n`\n```\n\n:::","srcMarkdownNoYaml":"\n\n```{ojs}\n// Importar D3.js\nd3 = require(\"d3@7\")\n// Carregando os dados\nstateData1 = await FileAttachment(\"expec.csv\").csv()\nstateData = tabelaFiltrada2.map(d => ({\n  estado: d.estado,\n  valor: +d.valor // Converte para número\n}))\ntabelaFiltrada2 = stateData1\n    .filter(d => +d.Ano === ano5)\n    .map(d => ({\n        estado: d.Local,\n        valor: d.ex\n    }));\n\n\ndados = FileAttachment(\"comp_pop.csv\").csv()\ntabelaFiltrada = dados.filter(d => d.new_local === estados &&\n                                   +d.Ano === ano6)\n\n```\n\n## Mapa da expectativa de vida ao nascer por Unidade Federativa\nO mapa representa a expectativa de vida ao nascer distribuido entre estados e Distrito Federal ao longo dos anos de 2000 a 2023.\n\n::: {.panel-tabset}\n\n## PLot\n```{ojs}\nviewof ano5 = Inputs.range([2000, 2023],\n       {\n        value: [2000],\n        step: 1,\n        label: \"Ano: \"\n    }\n)\n\n// Carregar o GeoJSON dos estados brasileiros\ngeoData = await fetch(\"https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/brazil-states.geojson\")\n  .then(response => response.json())\n\n// Criar o mapa\nwidth = 800;\nheight = 600;\n\nchart3 = {\n  const svg = d3.create(\"svg\")\n    .attr(\"viewBox\", [0, 0, width, height])\n    .style(\"width\", \"100%\")\n    .style(\"height\", \"auto\");\n\n  // Configurar a projeção\n  const projection = d3.geoMercator()\n    .center([-52, -15]) // Centralizar no Brasil\n    .scale(700)\n    .translate([width / 2, height / 2]);\n\n  const path = d3.geoPath().projection(projection);\n\n  // Criar escala de cores\n  const valores = stateData.map(d => d.valor);\n  const colorScale = d3.scaleSequential()\n    .domain([d3.min(valores), d3.max(valores)])\n    .interpolator(d3.interpolateBlues);\n\n  // Função para normalizar nomes (remover acentos)\n  const normalizeName = name => name\n    ? name.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").toLowerCase()\n    : \"\";\n\n  // Criar mapa\n  svg.selectAll(\"path\")\n    .data(geoData.features)\n    .join(\"path\")\n    .attr(\"d\", path)\n    .attr(\"fill\", d => {\n      const state = stateData.find(s =>\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n      return state ? colorScale(state.valor) : \"#ccc\";\n    })\n    .attr(\"stroke\", \"white\")\n    .attr(\"stroke-width\", 0.5);\n\n  // Adicionar tooltip\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .attr(\"class\", \"tooltip\")\n    .style(\"opacity\", 0)\n    .style(\"position\", \"absolute\")\n    .style(\"background-color\", \"white\")\n    .style(\"border\", \"solid\")\n    .style(\"border-width\", \"1px\")\n    .style(\"border-radius\", \"5px\")\n    .style(\"padding\", \"5px\");\n\n  svg.selectAll(\"path\")\n    .on(\"mouseover\", (event, d) => {\n      const state = stateData.find(s =>\n        normalizeName(s.estado) === normalizeName(d.properties.name)\n      );\n\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", .9);\n\n      tooltip.html(`\n        Estado: ${d.properties.name}<br/>\n        Valor: ${state ? state.valor : 'Sem dados'}\n      `)\n        .style(\"left\", (event.pageX + 10) + \"px\")\n        .style(\"top\", (event.pageY - 28) + \"px\");\n    })\n    .on(\"mouseout\", () => {\n      tooltip.transition()\n        .duration(500)\n        .style(\"opacity\", 0);\n    });\n\n  // Adicionar barra de cores (legenda)\n  const legendWidth = 400;\n  const legendHeight = 20;\n\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${(width - legendWidth) / 2}, ${height - 25})`);\n\n  const gradient = legend.append(\"defs\")\n    .append(\"linearGradient\")\n    .attr(\"id\", \"legend-gradient\")\n    .attr(\"x1\", \"0%\")\n    .attr(\"x2\", \"100%\")\n    .attr(\"y1\", \"0%\")\n    .attr(\"y2\", \"0%\");\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"0%\")\n    .attr(\"stop-color\", colorScale(d3.min(valores)));\n\n  gradient.append(\"stop\")\n    .attr(\"offset\", \"100%\")\n    .attr(\"stop-color\", colorScale(d3.max(valores)));\n\n  legend.append(\"rect\")\n    .attr(\"width\", legendWidth)\n    .attr(\"height\", legendHeight)\n    .style(\"fill\", \"url(#legend-gradient)\");\n\n  // Adicionar rótulos na barra de cores\n  legend.append(\"text\")\n    .attr(\"x\", 0)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"start\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.min(valores)));\n\n  legend.append(\"text\")\n    .attr(\"x\", legendWidth)\n    .attr(\"y\", -5)\n    .attr(\"text-anchor\", \"end\")\n    .style(\"font-size\", \"20px\")\n    .text(Math.round(d3.max(valores)));\n\n  return svg.node();\n}\n\n// Mostrar valores mínimos e máximos\n    minMaxValues = {\n    const valores = stateData.map(d => d.valor);\n    return {\n        min: d3.min(valores),\n        max: d3.max(valores)\n    };\n}\n```\n\n## Data\n\n```{ojs}\nInputs.table(tabelaFiltrada2)\nhtml`\n<body>\n    <a href=\"expec.csv\" download>\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV completo\n        </button>\n    </a>\n    <a download=\"tabelaFiltrada2.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\">\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV filtrado\n        </button>\n</a>\n</body>\n`\n```\n\n:::\n\n## Evolução da População por faixa-etária\nO gráfico representa uma comparação entre dados interpolados pelo IBGE e por nós (SIGERIP), que nos demonstra a população por faixa-etária sellecionado por nação, regiões, estados e distrito federal.\n\n::: {.panel-tabset}\n\n## PLot\n```{ojs}\nviewof ano6 = Inputs.range([2000, 2023],\n       {\n        value: [2000],\n        step: 1,\n        label: \"Ano: \"\n    }\n)\n\nviewof estados = Inputs.select(['Brasil', 'Norte', 'Nordeste', 'Sudeste', 'Sul', 'Centro-Oeste',\n       'Rondônia', 'Acre', 'Amazonas', 'Roraima', 'Pará', 'Amapá',\n       'Tocantins', 'Maranhão', 'Piauí', 'Ceará', 'Rio Grande do Norte',\n       'Paraíba', 'Pernambuco', 'Alagoas', 'Sergipe', 'Bahia',\n       'Minas Gerais', 'Espírito Santo', 'Rio de Janeiro', 'São Paulo',\n       'Paraná', 'Santa Catarina', 'Rio Grande do Sul',\n       'Mato Grosso do Sul', 'Mato Grosso', 'Goiás', 'Distrito Federal'],\n       {\n        value: 'Brasil',\n        label: \"Local: \"\n        }\n       )\n\n// Gráfico\nchart = {{\n  // Definição das dimensões do gráfico\n  const width = 828;  // Largura do gráfico\n  const height = 600; // Altura do gráfico\n  const marginTop = 20;    // Margem superior\n  const marginRight = 20;  // Margem direita\n  const marginBottom = 30; // Margem inferior\n  const marginLeft = 50;   // Margem esquerda\n\n  // Escala para o eixo X (Ano)\n  const x = d3.scaleLinear()\n    .domain(d3.extent(tabelaFiltrada, d => +d.new_faixa))  // Determina o intervalo de valores para o eixo X com base no ano\n    .range([marginLeft, width - marginRight]);  // Define o intervalo de pixels no eixo X\n\n  // Escala para o eixo Y (Total)\n  const y = d3.scaleLinear()\n    .domain([d3.min(tabelaFiltrada, d => +d.Total), d3.max(tabelaFiltrada, d => +d.Total)]).nice()  // Define o intervalo de valores para o eixo Y com base no total\n    .range([height - marginBottom, marginTop]);  // Define o intervalo de pixels no eixo Y\n\n  // Definição de cores para as linhas\n  const color = d3.scaleOrdinal(d3.schemeCategory10);  // Usa uma paleta de cores pré-definida do D3\n\n  // Criação do elemento SVG para o gráfico\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)  // Define a largura do SVG\n    .attr(\"height\", height)  // Define a altura do SVG\n    .attr(\"viewBox\", [0, 0, width, height])  // Define a visualização do SVG com base nas dimensões\n    .style(\"max-width\", \"100%\")  // Estilo para garantir que o gráfico seja responsivo\n    .style(\"height\", \"auto\")  // Estilo para ajustar a altura automaticamente\n    .style(\"overflow\", \"visible\")  // Permite que os elementos do gráfico saiam do limite do SVG\n    .style(\"font\", \"10px sans-serif\");  // Define o estilo da fonte no gráfico\n\n  // Adiciona o eixo X (ano)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - marginBottom})`)  // Posiciona o eixo X na parte inferior\n    .call(d3.axisBottom(x).tickFormat(d3.format(\"d\")));  // Aplica a escala X e formata os ticks como números inteiros\n\n  // Adiciona o eixo Y (total)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${marginLeft},0)`)  // Posiciona o eixo Y à esquerda\n    .call(d3.axisLeft(y))  // Aplica a escala Y\n    .call(g => g.select(\".domain\").remove())  // Remove a linha do eixo Y\n    .call(g => g.append(\"text\")  // Adiciona texto ao lado do eixo Y\n      .attr(\"x\", -marginLeft)  // Posiciona o texto à esquerda do gráfico\n      .attr(\"y\", 10)  // Posiciona o texto no eixo Y\n      .attr(\"fill\", \"currentColor\")  // Define a cor do texto\n      .attr(\"text-anchor\", \"start\")  // Define o alinhamento do texto\n      .text(\"↑ Total (%)\"));  // Texto do eixo Y\n\n  // Agrupa os dados pela coluna UF (Unidade Federativa)\n  const groupedData = d3.group(tabelaFiltrada, d => d.Fonte);\n\n  // Define a função para desenhar as linhas no gráfico\n  const line = d3.line()\n    .x(d => x(+d.new_faixa))  // Define a posição X da linha com base no ano\n    .y(d => y(+d.Total));  // Define a posição Y da linha com base no total\n\n  // Adiciona as linhas para cada grupo de dados\n  const paths = svg.append(\"g\")\n    .selectAll(\"path\")  // Seleciona todos os elementos \"path\" (caminhos das linhas)\n    .data(groupedData)  // Vincula os dados agrupados (por UF)\n    .join(\"path\")  // Cria um novo \"path\" para cada grupo de dados\n    .attr(\"fill\", \"none\")  // Define que as linhas não terão preenchimento\n    .attr(\"stroke\", ([key]) => color(key))  // Define a cor da linha de acordo com a UF\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da linha\n    .attr(\"d\", ([, values]) => line(values));  // Desenha a linha para cada conjunto de dados\n\n  // Adiciona o texto com o nome da UF na extremidade de cada linha\n  svg.append(\"g\")\n    .selectAll(\"text\")\n    .data(groupedData)\n    .join(\"text\")\n    .attr(\"font-size\", 20)  // Define o tamanho da fonte do texto\n    .attr(\"x\", width - marginRight)  // Posiciona o texto à direita\n    .attr(\"y\", ([, values]) => y(+values[values.length - 1].Total))  // Posiciona o texto na última coordenada da linha\n    .attr(\"dy\", \"0.35em\")  // Ajusta a posição vertical do texto\n    .attr(\"text-anchor\", \"start\")  // Alinha o texto à esquerda\n    .attr(\"fill\", ([key]) => color(key))  // Define a cor do texto de acordo com a UF\n    .text(([key]) => key);  // Define o texto como o nome da UF\n  \n  // Adiciona os pontos no gráfico\n  svg.append(\"g\")\n    .selectAll(\"circle\")\n    .data(tabelaFiltrada)\n    .join(\"circle\")\n    .attr(\"cx\", d => x(+d.new_faixa))  // Posição horizontal baseada no ano\n    .attr(\"cy\", d => y(+d.Total))  // Posição vertical baseada no total\n    .attr(\"r\", 4)  // Define o raio do círculo\n    .attr(\"fill\", d => color(d.Fonte))  // Define a cor do ponto com base na UF\n    .attr(\"stroke\", \"white\")  // Adiciona uma borda branca ao ponto\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da borda\n    ;\n\n  // Criação do tooltip (caixa de informação ao passar o mouse)\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .style(\"position\", \"absolute\")  // Define a posição absoluta do tooltip\n    .style(\"background\", \"white\")  // Define o fundo branco do tooltip\n    .style(\"border\", \"1px solid #ccc\")  // Define a borda do tooltip\n    .style(\"padding\", \"5px\")  // Adiciona o espaçamento interno\n    .style(\"border-radius\", \"5px\")  // Define bordas arredondadas\n    .style(\"font-size\", \"12px\")  // Define o tamanho da fonte\n    .style(\"pointer-events\", \"none\")  // Impede a interação do tooltip com o gráfico\n    .style(\"opacity\", 0);  // Inicialmente o tooltip é invisível\n\n  // Adiciona interação para mostrar o tooltip quando o mouse passa sobre a linha\n  paths.on(\"pointermove\", (event, [uf, values]) => {\n    // Encontra o ponto mais próximo do mouse na linha\n    const [xm, ym] = d3.pointer(event);\n    const closest = d3.least(values, d => Math.hypot(x(+d.Ano) - xm, y(+d.Total) - ym));\n    \n    if (closest) {\n      const { Ano, Total } = closest;  // Obtém os dados do ponto mais próximo\n\n      // Destaque da linha: reduz opacidade das outras e aumenta a espessura da linha ativa\n      paths.attr(\"stroke-opacity\", 0.2);  \n      d3.select(event.target).attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 2.5);\n\n      // Atualiza o tooltip com os dados do ponto mais próximo\n      tooltip.style(\"opacity\", 1)\n        .html(`Fonte: ${uf}<br>Ano: ${Ano}<br>Total: ${Total}`)\n        .style(\"left\", `${event.pageX + 10}px`)  // Posiciona o tooltip ao lado do mouse\n        .style(\"top\", `${event.pageY + 10}px`);  // Posiciona o tooltip acima do mouse\n    }\n  });\n\n  // Esconde o tooltip e restaura a opacidade das linhas quando o mouse sai\n  paths.on(\"pointerleave\", () => {\n    paths.attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 1.5);  // Restaura a opacidade e espessura das linhas\n    tooltip.style(\"opacity\", 0);  // Oculta o tooltip\n  });\n\n  return svg.node();  // Retorna o elemento SVG para ser exibido\n}};\n```\n## Data\n\n```{ojs}\nInputs.table(tabelaFiltrada)\nhtml`\n<body>\n    <a href=\"comp_pop.csv\" download>\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV completo\n        </button>\n    </a>\n    <a download=\"tabelaFiltrada.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\">\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV filtrado\n        </button>\n</a>\n</body>\n`\n```\n\n:::\n## Mortalidade por faixa-etária\nO gráfico representa a mortalidade ao longo do tempo por nação, regiões, estado e distrito federal, podendo selecionar faixa etária no qual deseja ver a sua evolução ao longo do tempo (2000 - 2023).\n\n::: {.panel-tabset}\n\n## PLot\n```{ojs}\nmortalidade = FileAttachment(\"mortalidade1.csv\").csv()\nmortalidade_filtrada = mortalidade\n    .filter(d => d.idade === faixa_etaria_mortalidade &&\n                 (estados_mortalidade.includes(\"Todos estados\") || estados_mortalidade.includes(d.UF))\n    )\n    .map(d => ({\n        Ano: d.Ano,\n        UF: d.UF,\n        Total: d.Total\n    }));\n\nviewof faixa_etaria_mortalidade = Inputs.select(\n    ['Menos de 1 ano', '1 a 4 anos', '5 a 9 anos', '10 a 14 anos', '15 a 19 anos', '20 a 24 anos', '25 a 29 anos', '30 a 34 anos', '35 a 39 anos', '40 a 44 anos', '45 a 49 anos', '50 a 54 anos', '55 a 59 anos', '60 a 64 anos', '65 a 69 anos', '70 a 74 anos', '75 a 79 anos', '80 anos ou mais'],\n    {\n        value: ['Menos de 1 ano'],\n        label: \"Faixa etária: \"\n    }\n)\nviewof estados_mortalidade = Inputs.checkbox(\n  [\n    \"AC\", \"AL\", \"AM\", \"AP\", \"BA\", \"CE\", \"DF\", \"ES\", \"GO\", \"MA\", \n    \"MT\", \"MS\", \"MG\", \"PA\", \"PB\", \"PE\", \"PI\", \"PR\", \"RJ\", \"RN\", \n    \"RO\", \"RR\", \"RS\", \"SC\", \"SE\", \"SP\", \"TO\", \"Todos estados\"\n  ],\n  {\n    value: [\"Todos estados\"], // Define \"Todos estados\" como valor inicial selecionado\n    label: \"Local: \",\n    sort: true, // Ordena alfabeticamente\n    unique: true // Evita duplicatas\n  }\n)\n\n\n// Gráfico\nchart1 = {{\n  // Definição das dimensões do gráfico\n  const width = 928;  // Largura do gráfico\n  const height = 600; // Altura do gráfico\n  const marginTop = 20;    // Margem superior\n  const marginRight = 20;  // Margem direita\n  const marginBottom = 30; // Margem inferior\n  const marginLeft = 50;   // Margem esquerda\n\n  // Escala para o eixo X (Ano)\n  const x = d3.scaleLinear()\n    .domain(d3.extent(mortalidade_filtrada, d => +d.Ano))  // Determina o intervalo de valores para o eixo X com base no ano\n    .range([marginLeft, width - marginRight]);  // Define o intervalo de pixels no eixo X\n\n  // Escala para o eixo Y (Total)\n  const y = d3.scaleLinear()\n    .domain([d3.min(mortalidade_filtrada, d => +d.Total), d3.max(mortalidade_filtrada, d => +d.Total)]).nice()  // Define o intervalo de valores para o eixo Y com base no total\n    .range([height - marginBottom, marginTop]);  // Define o intervalo de pixels no eixo Y\n\n  // Definição de cores para as linhas\n  const color = d3.scaleOrdinal(d3.schemeCategory10);  // Usa uma paleta de cores pré-definida do D3\n\n  // Criação do elemento SVG para o gráfico\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)  // Define a largura do SVG\n    .attr(\"height\", height)  // Define a altura do SVG\n    .attr(\"viewBox\", [0, 0, width, height])  // Define a visualização do SVG com base nas dimensões\n    .style(\"max-width\", \"100%\")  // Estilo para garantir que o gráfico seja responsivo\n    .style(\"height\", \"auto\")  // Estilo para ajustar a altura automaticamente\n    .style(\"overflow\", \"visible\")  // Permite que os elementos do gráfico saiam do limite do SVG\n    .style(\"font\", \"10px sans-serif\");  // Define o estilo da fonte no gráfico\n\n  // Adiciona o eixo X (ano)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(0,${height - marginBottom})`)  // Posiciona o eixo X na parte inferior\n    .call(d3.axisBottom(x).tickFormat(d3.format(\"d\")));  // Aplica a escala X e formata os ticks como números inteiros\n\n  // Adiciona o eixo Y (total)\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${marginLeft},0)`)  // Posiciona o eixo Y à esquerda\n    .call(d3.axisLeft(y))  // Aplica a escala Y\n    .call(g => g.select(\".domain\").remove())  // Remove a linha do eixo Y\n    .call(g => g.append(\"text\")  // Adiciona texto ao lado do eixo Y\n      .attr(\"x\", -marginLeft)  // Posiciona o texto à esquerda do gráfico\n      .attr(\"y\", 10)  // Posiciona o texto no eixo Y\n      .attr(\"fill\", \"currentColor\")  // Define a cor do texto\n      .attr(\"text-anchor\", \"start\")  // Define o alinhamento do texto\n      .text(\"↑ Total (%)\"));  // Texto do eixo Y\n\n  // Agrupa os dados pela coluna UF (Unidade Federativa)\n  const groupedData = d3.group(mortalidade_filtrada, d => d.UF);\n\n  // Define a função para desenhar as linhas no gráfico\n  const line = d3.line()\n    .x(d => x(+d.Ano))  // Define a posição X da linha com base no ano\n    .y(d => y(+d.Total));  // Define a posição Y da linha com base no total\n\n  // Adiciona as linhas para cada grupo de dados\n  const paths = svg.append(\"g\")\n    .selectAll(\"path\")  // Seleciona todos os elementos \"path\" (caminhos das linhas)\n    .data(groupedData)  // Vincula os dados agrupados (por UF)\n    .join(\"path\")  // Cria um novo \"path\" para cada grupo de dados\n    .attr(\"fill\", \"none\")  // Define que as linhas não terão preenchimento\n    .attr(\"stroke\", ([key]) => color(key))  // Define a cor da linha de acordo com a UF\n    .attr(\"stroke-width\", 1.5)  // Define a espessura da linha\n    .attr(\"d\", ([, values]) => line(values));  // Desenha a linha para cada conjunto de dados\n\n  // Adiciona o texto com o nome da UF na extremidade de cada linha\n  svg.append(\"g\")\n    .selectAll(\"text\")\n    .data(groupedData)\n    .join(\"text\")\n    .attr(\"font-size\", 10)  // Define o tamanho da fonte do texto\n    .attr(\"x\", width - marginRight)  // Posiciona o texto à direita\n    .attr(\"y\", ([, values]) => y(+values[values.length - 1].Total))  // Posiciona o texto na última coordenada da linha\n    .attr(\"dy\", \"0.35em\")  // Ajusta a posição vertical do texto\n    .attr(\"text-anchor\", \"start\")  // Alinha o texto à esquerda\n    .attr(\"fill\", ([key]) => color(key))  // Define a cor do texto de acordo com a UF\n    .text(([key]) => key);  // Define o texto como o nome da UF\n\n\n\n  // Criação do tooltip (caixa de informação ao passar o mouse)\n  const tooltip = d3.select(\"body\").append(\"div\")\n    .style(\"position\", \"absolute\")  // Define a posição absoluta do tooltip\n    .style(\"background\", \"white\")  // Define o fundo branco do tooltip\n    .style(\"border\", \"1px solid #ccc\")  // Define a borda do tooltip\n    .style(\"padding\", \"5px\")  // Adiciona o espaçamento interno\n    .style(\"border-radius\", \"5px\")  // Define bordas arredondadas\n    .style(\"font-size\", \"12px\")  // Define o tamanho da fonte\n    .style(\"pointer-events\", \"none\")  // Impede a interação do tooltip com o gráfico\n    .style(\"opacity\", 0);  // Inicialmente o tooltip é invisível\n\n  // Adiciona interação para mostrar o tooltip quando o mouse passa sobre a linha\n  paths.on(\"pointermove\", (event, [uf, values]) => {\n    // Encontra o ponto mais próximo do mouse na linha\n    const [xm, ym] = d3.pointer(event);\n    const closest = d3.least(values, d => Math.hypot(x(+d.Ano) - xm, y(+d.Total) - ym));\n    \n    if (closest) {\n      const { Ano, Total } = closest;  // Obtém os dados do ponto mais próximo\n\n      // Destaque da linha: reduz opacidade das outras e aumenta a espessura da linha ativa\n      paths.attr(\"stroke-opacity\", 0.2);  \n      d3.select(event.target).attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 2.5);\n\n      // Atualiza o tooltip com os dados do ponto mais próximo\n      tooltip.style(\"opacity\", 1)\n        .html(`UF: ${uf}<br>Ano: ${Ano}<br>Total: ${Total}`)\n        .style(\"left\", `${event.pageX + 10}px`)  // Posiciona o tooltip ao lado do mouse\n        .style(\"top\", `${event.pageY + 10}px`);  // Posiciona o tooltip acima do mouse\n    }\n  });\n\n  // Esconde o tooltip e restaura a opacidade das linhas quando o mouse sai\n  paths.on(\"pointerleave\", () => {\n    paths.attr(\"stroke-opacity\", 1).attr(\"stroke-width\", 1.5);  // Restaura a opacidade e espessura das linhas\n    tooltip.style(\"opacity\", 0);  // Oculta o tooltip\n  });\n\n  return svg.node();  // Retorna o elemento SVG para ser exibido\n}};\n```\n## Data\n\n```{ojs}\nInputs.table(tabelaFiltrada)\nfunction converterParaCSV(dados) {\n  const cabecalho = Object.keys(dados[0]).join(\",\")\n  const linhas = dados.map(obj => \n    Object.values(obj).map(v => \n      `\"${String(v).replace(/\"/g, '\"\"')}\"`\n    ).join(\",\")\n  )\n  return [cabecalho, ...linhas].join(\"\\n\")\n}\ncsv = converterParaCSV(mortalidade_filtrada)\nhtml`\n<body>\n    <a href=\"mortalidade1.csv\" download>\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV completo\n        </button>\n    </a>\n    <a download=\"mortalidade_filtrada.csv\" href=\"${\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv)}\">\n        <button style=\"padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 220px\">\n          ⬇️ Baixar CSV filtrado\n        </button>\n</a>\n</body>\n`\n```\n\n:::"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"panel":"sidebar","engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"graficos.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","theme":"cosmo","title":"Gráficos"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}