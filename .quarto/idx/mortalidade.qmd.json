{"title":"Dados de Mortalidade","markdown":{"yaml":{"title":"Dados de Mortalidade","execute":{"echo":false,"panel":"sidebar"}},"headingText":"Taxa central de mortalidade de 2000 à 2023 para os modelos de Lee-Miler e Lee-Carter","containsRefs":false,"markdown":"\n\n\n```{ojs}\nd3 = require(\"d3@7\")\n\ndata = await FileAttachment(\"dados/dados2/erros.csv\").csv()\ntabua_comb = await FileAttachment(\"dados/dados1/previsoes_combinado.csv\").csv()\n\ndata_filter = data.filter(\n    d => d.faixa_etaria === '0' && d.regiao === 'Brasil' && d.taxa === 'Total'\n)\n\n\nhtml`\n<p style=\"text-align: justify;\">Aqui, você encontrará um conjunto de dados detalhados sobre mortalidade dividido entre: Brasil, Regiões e Estados, combinando informações reais extraídas do Instituto Brasileiro de Geografia e Estatística (IBGE) com projeções e análises desenvolvidas por nossa equipe.</p>\n<p style=\"text-align: justify;\">Nosso objetivo é oferecer uma visão clara e acessível sobre a evolução dos padrões de mortalidade, permitindo comparações entre os dados históricos e nossas estimativas futuras. Utilizamos modelos estatísticos e atuariais para gerar previsões que podem ser aplicadas em diversas áreas, como seguros, previdência, saúde pública e planejamento estratégico.</p>\n<p style=\"text-align: justify;\">Explore nossos gráficos interativos e relatórios para entender melhor as tendências e impactos da longevidade no Brasil.</p>\n`\n```\n\n\n\n```{ojs}\nviewof qual = Inputs.checkbox(['Lee-Carter', 'Lee-Miler', 'Observado'], {value: ['Lee-Miler', 'Lee-Carter', 'Observado'], label: 'Modelos:'}) \n\nviewof regiao = Inputs.select([\n  \"Brasil\",\n  \"Norte\",\n  \"Nordeste\",\n  \"Centro-Oeste\",\n  \"Sudeste\",\n  \"Sul\",\n  \"Acre\",\n  \"Alagoas\",\n  \"Amapá\",\n  \"Amazonas\",\n  \"Bahia\",\n  \"Ceará\",\n  \"Distrito Federal\",\n  \"Espírito Santo\",\n  \"Goiás\",\n  \"Maranhão\",\n  \"Mato Grosso\",\n  \"Mato Grosso do Sul\",\n  \"Minas Gerais\",\n  \"Pará\",\n  \"Paraíba\",\n  \"Paraná\",\n  \"Pernambuco\",\n  \"Piauí\",\n  \"Rio de Janeiro\",\n  \"Rio Grande do Norte\",\n  \"Rio Grande do Sul\",\n  \"Rondônia\",\n  \"Roraima\",\n  \"Santa Catarina\",\n  \"São Paulo\",\n  \"Sergipe\",\n  \"Tocantins\"],\n  {\n        value: ['Brasil'],\n        label: \"Local: \"\n    })\n\nhtml`\n<div class=\"grafico-container\">\n  <!-- Legenda HTML -->\n  <div class=\"legenda\">\n    <div class=\"legenda-item\">\n      <div class=\"cor-marcador\" style=\"background: steelblue\"></div>\n      <span>Observado</span>\n    </div>\n    <div class=\"legenda-item\">\n      <div class=\"cor-marcador\" style=\"background: darkorange\"></div>\n      <span>Modelo LC</span>\n    </div>\n    <div class=\"legenda-item\">\n      <div class=\"cor-marcador\" style=\"background: green\"></div>\n      <span>Modelo LM</span>\n    </div>\n  </div>\n\n  <!-- Container do gráfico SVG será injetado aqui -->\n  <div id=\"grafico\"></div>\n</div>\n\n<style>\n.grafico-container {\n  max-width: 800px;\n  margin: 0 auto;\n  font-family: sans-serif;\n}\n\n.legenda {\n  display: flex;\n  gap: 1.5rem;\n  justify-content: center;\n  margin-bottom: 1.5rem;\n}\n\n.legenda-item {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.25rem 0.75rem;\n  background: #f5f5f5;\n  border-radius: 1rem;\n}\n\n.cor-marcador {\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n}\n\n</style>\n`\n\n```\n\n\n```{ojs}\nfunction lm_lc(){\n  //lm e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d => [ d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) => {\n          const linha = d3.line()\n            .x(d => xScale(d.ano))\n            .y(d => yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lm(){\n  //real e lm\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d => [d.mx_real, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) => {\n          const linha = d3.line()\n            .x(d => xScale(d.ano))\n            .y(d => yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lc(){\n  //real e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d => [d.mx_real, d.mx_lc]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) => {\n          const linha = d3.line()\n            .x(d => xScale(d.ano))\n            .y(d => yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n\n\nfunction todos(){\n  //todos\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d => [d.mx_real, d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) => {\n          const linha = d3.line()\n            .x(d => xScale(d.ano))\n            .y(d => yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n//real\nfunction real(){\n  {\n    const width = 800;\n    const height = 750;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d => d.mx_real), d3.max(filteredData, d => d.mx_real)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d.mx_real));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) => a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"steelblue\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lm\nfunction mx_lm(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d => d.mx_lm), d3.max(filteredData, d => d.mx_lm)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d.mx_lm));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) => a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"green\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lc\nfunction mx_lc(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d => d.mx_lc), d3.max(filteredData, d => d.mx_lc)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d.mx_lc));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) => a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"darkorange\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n```\n\n```{ojs}\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Observado\")\nlm = qual.includes(\"Lee-Miler\")\nlc = qual.includes(\"Lee-Carter\")\n\n{\n  if(totalSelecionado === 1 ){\n    if (rea) return real();\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  }else if (totalSelecionado === 3){\n    return todos()\n  }else if (totalSelecionado === 2){\n    if (rea && lm) return real_lm();\n    if (rea && lc) return real_lc();\n    if (lm && lc) return lm_lc();\n  }else if (totalSelecionado == 0){\n    return html`<p>Nenhum dado selecionado.</p>`\n  }\n\n}\n```","srcMarkdownNoYaml":"\n\n\n```{ojs}\nd3 = require(\"d3@7\")\n\ndata = await FileAttachment(\"dados/dados2/erros.csv\").csv()\ntabua_comb = await FileAttachment(\"dados/dados1/previsoes_combinado.csv\").csv()\n\ndata_filter = data.filter(\n    d => d.faixa_etaria === '0' && d.regiao === 'Brasil' && d.taxa === 'Total'\n)\n\n\nhtml`\n<p style=\"text-align: justify;\">Aqui, você encontrará um conjunto de dados detalhados sobre mortalidade dividido entre: Brasil, Regiões e Estados, combinando informações reais extraídas do Instituto Brasileiro de Geografia e Estatística (IBGE) com projeções e análises desenvolvidas por nossa equipe.</p>\n<p style=\"text-align: justify;\">Nosso objetivo é oferecer uma visão clara e acessível sobre a evolução dos padrões de mortalidade, permitindo comparações entre os dados históricos e nossas estimativas futuras. Utilizamos modelos estatísticos e atuariais para gerar previsões que podem ser aplicadas em diversas áreas, como seguros, previdência, saúde pública e planejamento estratégico.</p>\n<p style=\"text-align: justify;\">Explore nossos gráficos interativos e relatórios para entender melhor as tendências e impactos da longevidade no Brasil.</p>\n`\n```\n\n\n## Taxa central de mortalidade de 2000 à 2023 para os modelos de Lee-Miler e Lee-Carter\n\n```{ojs}\nviewof qual = Inputs.checkbox(['Lee-Carter', 'Lee-Miler', 'Observado'], {value: ['Lee-Miler', 'Lee-Carter', 'Observado'], label: 'Modelos:'}) \n\nviewof regiao = Inputs.select([\n  \"Brasil\",\n  \"Norte\",\n  \"Nordeste\",\n  \"Centro-Oeste\",\n  \"Sudeste\",\n  \"Sul\",\n  \"Acre\",\n  \"Alagoas\",\n  \"Amapá\",\n  \"Amazonas\",\n  \"Bahia\",\n  \"Ceará\",\n  \"Distrito Federal\",\n  \"Espírito Santo\",\n  \"Goiás\",\n  \"Maranhão\",\n  \"Mato Grosso\",\n  \"Mato Grosso do Sul\",\n  \"Minas Gerais\",\n  \"Pará\",\n  \"Paraíba\",\n  \"Paraná\",\n  \"Pernambuco\",\n  \"Piauí\",\n  \"Rio de Janeiro\",\n  \"Rio Grande do Norte\",\n  \"Rio Grande do Sul\",\n  \"Rondônia\",\n  \"Roraima\",\n  \"Santa Catarina\",\n  \"São Paulo\",\n  \"Sergipe\",\n  \"Tocantins\"],\n  {\n        value: ['Brasil'],\n        label: \"Local: \"\n    })\n\nhtml`\n<div class=\"grafico-container\">\n  <!-- Legenda HTML -->\n  <div class=\"legenda\">\n    <div class=\"legenda-item\">\n      <div class=\"cor-marcador\" style=\"background: steelblue\"></div>\n      <span>Observado</span>\n    </div>\n    <div class=\"legenda-item\">\n      <div class=\"cor-marcador\" style=\"background: darkorange\"></div>\n      <span>Modelo LC</span>\n    </div>\n    <div class=\"legenda-item\">\n      <div class=\"cor-marcador\" style=\"background: green\"></div>\n      <span>Modelo LM</span>\n    </div>\n  </div>\n\n  <!-- Container do gráfico SVG será injetado aqui -->\n  <div id=\"grafico\"></div>\n</div>\n\n<style>\n.grafico-container {\n  max-width: 800px;\n  margin: 0 auto;\n  font-family: sans-serif;\n}\n\n.legenda {\n  display: flex;\n  gap: 1.5rem;\n  justify-content: center;\n  margin-bottom: 1.5rem;\n}\n\n.legenda-item {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.25rem 0.75rem;\n  background: #f5f5f5;\n  border-radius: 1rem;\n}\n\n.cor-marcador {\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n}\n\n</style>\n`\n\n```\n\n\n```{ojs}\nfunction lm_lc(){\n  //lm e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d => [ d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) => {\n          const linha = d3.line()\n            .x(d => xScale(d.ano))\n            .y(d => yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lm(){\n  //real e lm\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d => [d.mx_real, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) => {\n          const linha = d3.line()\n            .x(d => xScale(d.ano))\n            .y(d => yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\nfunction real_lc(){\n  //real e lc\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d => [d.mx_real, d.mx_lc]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) => {\n          const linha = d3.line()\n            .x(d => xScale(d.ano))\n            .y(d => yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n\n\nfunction todos(){\n  //todos\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Cores para cada série\n    const cores = {\n      mx_real: \"steelblue\",\n      mx_lc: \"darkorange\",\n      mx_lm: \"green\"\n    };\n\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Processamento dos dados\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real),\n          mx_lc: Math.log(+d.mx_lc), // Adiciona transformação\n          mx_lm: Math.log(+d.mx_lm)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n        \n        // Escalas atualizadas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n\n        const yValues = filteredData.flatMap(d => [d.mx_real, d.mx_lc, d.mx_lm]);\n        const yScale = d3.scaleLinear()\n          .domain([d3.min(yValues), d3.max(yValues)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n\n        // Função para gerar linhas\n        const gerarLinha = (variavel, cor) => {\n          const linha = d3.line()\n            .x(d => xScale(d.ano))\n            .y(d => yScale(d[variavel]));\n          \n          subplot.append(\"path\")\n            .datum(filteredData)\n            .attr(\"d\", linha)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", cor)\n            .attr(\"stroke-width\", 2);\n        };\n\n        // Adiciona as três linhas\n        gerarLinha(\"mx_real\", cores.mx_real);\n        gerarLinha(\"mx_lc\", cores.mx_lc);\n        gerarLinha(\"mx_lm\", cores.mx_lm);\n        \n        // Título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\");\n      }\n      \n    }\n\n    return svg.node();\n  }\n}\n\n//real\nfunction real(){\n  {\n    const width = 800;\n    const height = 750;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_real: Math.log(+d.mx_real)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d => d.mx_real), d3.max(filteredData, d => d.mx_real)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d.mx_real));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) => a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"steelblue\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lm\nfunction mx_lm(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d => d.mx_lm), d3.max(filteredData, d => d.mx_lm)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d.mx_lm));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) => a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"green\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n\n//mx_lc\nfunction mx_lc(){\n  {\n    const width = 800;\n    const height = 650;\n    const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n    const numRows = 5;\n    const numCols = 4;\n    \n    // Criação do SVG principal\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Extrai faixas etárias únicas e ordena\n    const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n    \n    // Calcula dimensões dos subplots\n    const subplotWidth = width / numCols;\n    const subplotHeight = height / numRows;\n\n    // Criação dos subplots\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const index = row * numCols + col;\n        if (index >= ageGroups.length) continue;\n        \n        const currentAge = ageGroups[index];\n        const subplot = svg.append(\"g\")\n          .attr(\"transform\", `translate(${col * subplotWidth}, ${row * subplotHeight})`);\n        \n        // Filtra dados para a faixa etária atual\n        const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lc: Math.log(+d.mx_lc)\n        }));\n        \n        // Configura escalas\n        const xScale = d3.scaleLinear()\n          .domain(d3.extent(filteredData, d => d.ano))\n          .range([margin.left, subplotWidth - margin.right]);\n        \n        const yScale = d3.scaleLinear()\n          .domain([d3.min(filteredData, d => d.mx_lc), d3.max(filteredData, d => d.mx_lc)]).nice()\n          .range([subplotHeight - margin.bottom, margin.top]);\n        \n        // Adiciona eixos\n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n          .call(d3.axisBottom(xScale).ticks(5));\n        \n        subplot.append(\"g\")\n          .attr(\"transform\", `translate(${margin.left}, 0)`)\n          .call(d3.axisLeft(yScale).ticks(5));\n        \n        // Adiciona linha\n        const line = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d.mx_lc));\n        \n        subplot.append(\"path\")\n          .datum(filteredData.sort((a, b) => a.ano - b.ano))\n          .attr(\"d\", line)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"darkorange\")\n          .attr(\"stroke-width\", 2);\n        \n        // Adiciona título\n        subplot.append(\"text\")\n          .attr(\"x\", margin.left)\n          .attr(\"y\", margin.top)\n          .text(`Faixa: ${currentAge}`)\n          .attr(\"font-size\", \"12px\")\n          .attr(\"font-weight\", \"bold\", \"center\");\n      }\n    }\n\n    return svg.node();\n  }\n}\n```\n\n```{ojs}\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Observado\")\nlm = qual.includes(\"Lee-Miler\")\nlc = qual.includes(\"Lee-Carter\")\n\n{\n  if(totalSelecionado === 1 ){\n    if (rea) return real();\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  }else if (totalSelecionado === 3){\n    return todos()\n  }else if (totalSelecionado === 2){\n    if (rea && lm) return real_lm();\n    if (rea && lc) return real_lc();\n    if (lm && lc) return lm_lc();\n  }else if (totalSelecionado == 0){\n    return html`<p>Nenhum dado selecionado.</p>`\n  }\n\n}\n```"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"panel":"sidebar","engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"mortalidade.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","theme":"cosmo","title":"Dados de Mortalidade"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}