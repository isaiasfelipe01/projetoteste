{"title":"Modelos","markdown":{"yaml":{"title":"Modelos","execute":{"echo":false,"panel":"sidebar"}},"headingText":"Taxa central de mortalidade de 2000 à 2023 para os modelos de Lee-Miler e Lee-Carter","containsRefs":false,"markdown":"\n\n\n```{ojs}\nd3 = require(\"d3@7\")\n\ndata = await FileAttachment(\"dados/dados2/erros.csv\").csv()\ntabua_comb = await FileAttachment(\"dados/dados1/previsoes_combinado.csv\").csv()\n\n\n\nhtml`\n<p style=\"text-align: justify;\">Aqui, você encontrará um conjunto de dados detalhados sobre mortalidade dividido entre: Brasil, Regiões e Estados, combinando informações reais extraídas do Instituto Brasileiro de Geografia e Estatística (IBGE) com projeções e análises desenvolvidas por nossa equipe.</p>\n<p style=\"text-align: justify;\">Nosso objetivo é oferecer uma visão clara e acessível sobre a evolução dos padrões de mortalidade, permitindo comparações entre os dados históricos e nossas estimativas futuras. Utilizamos modelos estatísticos e atuariais para gerar previsões que podem ser aplicadas em diversas áreas, como seguros, previdência, saúde pública e planejamento estratégico.</p>\n<p style=\"text-align: justify;\">Explore nossos gráficos interativos e relatórios para entender melhor as tendências e impactos da longevidade no Brasil.</p>\n`\n```\n\n\n\n```{ojs}\nviewof qual = Inputs.checkbox(['Lee-Carter', 'Lee-Miler'], {value: ['Lee-Miler', 'Lee-Carter'], label: 'Modelos:'}) \n\nviewof regiao = Inputs.select([\n  \"Brasil\",\n  \"Norte\",\n  \"Nordeste\",\n  \"Centro-Oeste\",\n  \"Sudeste\",\n  \"Sul\",\n  \"Acre\",\n  \"Alagoas\",\n  \"Amapá\",\n  \"Amazonas\",\n  \"Bahia\",\n  \"Ceará\",\n  \"Distrito Federal\",\n  \"Espírito Santo\",\n  \"Goiás\",\n  \"Maranhão\",\n  \"Mato Grosso\",\n  \"Mato Grosso do Sul\",\n  \"Minas Gerais\",\n  \"Pará\",\n  \"Paraíba\",\n  \"Paraná\",\n  \"Pernambuco\",\n  \"Piauí\",\n  \"Rio de Janeiro\",\n  \"Rio Grande do Norte\",\n  \"Rio Grande do Sul\",\n  \"Rondônia\",\n  \"Roraima\",\n  \"Santa Catarina\",\n  \"São Paulo\",\n  \"Sergipe\",\n  \"Tocantins\"],\n  {\n        value: ['Brasil'],\n        label: \"Local: \"\n    })\n```\n::: {.panel-tabset}\n\n## Gráfico\n```{ojs}\nfunction lm_lc(){\n  //lm e lc\n  {\n  const width = 800;\n  const height = 700; // Aumentei a altura total para acomodar a legenda\n  const legendHeight = 50; // Altura dedicada para a legenda\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cores para cada série\n  const cores = {\n    mx_lm: \"blue\",\n    mx_lc: \"darkred\"\n  };\n  \n  const estilos = {\n  mx_lm: \"solid\",      // Linha sólida\n  mx_lc: \"dashed\"      // Linha tracejada\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n  \n  // Título geral\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"Mortalidade por Faixa Etária no Brasil (2000 - 2023) por Modelos de Previsão\")\n    .attr(\"font-size\", \"16px\")\n    .attr(\"font-weight\", \"bold\");\n    \n  // Adiciona legenda em linha horizontal acima dos gráficos\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${width/2 - 150}, 35)`);\n    \n  const legendItems = Object.entries(cores);\n  const legendItemWidth = 100; // Largura de cada item da legenda\n  \n  legendItems.forEach(([key, color], i) => {\n    const itemX = i * legendItemWidth;\n    \n    legend.append(\"rect\")\n      .attr(\"x\", itemX)\n      .attr(\"y\", 0)\n      .attr(\"width\", 15)\n      .attr(\"height\", 15)\n      .attr(\"fill\", color);\n      \n    legend.append(\"text\")\n      .attr(\"x\", itemX + 20)\n      .attr(\"y\", 12)\n      .text(key.charAt(0).toUpperCase() + key.slice(1))\n      .attr(\"font-size\", \"12px\");\n  });\n\n  // Ajuste a área dos gráficos para começar após a legenda\n  const graphsStartY = legendHeight + 10;\n  \n  const subplotWidth = width / numCols;\n  const subplotHeight = (height - graphsStartY) / numRows;\n\n  for (let row = 0; row < numRows; row++) {\n    for (let col = 0; col < numCols; col++) {\n      const index = row * numCols + col;\n      if (index >= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${graphsStartY + row * subplotHeight})`);\n      \n      // Processamento dos dados - filtrando por faixa etária\n      const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm),\n          mx_lc: Math.log(+d.mx_lc)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n      \n      // Verifica se existem dados para esta faixa etária\n      if (filteredData.length === 0) {\n        subplot.append(\"text\")\n          .attr(\"x\", subplotWidth / 2)\n          .attr(\"y\", subplotHeight / 2)\n          .attr(\"text-anchor\", \"middle\")\n          .text(`Sem dados para: ${currentAge}`)\n          .attr(\"font-size\", \"12px\");\n        continue;\n      }\n      \n      // Escalas atualizadas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d => d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n\n      const yValues = filteredData.flatMap(d => [d.mx_lm, d.mx_lc]);\n      const yScale = d3.scaleLinear()\n        .domain([d3.min(yValues), d3.max(yValues)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5))\n        .append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", 30)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"Ano\")\n        .attr(\"fill\", \"black\");\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5))\n        .append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"y\", -30)\n        .attr(\"x\", -subplotHeight / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"log(Mx)\")\n        .attr(\"fill\", \"black\");\n\n      // Função para gerar linhas\n      const gerarLinha = (variavel, cor, estilo) => {\n        const linha = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d[variavel]));\n          //.curve(d3.curveMonotoneX); // Adiciona suavização para as linhas\n        \n        subplot.append(\"path\")\n          .datum(filteredData)\n          .attr(\"d\", linha)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", cor)\n          .attr(\"stroke-dasharray\", estilo === \"dashed\" ? \"5,5\" : \"0\")\n          .attr(\"stroke-width\", 2);\n\n      };\n\n      // Adiciona as três linhas\n      gerarLinha(\"mx_lm\", cores.mx_lm, estilos.mx_lm);\n      gerarLinha(\"mx_lc\", cores.mx_lc, estilos.mx_lc);\n      \n      // Título\n      subplot.append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", margin.top / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n    \n  return svg.node();\n}}\n\nfunction mx_lm(){\n  //real e lm\n  {\n  const width = 800;\n  const height = 700; // Aumentei a altura total para acomodar a legenda\n  const legendHeight = 50; // Altura dedicada para a legenda\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cores para cada série\n  const cores = {\n    mx_lm: \"blue\",\n    mx_lc: \"darckred\"\n  };\n  \n  const estilos = {\n  mx_lm: \"solid\",      // Linha sólida\n  mx_lc: \"dashed\"      // Linha tracejada\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n  \n  // Título geral\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"Mortalidade por Faixa Etária no Brasil (2000 - 2023) por Modelos de Previsão\")\n    .attr(\"font-size\", \"16px\")\n    .attr(\"font-weight\", \"bold\");\n    \n  // Adiciona legenda em linha horizontal acima dos gráficos\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${width/2 - 150}, 35)`);\n    \n  const legendItems = Object.entries(cores);\n  const legendItemWidth = 100; // Largura de cada item da legenda\n  \n  legendItems.forEach(([key, color], i) => {\n    const itemX = i * legendItemWidth;\n    \n    legend.append(\"rect\")\n      .attr(\"x\", itemX)\n      .attr(\"y\", 0)\n      .attr(\"width\", 15)\n      .attr(\"height\", 15)\n      .attr(\"fill\", color);\n      \n    legend.append(\"text\")\n      .attr(\"x\", itemX + 20)\n      .attr(\"y\", 12)\n      .text(key.charAt(0).toUpperCase() + key.slice(1))\n      .attr(\"font-size\", \"12px\");\n  });\n\n  // Ajuste a área dos gráficos para começar após a legenda\n  const graphsStartY = legendHeight + 10;\n  \n  const subplotWidth = width / numCols;\n  const subplotHeight = (height - graphsStartY) / numRows;\n\n  for (let row = 0; row < numRows; row++) {\n    for (let col = 0; col < numCols; col++) {\n      const index = row * numCols + col;\n      if (index >= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${graphsStartY + row * subplotHeight})`);\n      \n      // Processamento dos dados - filtrando por faixa etária\n      const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm),\n          mx_lc: Math.log(+d.mx_lc)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n      \n      // Verifica se existem dados para esta faixa etária\n      if (filteredData.length === 0) {\n        subplot.append(\"text\")\n          .attr(\"x\", subplotWidth / 2)\n          .attr(\"y\", subplotHeight / 2)\n          .attr(\"text-anchor\", \"middle\")\n          .text(`Sem dados para: ${currentAge}`)\n          .attr(\"font-size\", \"12px\");\n        continue;\n      }\n      \n      // Escalas atualizadas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d => d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n\n      const yValues = filteredData.flatMap(d => [d.mx_lm, d.mx_lc]);\n      const yScale = d3.scaleLinear()\n        .domain([d3.min(yValues), d3.max(yValues)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5))\n        .append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", 30)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"Ano\")\n        .attr(\"fill\", \"black\");\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5))\n        .append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"y\", -30)\n        .attr(\"x\", -subplotHeight / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"log(Mx)\")\n        .attr(\"fill\", \"black\");\n\n      // Função para gerar linhas\n      const gerarLinha = (variavel, cor, estilo) => {\n        const linha = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d[variavel]));\n          //.curve(d3.curveMonotoneX); // Adiciona suavização para as linhas\n        \n        subplot.append(\"path\")\n          .datum(filteredData)\n          .attr(\"d\", linha)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", cor)\n          .attr(\"stroke-dasharray\", estilo === \"dashed\" ? \"5,5\" : \"0\")\n          .attr(\"stroke-width\", 2);\n\n      };\n\n      // Adiciona as três linhas\n      gerarLinha(\"mx_lm\", cores.mx_lm, estilos.mx_lm);\n      //gerarLinha(\"mx_lc\", cores.mx_lc, estilos.mx_lc);\n      \n      // Título\n      subplot.append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", margin.top / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n    \n  return svg.node();\n}\n}\n\nfunction mx_lc(){\n  //real e lc\n  {\n  const width = 800;\n  const height = 700; // Aumentei a altura total para acomodar a legenda\n  const legendHeight = 50; // Altura dedicada para a legenda\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cores para cada série\n  const cores = {\n    mx_lm: \"blue\",\n    mx_lc: \"darckred\"\n  };\n  \n  const estilos = {\n  mx_lm: \"solid\",      // Linha sólida\n  mx_lc: \"solid\"      // Linha tracejada\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n  \n  // Título geral\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"Mortalidade por Faixa Etária no Brasil (2000 - 2023) por Modelos de Previsão\")\n    .attr(\"font-size\", \"16px\")\n    .attr(\"font-weight\", \"bold\");\n    \n  // Adiciona legenda em linha horizontal acima dos gráficos\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${width/2 - 150}, 35)`);\n    \n  const legendItems = Object.entries(cores);\n  const legendItemWidth = 100; // Largura de cada item da legenda\n  \n  legendItems.forEach(([key, color], i) => {\n    const itemX = i * legendItemWidth;\n    \n    legend.append(\"rect\")\n      .attr(\"x\", itemX)\n      .attr(\"y\", 0)\n      .attr(\"width\", 15)\n      .attr(\"height\", 15)\n      .attr(\"fill\", color);\n      \n    legend.append(\"text\")\n      .attr(\"x\", itemX + 20)\n      .attr(\"y\", 12)\n      .text(key.charAt(0).toUpperCase() + key.slice(1))\n      .attr(\"font-size\", \"12px\");\n  });\n\n  // Ajuste a área dos gráficos para começar após a legenda\n  const graphsStartY = legendHeight + 10;\n  \n  const subplotWidth = width / numCols;\n  const subplotHeight = (height - graphsStartY) / numRows;\n\n  for (let row = 0; row < numRows; row++) {\n    for (let col = 0; col < numCols; col++) {\n      const index = row * numCols + col;\n      if (index >= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${graphsStartY + row * subplotHeight})`);\n      \n      // Processamento dos dados - filtrando por faixa etária\n      const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm),\n          mx_lc: Math.log(+d.mx_lc)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n      \n      // Verifica se existem dados para esta faixa etária\n      if (filteredData.length === 0) {\n        subplot.append(\"text\")\n          .attr(\"x\", subplotWidth / 2)\n          .attr(\"y\", subplotHeight / 2)\n          .attr(\"text-anchor\", \"middle\")\n          .text(`Sem dados para: ${currentAge}`)\n          .attr(\"font-size\", \"12px\");\n        continue;\n      }\n      \n      // Escalas atualizadas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d => d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n\n      const yValues = filteredData.flatMap(d => [d.mx_lm, d.mx_lc]);\n      const yScale = d3.scaleLinear()\n        .domain([d3.min(yValues), d3.max(yValues)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5))\n        .append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", 30)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"Ano\")\n        .attr(\"fill\", \"black\");\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5))\n        .append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"y\", -30)\n        .attr(\"x\", -subplotHeight / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"log(Mx)\")\n        .attr(\"fill\", \"black\");\n\n      // Função para gerar linhas\n      const gerarLinha = (variavel, cor, estilo) => {\n        const linha = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d[variavel]));\n          //.curve(d3.curveMonotoneX); // Adiciona suavização para as linhas\n        \n        subplot.append(\"path\")\n          .datum(filteredData)\n          .attr(\"d\", linha)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", cor)\n          .attr(\"stroke-dasharray\", estilo === \"dashed\" ? \"5,5\" : \"0\")\n          .attr(\"stroke-width\", 2);\n\n      };\n\n      // Adiciona as três linhas\n      //gerarLinha(\"mx_lm\", cores.mx_lm, estilos.mx_lm);\n      gerarLinha(\"mx_lc\", cores.mx_lc, estilos.mx_lc);\n      \n      // Título\n      subplot.append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", margin.top / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n    \n  return svg.node();\n}}\n\n```\n\n```{ojs}\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Observado\")\nlm = qual.includes(\"Lee-Miler\")\nlc = qual.includes(\"Lee-Carter\")\n\n{\n  if(totalSelecionado === 1 ){\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  }else if (totalSelecionado === 2){\n    if (lm && lc) return lm_lc();\n  }else if (totalSelecionado == 0){\n    return html`<p>Nenhum dado selecionado.</p>`\n  }\n\n}\n```\n\n## Dados\n\n```{ojs}\nInputs.table(data)\nhtml`\n<body>\n    <br>\n    <p>Baixar \n    <a href=\"dados/dados2/erros.csv\" download>\n        dados.\n    </a>\n    </p>\n</body>\n`\n```","srcMarkdownNoYaml":"\n\n\n```{ojs}\nd3 = require(\"d3@7\")\n\ndata = await FileAttachment(\"dados/dados2/erros.csv\").csv()\ntabua_comb = await FileAttachment(\"dados/dados1/previsoes_combinado.csv\").csv()\n\n\n\nhtml`\n<p style=\"text-align: justify;\">Aqui, você encontrará um conjunto de dados detalhados sobre mortalidade dividido entre: Brasil, Regiões e Estados, combinando informações reais extraídas do Instituto Brasileiro de Geografia e Estatística (IBGE) com projeções e análises desenvolvidas por nossa equipe.</p>\n<p style=\"text-align: justify;\">Nosso objetivo é oferecer uma visão clara e acessível sobre a evolução dos padrões de mortalidade, permitindo comparações entre os dados históricos e nossas estimativas futuras. Utilizamos modelos estatísticos e atuariais para gerar previsões que podem ser aplicadas em diversas áreas, como seguros, previdência, saúde pública e planejamento estratégico.</p>\n<p style=\"text-align: justify;\">Explore nossos gráficos interativos e relatórios para entender melhor as tendências e impactos da longevidade no Brasil.</p>\n`\n```\n\n\n## Taxa central de mortalidade de 2000 à 2023 para os modelos de Lee-Miler e Lee-Carter\n\n```{ojs}\nviewof qual = Inputs.checkbox(['Lee-Carter', 'Lee-Miler'], {value: ['Lee-Miler', 'Lee-Carter'], label: 'Modelos:'}) \n\nviewof regiao = Inputs.select([\n  \"Brasil\",\n  \"Norte\",\n  \"Nordeste\",\n  \"Centro-Oeste\",\n  \"Sudeste\",\n  \"Sul\",\n  \"Acre\",\n  \"Alagoas\",\n  \"Amapá\",\n  \"Amazonas\",\n  \"Bahia\",\n  \"Ceará\",\n  \"Distrito Federal\",\n  \"Espírito Santo\",\n  \"Goiás\",\n  \"Maranhão\",\n  \"Mato Grosso\",\n  \"Mato Grosso do Sul\",\n  \"Minas Gerais\",\n  \"Pará\",\n  \"Paraíba\",\n  \"Paraná\",\n  \"Pernambuco\",\n  \"Piauí\",\n  \"Rio de Janeiro\",\n  \"Rio Grande do Norte\",\n  \"Rio Grande do Sul\",\n  \"Rondônia\",\n  \"Roraima\",\n  \"Santa Catarina\",\n  \"São Paulo\",\n  \"Sergipe\",\n  \"Tocantins\"],\n  {\n        value: ['Brasil'],\n        label: \"Local: \"\n    })\n```\n::: {.panel-tabset}\n\n## Gráfico\n```{ojs}\nfunction lm_lc(){\n  //lm e lc\n  {\n  const width = 800;\n  const height = 700; // Aumentei a altura total para acomodar a legenda\n  const legendHeight = 50; // Altura dedicada para a legenda\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cores para cada série\n  const cores = {\n    mx_lm: \"blue\",\n    mx_lc: \"darkred\"\n  };\n  \n  const estilos = {\n  mx_lm: \"solid\",      // Linha sólida\n  mx_lc: \"dashed\"      // Linha tracejada\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n  \n  // Título geral\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"Mortalidade por Faixa Etária no Brasil (2000 - 2023) por Modelos de Previsão\")\n    .attr(\"font-size\", \"16px\")\n    .attr(\"font-weight\", \"bold\");\n    \n  // Adiciona legenda em linha horizontal acima dos gráficos\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${width/2 - 150}, 35)`);\n    \n  const legendItems = Object.entries(cores);\n  const legendItemWidth = 100; // Largura de cada item da legenda\n  \n  legendItems.forEach(([key, color], i) => {\n    const itemX = i * legendItemWidth;\n    \n    legend.append(\"rect\")\n      .attr(\"x\", itemX)\n      .attr(\"y\", 0)\n      .attr(\"width\", 15)\n      .attr(\"height\", 15)\n      .attr(\"fill\", color);\n      \n    legend.append(\"text\")\n      .attr(\"x\", itemX + 20)\n      .attr(\"y\", 12)\n      .text(key.charAt(0).toUpperCase() + key.slice(1))\n      .attr(\"font-size\", \"12px\");\n  });\n\n  // Ajuste a área dos gráficos para começar após a legenda\n  const graphsStartY = legendHeight + 10;\n  \n  const subplotWidth = width / numCols;\n  const subplotHeight = (height - graphsStartY) / numRows;\n\n  for (let row = 0; row < numRows; row++) {\n    for (let col = 0; col < numCols; col++) {\n      const index = row * numCols + col;\n      if (index >= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${graphsStartY + row * subplotHeight})`);\n      \n      // Processamento dos dados - filtrando por faixa etária\n      const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm),\n          mx_lc: Math.log(+d.mx_lc)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n      \n      // Verifica se existem dados para esta faixa etária\n      if (filteredData.length === 0) {\n        subplot.append(\"text\")\n          .attr(\"x\", subplotWidth / 2)\n          .attr(\"y\", subplotHeight / 2)\n          .attr(\"text-anchor\", \"middle\")\n          .text(`Sem dados para: ${currentAge}`)\n          .attr(\"font-size\", \"12px\");\n        continue;\n      }\n      \n      // Escalas atualizadas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d => d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n\n      const yValues = filteredData.flatMap(d => [d.mx_lm, d.mx_lc]);\n      const yScale = d3.scaleLinear()\n        .domain([d3.min(yValues), d3.max(yValues)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5))\n        .append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", 30)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"Ano\")\n        .attr(\"fill\", \"black\");\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5))\n        .append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"y\", -30)\n        .attr(\"x\", -subplotHeight / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"log(Mx)\")\n        .attr(\"fill\", \"black\");\n\n      // Função para gerar linhas\n      const gerarLinha = (variavel, cor, estilo) => {\n        const linha = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d[variavel]));\n          //.curve(d3.curveMonotoneX); // Adiciona suavização para as linhas\n        \n        subplot.append(\"path\")\n          .datum(filteredData)\n          .attr(\"d\", linha)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", cor)\n          .attr(\"stroke-dasharray\", estilo === \"dashed\" ? \"5,5\" : \"0\")\n          .attr(\"stroke-width\", 2);\n\n      };\n\n      // Adiciona as três linhas\n      gerarLinha(\"mx_lm\", cores.mx_lm, estilos.mx_lm);\n      gerarLinha(\"mx_lc\", cores.mx_lc, estilos.mx_lc);\n      \n      // Título\n      subplot.append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", margin.top / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n    \n  return svg.node();\n}}\n\nfunction mx_lm(){\n  //real e lm\n  {\n  const width = 800;\n  const height = 700; // Aumentei a altura total para acomodar a legenda\n  const legendHeight = 50; // Altura dedicada para a legenda\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cores para cada série\n  const cores = {\n    mx_lm: \"blue\",\n    mx_lc: \"darckred\"\n  };\n  \n  const estilos = {\n  mx_lm: \"solid\",      // Linha sólida\n  mx_lc: \"dashed\"      // Linha tracejada\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n  \n  // Título geral\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"Mortalidade por Faixa Etária no Brasil (2000 - 2023) por Modelos de Previsão\")\n    .attr(\"font-size\", \"16px\")\n    .attr(\"font-weight\", \"bold\");\n    \n  // Adiciona legenda em linha horizontal acima dos gráficos\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${width/2 - 150}, 35)`);\n    \n  const legendItems = Object.entries(cores);\n  const legendItemWidth = 100; // Largura de cada item da legenda\n  \n  legendItems.forEach(([key, color], i) => {\n    const itemX = i * legendItemWidth;\n    \n    legend.append(\"rect\")\n      .attr(\"x\", itemX)\n      .attr(\"y\", 0)\n      .attr(\"width\", 15)\n      .attr(\"height\", 15)\n      .attr(\"fill\", color);\n      \n    legend.append(\"text\")\n      .attr(\"x\", itemX + 20)\n      .attr(\"y\", 12)\n      .text(key.charAt(0).toUpperCase() + key.slice(1))\n      .attr(\"font-size\", \"12px\");\n  });\n\n  // Ajuste a área dos gráficos para começar após a legenda\n  const graphsStartY = legendHeight + 10;\n  \n  const subplotWidth = width / numCols;\n  const subplotHeight = (height - graphsStartY) / numRows;\n\n  for (let row = 0; row < numRows; row++) {\n    for (let col = 0; col < numCols; col++) {\n      const index = row * numCols + col;\n      if (index >= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${graphsStartY + row * subplotHeight})`);\n      \n      // Processamento dos dados - filtrando por faixa etária\n      const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm),\n          mx_lc: Math.log(+d.mx_lc)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n      \n      // Verifica se existem dados para esta faixa etária\n      if (filteredData.length === 0) {\n        subplot.append(\"text\")\n          .attr(\"x\", subplotWidth / 2)\n          .attr(\"y\", subplotHeight / 2)\n          .attr(\"text-anchor\", \"middle\")\n          .text(`Sem dados para: ${currentAge}`)\n          .attr(\"font-size\", \"12px\");\n        continue;\n      }\n      \n      // Escalas atualizadas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d => d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n\n      const yValues = filteredData.flatMap(d => [d.mx_lm, d.mx_lc]);\n      const yScale = d3.scaleLinear()\n        .domain([d3.min(yValues), d3.max(yValues)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5))\n        .append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", 30)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"Ano\")\n        .attr(\"fill\", \"black\");\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5))\n        .append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"y\", -30)\n        .attr(\"x\", -subplotHeight / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"log(Mx)\")\n        .attr(\"fill\", \"black\");\n\n      // Função para gerar linhas\n      const gerarLinha = (variavel, cor, estilo) => {\n        const linha = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d[variavel]));\n          //.curve(d3.curveMonotoneX); // Adiciona suavização para as linhas\n        \n        subplot.append(\"path\")\n          .datum(filteredData)\n          .attr(\"d\", linha)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", cor)\n          .attr(\"stroke-dasharray\", estilo === \"dashed\" ? \"5,5\" : \"0\")\n          .attr(\"stroke-width\", 2);\n\n      };\n\n      // Adiciona as três linhas\n      gerarLinha(\"mx_lm\", cores.mx_lm, estilos.mx_lm);\n      //gerarLinha(\"mx_lc\", cores.mx_lc, estilos.mx_lc);\n      \n      // Título\n      subplot.append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", margin.top / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n    \n  return svg.node();\n}\n}\n\nfunction mx_lc(){\n  //real e lc\n  {\n  const width = 800;\n  const height = 700; // Aumentei a altura total para acomodar a legenda\n  const legendHeight = 50; // Altura dedicada para a legenda\n  const margin = { top: 30, right: 20, bottom: 40, left: 50 };\n  const numRows = 5;\n  const numCols = 4;\n  \n  // Cores para cada série\n  const cores = {\n    mx_lm: \"blue\",\n    mx_lc: \"darckred\"\n  };\n  \n  const estilos = {\n  mx_lm: \"solid\",      // Linha sólida\n  mx_lc: \"solid\"      // Linha tracejada\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\n  const ageGroups = [...new Set(data.map(d => d.faixa_etaria))].sort();\n  \n  // Título geral\n  svg.append(\"text\")\n    .attr(\"x\", width / 2)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .text(\"Mortalidade por Faixa Etária no Brasil (2000 - 2023) por Modelos de Previsão\")\n    .attr(\"font-size\", \"16px\")\n    .attr(\"font-weight\", \"bold\");\n    \n  // Adiciona legenda em linha horizontal acima dos gráficos\n  const legend = svg.append(\"g\")\n    .attr(\"transform\", `translate(${width/2 - 150}, 35)`);\n    \n  const legendItems = Object.entries(cores);\n  const legendItemWidth = 100; // Largura de cada item da legenda\n  \n  legendItems.forEach(([key, color], i) => {\n    const itemX = i * legendItemWidth;\n    \n    legend.append(\"rect\")\n      .attr(\"x\", itemX)\n      .attr(\"y\", 0)\n      .attr(\"width\", 15)\n      .attr(\"height\", 15)\n      .attr(\"fill\", color);\n      \n    legend.append(\"text\")\n      .attr(\"x\", itemX + 20)\n      .attr(\"y\", 12)\n      .text(key.charAt(0).toUpperCase() + key.slice(1))\n      .attr(\"font-size\", \"12px\");\n  });\n\n  // Ajuste a área dos gráficos para começar após a legenda\n  const graphsStartY = legendHeight + 10;\n  \n  const subplotWidth = width / numCols;\n  const subplotHeight = (height - graphsStartY) / numRows;\n\n  for (let row = 0; row < numRows; row++) {\n    for (let col = 0; col < numCols; col++) {\n      const index = row * numCols + col;\n      if (index >= ageGroups.length) continue;\n      \n      const currentAge = ageGroups[index];\n      const subplot = svg.append(\"g\")\n        .attr(\"transform\", `translate(${col * subplotWidth}, ${graphsStartY + row * subplotHeight})`);\n      \n      // Processamento dos dados - filtrando por faixa etária\n      const filteredData = data.filter(d => \n          d.faixa_etaria === currentAge && \n          d.regiao === regiao && \n          d.taxa === 'Total'\n        ).map(d => ({\n          ...d,\n          ano: +d.ano,\n          mx_lm: Math.log(+d.mx_lm),\n          mx_lc: Math.log(+d.mx_lc)  // Adiciona transformação\n        })).sort((a, b) => a.ano - b.ano);\n      \n      // Verifica se existem dados para esta faixa etária\n      if (filteredData.length === 0) {\n        subplot.append(\"text\")\n          .attr(\"x\", subplotWidth / 2)\n          .attr(\"y\", subplotHeight / 2)\n          .attr(\"text-anchor\", \"middle\")\n          .text(`Sem dados para: ${currentAge}`)\n          .attr(\"font-size\", \"12px\");\n        continue;\n      }\n      \n      // Escalas atualizadas\n      const xScale = d3.scaleLinear()\n        .domain(d3.extent(filteredData, d => d.ano))\n        .range([margin.left, subplotWidth - margin.right]);\n\n      const yValues = filteredData.flatMap(d => [d.mx_lm, d.mx_lc]);\n      const yScale = d3.scaleLinear()\n        .domain([d3.min(yValues), d3.max(yValues)]).nice()\n        .range([subplotHeight - margin.bottom, margin.top]);\n      \n      // Eixos\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(0, ${subplotHeight - margin.bottom})`)\n        .call(d3.axisBottom(xScale).ticks(5))\n        .append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", 30)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"Ano\")\n        .attr(\"fill\", \"black\");\n\n      subplot.append(\"g\")\n        .attr(\"transform\", `translate(${margin.left}, 0)`)\n        .call(d3.axisLeft(yScale).ticks(5))\n        .append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"y\", -30)\n        .attr(\"x\", -subplotHeight / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"log(Mx)\")\n        .attr(\"fill\", \"black\");\n\n      // Função para gerar linhas\n      const gerarLinha = (variavel, cor, estilo) => {\n        const linha = d3.line()\n          .x(d => xScale(d.ano))\n          .y(d => yScale(d[variavel]));\n          //.curve(d3.curveMonotoneX); // Adiciona suavização para as linhas\n        \n        subplot.append(\"path\")\n          .datum(filteredData)\n          .attr(\"d\", linha)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", cor)\n          .attr(\"stroke-dasharray\", estilo === \"dashed\" ? \"5,5\" : \"0\")\n          .attr(\"stroke-width\", 2);\n\n      };\n\n      // Adiciona as três linhas\n      //gerarLinha(\"mx_lm\", cores.mx_lm, estilos.mx_lm);\n      gerarLinha(\"mx_lc\", cores.mx_lc, estilos.mx_lc);\n      \n      // Título\n      subplot.append(\"text\")\n        .attr(\"x\", subplotWidth / 2)\n        .attr(\"y\", margin.top / 2)\n        .attr(\"text-anchor\", \"middle\")\n        .text(`Faixa: ${currentAge}`)\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"bold\");\n    }\n  }\n    \n  return svg.node();\n}}\n\n```\n\n```{ojs}\ntotalSelecionado = qual.length;\nrea = qual.includes(\"Observado\")\nlm = qual.includes(\"Lee-Miler\")\nlc = qual.includes(\"Lee-Carter\")\n\n{\n  if(totalSelecionado === 1 ){\n    if (lm) return mx_lm();\n    if (lc) return mx_lc();\n  }else if (totalSelecionado === 2){\n    if (lm && lc) return lm_lc();\n  }else if (totalSelecionado == 0){\n    return html`<p>Nenhum dado selecionado.</p>`\n  }\n\n}\n```\n\n## Dados\n\n```{ojs}\nInputs.table(data)\nhtml`\n<body>\n    <br>\n    <p>Baixar \n    <a href=\"dados/dados2/erros.csv\" download>\n        dados.\n    </a>\n    </p>\n</body>\n`\n```"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"panel":"sidebar","engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"modelos.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","theme":"cosmo","title":"Modelos"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}